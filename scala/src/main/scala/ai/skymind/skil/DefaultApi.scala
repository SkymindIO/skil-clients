/**
 * Endpoints
 * Endpoints API for different services in SKIL
 *
 * OpenAPI spec version: 1.2.0-rc1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ai.skymind.skil

import java.text.SimpleDateFormat

import ai.skymind.skil.model.AccumulatedResults
import ai.skymind.skil.model.AddCredentialsRequest
import ai.skymind.skil.model.AddExampleRequest
import ai.skymind.skil.model.AddModelHistoryRequest
import ai.skymind.skil.model.AddResourceRequest
import ai.skymind.skil.model.AggregatePrediction
import ai.skymind.skil.model.ArrayByte
import ai.skymind.skil.model.AuthPolicy
import ai.skymind.skil.model.Base64NDArrayBody
import ai.skymind.skil.model.Base64NDArrayBodyKNN
import ai.skymind.skil.model.BatchCSVRecord
import ai.skymind.skil.model.BatchRecord
import ai.skymind.skil.model.BestModel
import ai.skymind.skil.model.ChangePasswordRequest
import ai.skymind.skil.model.ClassificationResult
import ai.skymind.skil.model.CreateDeploymentRequest
import ai.skymind.skil.model.CreateJobRequest
import ai.skymind.skil.model.DeploymentResponse
import ai.skymind.skil.model.DetectionResult
import ai.skymind.skil.model.DownloadOutputFileRequest
import ai.skymind.skil.model.EvaluationResultsEntity
import ai.skymind.skil.model.ExampleEntity
import ai.skymind.skil.model.ExperimentEntity
import ai.skymind.skil.model.FeedbackResponse
import java.io.File
import ai.skymind.skil.model.FileUploadList
import ai.skymind.skil.model.ImportModelRequest
import ai.skymind.skil.model.InlineResponse200
import ai.skymind.skil.model.JobEntity
import ai.skymind.skil.model.JsonArrayResponse
import ai.skymind.skil.model.LogBatch
import ai.skymind.skil.model.LogRequest
import ai.skymind.skil.model.LoginRequest
import ai.skymind.skil.model.LoginResponse
import ai.skymind.skil.model.MetaData
import ai.skymind.skil.model.MinibatchEntity
import ai.skymind.skil.model.ModelEntity
import ai.skymind.skil.model.ModelFeedBackRequest
import ai.skymind.skil.model.ModelHistoryEntity
import ai.skymind.skil.model.ModelInstanceEntity
import ai.skymind.skil.model.ModelStatus
import ai.skymind.skil.model.MultiClassClassificationResult
import ai.skymind.skil.model.MultiPredictRequest
import ai.skymind.skil.model.MultiPredictResponse
import ai.skymind.skil.model.NearestNeighborRequest
import ai.skymind.skil.model.NearestNeighborsResults
import ai.skymind.skil.model.Prediction
import ai.skymind.skil.model.Resource
import ai.skymind.skil.model.ResourceCredentials
import ai.skymind.skil.model.ResourceGroup
import ai.skymind.skil.model.RetrainingStatus
import ai.skymind.skil.model.RevisionsWritten
import ai.skymind.skil.model.Role
import ai.skymind.skil.model.RollbackStatus
import ai.skymind.skil.model.SetState
import ai.skymind.skil.model.SingleCSVRecord
import ai.skymind.skil.model.SingleRecord
import ai.skymind.skil.model.Token
import ai.skymind.skil.model.TokenGenerateRequest
import ai.skymind.skil.model.UpdateBestModel
import ai.skymind.skil.model.User
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class DefaultApi(
  val defBasePath: String = "http://localhost:9008",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new DefaultApiAsyncHelper(client, config)

  /**
   * Tells how many retraining examples have labels associated with them.
   * 
   *
   * @return AccumulatedResults
   */
  def accumulatedResults(): Option[AccumulatedResults] = {
    val await = Try(Await.result(accumulatedResultsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Tells how many retraining examples have labels associated with them. asynchronously
   * 
   *
   * @return Future(AccumulatedResults)
   */
  def accumulatedResultsAsync(): Future[AccumulatedResults] = {
      helper.accumulatedResults()
  }

  /**
   * Adds credentials
   * 
   *
   * @param AddCredentialsRequest Add credentials request object 
   * @return ResourceCredentials
   */
  def addCredentials(AddCredentialsRequest: AddCredentialsRequest): Option[ResourceCredentials] = {
    val await = Try(Await.result(addCredentialsAsync(AddCredentialsRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds credentials asynchronously
   * 
   *
   * @param AddCredentialsRequest Add credentials request object 
   * @return Future(ResourceCredentials)
   */
  def addCredentialsAsync(AddCredentialsRequest: AddCredentialsRequest): Future[ResourceCredentials] = {
      helper.addCredentials(AddCredentialsRequest)
  }

  /**
   * Adds an evaluation result
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param EvaluationResultsEntity The evaluation result entity 
   * @return EvaluationResultsEntity
   */
  def addEvaluationResult(ModelHistoryServerId: String, EvaluationResultsEntity: EvaluationResultsEntity): Option[EvaluationResultsEntity] = {
    val await = Try(Await.result(addEvaluationResultAsync(ModelHistoryServerId, EvaluationResultsEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an evaluation result asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param EvaluationResultsEntity The evaluation result entity 
   * @return Future(EvaluationResultsEntity)
   */
  def addEvaluationResultAsync(ModelHistoryServerId: String, EvaluationResultsEntity: EvaluationResultsEntity): Future[EvaluationResultsEntity] = {
      helper.addEvaluationResult(ModelHistoryServerId, EvaluationResultsEntity)
  }

  /**
   * Adds a number of examples to a minibatch ID given an AddExampleRequest.
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddExampleRequest The add example request, encapsulating minibatch details and examples batch size 
   * @return AddExampleRequest
   */
  def addExampleForBatch(ModelHistoryServerId: String, AddExampleRequest: AddExampleRequest): Option[AddExampleRequest] = {
    val await = Try(Await.result(addExampleForBatchAsync(ModelHistoryServerId, AddExampleRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a number of examples to a minibatch ID given an AddExampleRequest. asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddExampleRequest The add example request, encapsulating minibatch details and examples batch size 
   * @return Future(AddExampleRequest)
   */
  def addExampleForBatchAsync(ModelHistoryServerId: String, AddExampleRequest: AddExampleRequest): Future[AddExampleRequest] = {
      helper.addExampleForBatch(ModelHistoryServerId, AddExampleRequest)
  }

  /**
   * Adds an example to a minibatch
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExampleEntity The example to add to the minibatch 
   * @return ExampleEntity
   */
  def addExampleToMinibatch(ModelHistoryServerId: String, ExampleEntity: ExampleEntity): Option[ExampleEntity] = {
    val await = Try(Await.result(addExampleToMinibatchAsync(ModelHistoryServerId, ExampleEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an example to a minibatch asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExampleEntity The example to add to the minibatch 
   * @return Future(ExampleEntity)
   */
  def addExampleToMinibatchAsync(ModelHistoryServerId: String, ExampleEntity: ExampleEntity): Future[ExampleEntity] = {
      helper.addExampleToMinibatch(ModelHistoryServerId, ExampleEntity)
  }

  /**
   * Add an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentEntity The experiment entity to add 
   * @return ExperimentEntity
   */
  def addExperiment(ModelHistoryServerId: String, ExperimentEntity: ExperimentEntity): Option[ExperimentEntity] = {
    val await = Try(Await.result(addExperimentAsync(ModelHistoryServerId, ExperimentEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentEntity The experiment entity to add 
   * @return Future(ExperimentEntity)
   */
  def addExperimentAsync(ModelHistoryServerId: String, ExperimentEntity: ExperimentEntity): Future[ExperimentEntity] = {
      helper.addExperiment(ModelHistoryServerId, ExperimentEntity)
  }

  /**
   * 
   * 
   *
   * @param Id Batch ID to retrain the model with and get feedback for. 
   * @param `Type` The type of the labels array. 
   * @param File The labels file to upload. (optional)
   * @return FeedbackResponse
   */
  def addFeedbackBinary(Id: String, `Type`: String, File: Option[File] = None): Option[FeedbackResponse] = {
    val await = Try(Await.result(addFeedbackBinaryAsync(Id, `Type`, File), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param Id Batch ID to retrain the model with and get feedback for. 
   * @param `Type` The type of the labels array. 
   * @param File The labels file to upload. (optional)
   * @return Future(FeedbackResponse)
   */
  def addFeedbackBinaryAsync(Id: String, `Type`: String, File: Option[File] = None): Future[FeedbackResponse] = {
      helper.addFeedbackBinary(Id, `Type`, File)
  }

  /**
   * Gets the retraining feedback for the given batch ID.
   * 
   *
   * @param Id Batch ID to retrain the model with and get feedback for. 
   * @param Labels The associated labels (one-hot vectors) with the batch for retraining. (optional)
   * @return FeedbackResponse
   */
  def addFeedbackJson(Id: String, Labels: Option[List[List[Double]]] = None): Option[FeedbackResponse] = {
    val await = Try(Await.result(addFeedbackJsonAsync(Id, Labels), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the retraining feedback for the given batch ID. asynchronously
   * 
   *
   * @param Id Batch ID to retrain the model with and get feedback for. 
   * @param Labels The associated labels (one-hot vectors) with the batch for retraining. (optional)
   * @return Future(FeedbackResponse)
   */
  def addFeedbackJsonAsync(Id: String, Labels: Option[List[List[Double]]] = None): Future[FeedbackResponse] = {
      helper.addFeedbackJson(Id, Labels)
  }

  /**
   * Adds a minibatch
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchEntity The minibatch entity to add 
   * @return MinibatchEntity
   */
  def addMinibatch(ModelHistoryServerId: String, MinibatchEntity: MinibatchEntity): Option[MinibatchEntity] = {
    val await = Try(Await.result(addMinibatchAsync(ModelHistoryServerId, MinibatchEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a minibatch asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchEntity The minibatch entity to add 
   * @return Future(MinibatchEntity)
   */
  def addMinibatchAsync(ModelHistoryServerId: String, MinibatchEntity: MinibatchEntity): Future[MinibatchEntity] = {
      helper.addMinibatch(ModelHistoryServerId, MinibatchEntity)
  }

  /**
   * Adds an evaluation feedback to the model against a given minibatch id.
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelFeedBackRequest The model feedback request object 
   * @return ModelFeedBackRequest
   */
  def addModelFeedback(ModelHistoryServerId: String, ModelFeedBackRequest: ModelFeedBackRequest): Option[ModelFeedBackRequest] = {
    val await = Try(Await.result(addModelFeedbackAsync(ModelHistoryServerId, ModelFeedBackRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an evaluation feedback to the model against a given minibatch id. asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelFeedBackRequest The model feedback request object 
   * @return Future(ModelFeedBackRequest)
   */
  def addModelFeedbackAsync(ModelHistoryServerId: String, ModelFeedBackRequest: ModelFeedBackRequest): Future[ModelFeedBackRequest] = {
      helper.addModelFeedback(ModelHistoryServerId, ModelFeedBackRequest)
  }

  /**
   * Add a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddModelHistoryRequest The model history request object 
   * @return ModelHistoryEntity
   */
  def addModelHistory(ModelHistoryServerId: String, AddModelHistoryRequest: AddModelHistoryRequest): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(addModelHistoryAsync(ModelHistoryServerId, AddModelHistoryRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddModelHistoryRequest The model history request object 
   * @return Future(ModelHistoryEntity)
   */
  def addModelHistoryAsync(ModelHistoryServerId: String, AddModelHistoryRequest: AddModelHistoryRequest): Future[ModelHistoryEntity] = {
      helper.addModelHistory(ModelHistoryServerId, AddModelHistoryRequest)
  }

  /**
   * Adds a model
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceEntity The object encapsulating the model instance id and evaluation type to aggregate 
   * @return ModelInstanceEntity
   */
  def addModelInstance(ModelHistoryServerId: String, ModelInstanceEntity: ModelInstanceEntity): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(addModelInstanceAsync(ModelHistoryServerId, ModelInstanceEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a model asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceEntity The object encapsulating the model instance id and evaluation type to aggregate 
   * @return Future(ModelInstanceEntity)
   */
  def addModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceEntity: ModelInstanceEntity): Future[ModelInstanceEntity] = {
      helper.addModelInstance(ModelHistoryServerId, ModelInstanceEntity)
  }

  /**
   * Adds a resource
   * 
   *
   * @param AddResourceRequest The Add resource request object 
   * @return Any
   */
  def addResource(AddResourceRequest: AddResourceRequest): Option[Any] = {
    val await = Try(Await.result(addResourceAsync(AddResourceRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a resource asynchronously
   * 
   *
   * @param AddResourceRequest The Add resource request object 
   * @return Future(Any)
   */
  def addResourceAsync(AddResourceRequest: AddResourceRequest): Future[Any] = {
      helper.addResource(AddResourceRequest)
  }

  /**
   * Adds a resource group
   * 
   *
   * @param GroupName Name of the resource group 
   * @return ResourceGroup
   */
  def addResourceGroup(GroupName: String): Option[ResourceGroup] = {
    val await = Try(Await.result(addResourceGroupAsync(GroupName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a resource group asynchronously
   * 
   *
   * @param GroupName Name of the resource group 
   * @return Future(ResourceGroup)
   */
  def addResourceGroupAsync(GroupName: String): Future[ResourceGroup] = {
      helper.addResourceGroup(GroupName)
  }

  /**
   * Adds a resource to a resource group
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @param ResourceId ID of the resource 
   * @return void
   */
  def addResourceToGroup(ResourceGroupId: Long, ResourceId: Long) = {
    val await = Try(Await.result(addResourceToGroupAsync(ResourceGroupId, ResourceId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a resource to a resource group asynchronously
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @param ResourceId ID of the resource 
   * @return Future(void)
   */
  def addResourceToGroupAsync(ResourceGroupId: Long, ResourceId: Long) = {
      helper.addResourceToGroup(ResourceGroupId, ResourceId)
  }

  /**
   * Aggregates the evaluaition results of a model instance, based on the evaluation type
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AggregatePrediction The object encapsulating the model instance id and evaluation type to aggregate 
   * @return EvaluationResultsEntity
   */
  def aggregateModelResults(ModelHistoryServerId: String, AggregatePrediction: AggregatePrediction): Option[EvaluationResultsEntity] = {
    val await = Try(Await.result(aggregateModelResultsAsync(ModelHistoryServerId, AggregatePrediction), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Aggregates the evaluaition results of a model instance, based on the evaluation type asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AggregatePrediction The object encapsulating the model instance id and evaluation type to aggregate 
   * @return Future(EvaluationResultsEntity)
   */
  def aggregateModelResultsAsync(ModelHistoryServerId: String, AggregatePrediction: AggregatePrediction): Future[EvaluationResultsEntity] = {
      helper.aggregateModelResults(ModelHistoryServerId, AggregatePrediction)
  }

  /**
   * Change user&#39;s password
   * 
   *
   * @param UserId User&#39;s ID 
   * @param ChangePasswordRequest Password details. 
   * @return User
   */
  def changeUserPassword(UserId: String, ChangePasswordRequest: ChangePasswordRequest): Option[User] = {
    val await = Try(Await.result(changeUserPasswordAsync(UserId, ChangePasswordRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Change user&#39;s password asynchronously
   * 
   *
   * @param UserId User&#39;s ID 
   * @param ChangePasswordRequest Password details. 
   * @return Future(User)
   */
  def changeUserPasswordAsync(UserId: String, ChangePasswordRequest: ChangePasswordRequest): Future[User] = {
      helper.changeUserPassword(UserId, ChangePasswordRequest)
  }

  /**
   * Use the deployed model to classify the input
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return ClassificationResult
   */
  def classify(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[ClassificationResult] = {
    val await = Try(Await.result(classifyAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Use the deployed model to classify the input asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(ClassificationResult)
   */
  def classifyAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[ClassificationResult] = {
      helper.classify(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Same as /classify but returns the output as Base64NDArrayBody
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Base64NDArrayBody
   */
  def classifyarray(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(classifyarrayAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Same as /classify but returns the output as Base64NDArrayBody asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(Base64NDArrayBody)
   */
  def classifyarrayAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[Base64NDArrayBody] = {
      helper.classifyarray(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Use the deployed model to classify the input, using input image file from multipart form data.
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param Image The file to upload. (optional)
   * @return ClassificationResult
   */
  def classifyimage(DeploymentName: String, VersionName: String, ModelName: String, Image: Option[File] = None): Option[ClassificationResult] = {
    val await = Try(Await.result(classifyimageAsync(DeploymentName, VersionName, ModelName, Image), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Use the deployed model to classify the input, using input image file from multipart form data. asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param Image The file to upload. (optional)
   * @return Future(ClassificationResult)
   */
  def classifyimageAsync(DeploymentName: String, VersionName: String, ModelName: String, Image: Option[File] = None): Future[ClassificationResult] = {
      helper.classifyimage(DeploymentName, VersionName, ModelName, Image)
  }

  /**
   * Clears the accumulated data for retraining.
   * 
   *
   * @return FeedbackResponse
   */
  def clearState(): Option[FeedbackResponse] = {
    val await = Try(Await.result(clearStateAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Clears the accumulated data for retraining. asynchronously
   * 
   *
   * @return Future(FeedbackResponse)
   */
  def clearStateAsync(): Future[FeedbackResponse] = {
      helper.clearState()
  }

  /**
   * Create a job
   * 
   *
   * @param JobIdOrType Job Type 
   * @param CreateJobRequest Create job request object 
   * @return JobEntity
   */
  def createJob(JobIdOrType: String, CreateJobRequest: CreateJobRequest): Option[JobEntity] = {
    val await = Try(Await.result(createJobAsync(JobIdOrType, CreateJobRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a job asynchronously
   * 
   *
   * @param JobIdOrType Job Type 
   * @param CreateJobRequest Create job request object 
   * @return Future(JobEntity)
   */
  def createJobAsync(JobIdOrType: String, CreateJobRequest: CreateJobRequest): Future[JobEntity] = {
      helper.createJob(JobIdOrType, CreateJobRequest)
  }

  /**
   * Creates model History
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryEntity The model history entity 
   * @return ModelHistoryEntity
   */
  def createModelHistory(ModelHistoryServerId: String, ModelHistoryEntity: ModelHistoryEntity): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(createModelHistoryAsync(ModelHistoryServerId, ModelHistoryEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Creates model History asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryEntity The model history entity 
   * @return Future(ModelHistoryEntity)
   */
  def createModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryEntity: ModelHistoryEntity): Future[ModelHistoryEntity] = {
      helper.createModelHistory(ModelHistoryServerId, ModelHistoryEntity)
  }

  /**
   * Delete credentials given an ID
   * 
   *
   * @param CredentialId Credentials ID 
   * @return void
   */
  def deleteCredentialsById(CredentialId: Long) = {
    val await = Try(Await.result(deleteCredentialsByIdAsync(CredentialId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete credentials given an ID asynchronously
   * 
   *
   * @param CredentialId Credentials ID 
   * @return Future(void)
   */
  def deleteCredentialsByIdAsync(CredentialId: Long) = {
      helper.deleteCredentialsById(CredentialId)
  }

  /**
   * Deletes an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to delete 
   * @return InlineResponse200
   */
  def deleteExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deleteExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to delete 
   * @return Future(InlineResponse200)
   */
  def deleteExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[InlineResponse200] = {
      helper.deleteExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * Deletes a job given its ID
   * 
   *
   * @param JobIdOrType Job ID 
   * @return void
   */
  def deleteJobById(JobIdOrType: Long) = {
    val await = Try(Await.result(deleteJobByIdAsync(JobIdOrType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a job given its ID asynchronously
   * 
   *
   * @param JobIdOrType Job ID 
   * @return Future(void)
   */
  def deleteJobByIdAsync(JobIdOrType: Long) = {
      helper.deleteJobById(JobIdOrType)
  }

  /**
   * Delete a model by deployment and model id
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @return InlineResponse200
   */
  def deleteModel(DeploymentId: String, ModelId: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deleteModelAsync(DeploymentId, ModelId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a model by deployment and model id asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @return Future(InlineResponse200)
   */
  def deleteModelAsync(DeploymentId: String, ModelId: String): Future[InlineResponse200] = {
      helper.deleteModel(DeploymentId, ModelId)
  }

  /**
   * Deletes a model history / workspace, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to delete 
   * @return InlineResponse200
   */
  def deleteModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deleteModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a model history / workspace, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to delete 
   * @return Future(InlineResponse200)
   */
  def deleteModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[InlineResponse200] = {
      helper.deleteModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Deletes a model instance, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to delete. 
   * @return void
   */
  def deleteModelInstance(ModelHistoryServerId: String, ModelInstanceID: String) = {
    val await = Try(Await.result(deleteModelInstanceAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a model instance, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to delete. 
   * @return Future(void)
   */
  def deleteModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceID: String) = {
      helper.deleteModelInstance(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Delete the resource with the specified resource ID
   * 
   *
   * @param ResourceId ID of the resource 
   * @return Resource
   */
  def deleteResourceById(ResourceId: Long): Option[Resource] = {
    val await = Try(Await.result(deleteResourceByIdAsync(ResourceId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete the resource with the specified resource ID asynchronously
   * 
   *
   * @param ResourceId ID of the resource 
   * @return Future(Resource)
   */
  def deleteResourceByIdAsync(ResourceId: Long): Future[Resource] = {
      helper.deleteResourceById(ResourceId)
  }

  /**
   * Removes a resource from a resource group
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @param ResourceId ID of the resource 
   * @return void
   */
  def deleteResourceFromGroup(ResourceGroupId: Long, ResourceId: Long) = {
    val await = Try(Await.result(deleteResourceFromGroupAsync(ResourceGroupId, ResourceId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Removes a resource from a resource group asynchronously
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @param ResourceId ID of the resource 
   * @return Future(void)
   */
  def deleteResourceFromGroupAsync(ResourceGroupId: Long, ResourceId: Long) = {
      helper.deleteResourceFromGroup(ResourceGroupId, ResourceId)
  }

  /**
   * Delete the resource group with the specified resource group ID
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @return ResourceGroup
   */
  def deleteResourceGroupById(ResourceGroupId: Long): Option[ResourceGroup] = {
    val await = Try(Await.result(deleteResourceGroupByIdAsync(ResourceGroupId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete the resource group with the specified resource group ID asynchronously
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @return Future(ResourceGroup)
   */
  def deleteResourceGroupByIdAsync(ResourceGroupId: Long): Future[ResourceGroup] = {
      helper.deleteResourceGroupById(ResourceGroupId)
  }

  /**
   * Deploy a model in a deployment group.
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param Body the model import request 
   * @return ModelEntity
   */
  def deployModel(DeploymentId: String, Body: ImportModelRequest): Option[ModelEntity] = {
    val await = Try(Await.result(deployModelAsync(DeploymentId, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deploy a model in a deployment group. asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param Body the model import request 
   * @return Future(ModelEntity)
   */
  def deployModelAsync(DeploymentId: String, Body: ImportModelRequest): Future[ModelEntity] = {
      helper.deployModel(DeploymentId, Body)
  }

  /**
   * Create a new deployment group.
   * 
   *
   * @param Body the deployment request 
   * @return DeploymentResponse
   */
  def deploymentCreate(Body: CreateDeploymentRequest): Option[DeploymentResponse] = {
    val await = Try(Await.result(deploymentCreateAsync(Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a new deployment group. asynchronously
   * 
   *
   * @param Body the deployment request 
   * @return Future(DeploymentResponse)
   */
  def deploymentCreateAsync(Body: CreateDeploymentRequest): Future[DeploymentResponse] = {
      helper.deploymentCreate(Body)
  }

  /**
   * Delete a deployment by id
   * 
   *
   * @param DeploymentId Id of the deployment group 
   * @return InlineResponse200
   */
  def deploymentDelete(DeploymentId: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deploymentDeleteAsync(DeploymentId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a deployment by id asynchronously
   * 
   *
   * @param DeploymentId Id of the deployment group 
   * @return Future(InlineResponse200)
   */
  def deploymentDeleteAsync(DeploymentId: String): Future[InlineResponse200] = {
      helper.deploymentDelete(DeploymentId)
  }

  /**
   * Get a deployment details by id
   * 
   *
   * @param DeploymentId Id of the deployment group 
   * @return DeploymentResponse
   */
  def deploymentGet(DeploymentId: String): Option[DeploymentResponse] = {
    val await = Try(Await.result(deploymentGetAsync(DeploymentId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a deployment details by id asynchronously
   * 
   *
   * @param DeploymentId Id of the deployment group 
   * @return Future(DeploymentResponse)
   */
  def deploymentGetAsync(DeploymentId: String): Future[DeploymentResponse] = {
      helper.deploymentGet(DeploymentId)
  }

  /**
   * Get a list of deployments
   * 
   *
   * @return List[DeploymentResponse]
   */
  def deployments(): Option[List[DeploymentResponse]] = {
    val await = Try(Await.result(deploymentsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a list of deployments asynchronously
   * 
   *
   * @return Future(List[DeploymentResponse])
   */
  def deploymentsAsync(): Future[List[DeploymentResponse]] = {
      helper.deployments()
  }

  /**
   * Detect the objects, given a (input) prediction request
   * 
   *
   * @param Id the GUID for mapping the results in the detections 
   * @param NeedsPreprocessing (true) if the image needs preprocessing 
   * @param Threshold A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none. 
   * @param File the image file to detect objects from 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return DetectionResult
   */
  def detectobjects(Id: String, NeedsPreprocessing: Boolean, Threshold: Float, File: File, DeploymentName: String, VersionName: String, ModelName: String): Option[DetectionResult] = {
    val await = Try(Await.result(detectobjectsAsync(Id, NeedsPreprocessing, Threshold, File, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Detect the objects, given a (input) prediction request asynchronously
   * 
   *
   * @param Id the GUID for mapping the results in the detections 
   * @param NeedsPreprocessing (true) if the image needs preprocessing 
   * @param Threshold A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none. 
   * @param File the image file to detect objects from 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(DetectionResult)
   */
  def detectobjectsAsync(Id: String, NeedsPreprocessing: Boolean, Threshold: Float, File: File, DeploymentName: String, VersionName: String, ModelName: String): Future[DetectionResult] = {
      helper.detectobjects(Id, NeedsPreprocessing, Threshold, File, DeploymentName, VersionName, ModelName)
  }

  /**
   * Download the output file from the job&#39;s execution. This will ONLY work if the job&#39;s run status is &#39;COMPLETE&#39;.
   * 
   *
   * @param JobId Job ID 
   * @param DownloadOutputFileRequest Download output file request object 
   * @return void
   */
  def downloadJobOutputFile(JobId: Long, DownloadOutputFileRequest: DownloadOutputFileRequest) = {
    val await = Try(Await.result(downloadJobOutputFileAsync(JobId, DownloadOutputFileRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Download the output file from the job&#39;s execution. This will ONLY work if the job&#39;s run status is &#39;COMPLETE&#39;. asynchronously
   * 
   *
   * @param JobId Job ID 
   * @param DownloadOutputFileRequest Download output file request object 
   * @return Future(void)
   */
  def downloadJobOutputFileAsync(JobId: Long, DownloadOutputFileRequest: DownloadOutputFileRequest) = {
      helper.downloadJobOutputFile(JobId, DownloadOutputFileRequest)
  }

  /**
   * Generate new auth token
   * 
   *
   * @param TokenGenerateRequest Auth token details. 
   * @return Token
   */
  def generateAuthToken(TokenGenerateRequest: TokenGenerateRequest): Option[Token] = {
    val await = Try(Await.result(generateAuthTokenAsync(TokenGenerateRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Generate new auth token asynchronously
   * 
   *
   * @param TokenGenerateRequest Auth token details. 
   * @return Future(Token)
   */
  def generateAuthTokenAsync(TokenGenerateRequest: TokenGenerateRequest): Future[Token] = {
      helper.generateAuthToken(TokenGenerateRequest)
  }

  /**
   * Get a list of all available jobs
   * 
   *
   * @return List[JobEntity]
   */
  def getAllJobs(): Option[List[JobEntity]] = {
    val await = Try(Await.result(getAllJobsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a list of all available jobs asynchronously
   * 
   *
   * @return Future(List[JobEntity])
   */
  def getAllJobsAsync(): Future[List[JobEntity]] = {
      helper.getAllJobs()
  }

  /**
   * Get the memory mapped array based on the array type.
   * The array is specified through a file path, in the configuration object, during model server deployment.
   *
   * @param Accept  
   * @param ArrayType The format in which the memory mapped array is returned. 
   * @return void
   */
  def getArray(Accept: String, ArrayType: String) = {
    val await = Try(Await.result(getArrayAsync(Accept, ArrayType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the memory mapped array based on the array type. asynchronously
   * The array is specified through a file path, in the configuration object, during model server deployment.
   *
   * @param Accept  
   * @param ArrayType The format in which the memory mapped array is returned. 
   * @return Future(void)
   */
  def getArrayAsync(Accept: String, ArrayType: String) = {
      helper.getArray(Accept, ArrayType)
  }

  /**
   * Get the memory mapped array indices based on the array type.
   * 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;. 
   * @param Accept  
   * @param ArrayType Format in which the memory mapped array is returned in. 
   * @param Input Input indices array (optional)
   * @return void
   */
  def getArrayIndices(`ContentType`: String, Accept: String, ArrayType: String, Input: Option[String] = None) = {
    val await = Try(Await.result(getArrayIndicesAsync(`ContentType`, Accept, ArrayType, Input), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the memory mapped array indices based on the array type. asynchronously
   * 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;. 
   * @param Accept  
   * @param ArrayType Format in which the memory mapped array is returned in. 
   * @param Input Input indices array (optional)
   * @return Future(void)
   */
  def getArrayIndicesAsync(`ContentType`: String, Accept: String, ArrayType: String, Input: Option[String] = None) = {
      helper.getArrayIndices(`ContentType`, Accept, ArrayType, Input)
  }

  /**
   * Get the memory mapped array within a range based on the array type.
   * 
   *
   * @param Accept  
   * @param ArrayType Format in which the memory mapped array is returned in. 
   * @param From  
   * @param To  
   * @return void
   */
  def getArrayRange(Accept: String, ArrayType: String, From: Integer, To: Integer) = {
    val await = Try(Await.result(getArrayRangeAsync(Accept, ArrayType, From, To), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the memory mapped array within a range based on the array type. asynchronously
   * 
   *
   * @param Accept  
   * @param ArrayType Format in which the memory mapped array is returned in. 
   * @param From  
   * @param To  
   * @return Future(void)
   */
  def getArrayRangeAsync(Accept: String, ArrayType: String, From: Integer, To: Integer) = {
      helper.getArrayRange(Accept, ArrayType, From, To)
  }

  /**
   * Get auth policy
   * 
   *
   * @return AuthPolicy
   */
  def getAuthPolicy(): Option[AuthPolicy] = {
    val await = Try(Await.result(getAuthPolicyAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get auth policy asynchronously
   * 
   *
   * @return Future(AuthPolicy)
   */
  def getAuthPolicyAsync(): Future[AuthPolicy] = {
      helper.getAuthPolicy()
  }

  /**
   * Gets the best model among the given model instance IDs, based on the evaluation type and column metric
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param BestModel Object encapsulating the model ids, eval type and column metric name 
   * @return ModelInstanceEntity
   */
  def getBestModelAmongModelIds(ModelHistoryServerId: String, BestModel: BestModel): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(getBestModelAmongModelIdsAsync(ModelHistoryServerId, BestModel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the best model among the given model instance IDs, based on the evaluation type and column metric asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param BestModel Object encapsulating the model ids, eval type and column metric name 
   * @return Future(ModelInstanceEntity)
   */
  def getBestModelAmongModelIdsAsync(ModelHistoryServerId: String, BestModel: BestModel): Future[ModelInstanceEntity] = {
      helper.getBestModelAmongModelIds(ModelHistoryServerId, BestModel)
  }

  /**
   * Get credentials given an ID
   * 
   *
   * @param CredentialId Credentials ID 
   * @return ResourceCredentials
   */
  def getCredentialsById(CredentialId: Long): Option[ResourceCredentials] = {
    val await = Try(Await.result(getCredentialsByIdAsync(CredentialId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get credentials given an ID asynchronously
   * 
   *
   * @param CredentialId Credentials ID 
   * @return Future(ResourceCredentials)
   */
  def getCredentialsByIdAsync(CredentialId: Long): Future[ResourceCredentials] = {
      helper.getCredentialsById(CredentialId)
  }

  /**
   * Returns the current model being used for retraining.
   * 
   *
   * @return void
   */
  def getCurrentModel() = {
    val await = Try(Await.result(getCurrentModelAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns the current model being used for retraining. asynchronously
   * 
   *
   * @return Future(void)
   */
  def getCurrentModelAsync() = {
      helper.getCurrentModel()
  }

  /**
   * Gets the list of evaluation results entity, given a model instance ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get evaluation results for. 
   * @return List[EvaluationResultsEntity]
   */
  def getEvaluationForModelID(ModelHistoryServerId: String, ModelInstanceID: String): Option[List[EvaluationResultsEntity]] = {
    val await = Try(Await.result(getEvaluationForModelIDAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the list of evaluation results entity, given a model instance ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get evaluation results for. 
   * @return Future(List[EvaluationResultsEntity])
   */
  def getEvaluationForModelIDAsync(ModelHistoryServerId: String, ModelInstanceID: String): Future[List[EvaluationResultsEntity]] = {
      helper.getEvaluationForModelID(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Gets all the examples for a minibatch ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return List[ExampleEntity]
   */
  def getExamplesForMinibatch(ModelHistoryServerId: String, MinibatchId: String): Option[List[ExampleEntity]] = {
    val await = Try(Await.result(getExamplesForMinibatchAsync(ModelHistoryServerId, MinibatchId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets all the examples for a minibatch ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return Future(List[ExampleEntity])
   */
  def getExamplesForMinibatchAsync(ModelHistoryServerId: String, MinibatchId: String): Future[List[ExampleEntity]] = {
      helper.getExamplesForMinibatch(ModelHistoryServerId, MinibatchId)
  }

  /**
   * Obtain an experiment&#39;s details, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to obtain 
   * @return ExperimentEntity
   */
  def getExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[ExperimentEntity] = {
    val await = Try(Await.result(getExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain an experiment&#39;s details, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to obtain 
   * @return Future(ExperimentEntity)
   */
  def getExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[ExperimentEntity] = {
      helper.getExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * Obtain all experiments for a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace 
   * @return ExperimentEntity
   */
  def getExperimentsForModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[ExperimentEntity] = {
    val await = Try(Await.result(getExperimentsForModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain all experiments for a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace 
   * @return Future(ExperimentEntity)
   */
  def getExperimentsForModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[ExperimentEntity] = {
      helper.getExperimentsForModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Get a job by its ID
   * 
   *
   * @param JobIdOrType Job ID 
   * @return JobEntity
   */
  def getJobById(JobIdOrType: Long): Option[JobEntity] = {
    val await = Try(Await.result(getJobByIdAsync(JobIdOrType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a job by its ID asynchronously
   * 
   *
   * @param JobIdOrType Job ID 
   * @return Future(JobEntity)
   */
  def getJobByIdAsync(JobIdOrType: Long): Future[JobEntity] = {
      helper.getJobById(JobIdOrType)
  }

  /**
   * Get the last evaluation specifications from the current model.
   * 
   *
   * @return EvaluationResultsEntity
   */
  def getLastEvaluation(): Option[EvaluationResultsEntity] = {
    val await = Try(Await.result(getLastEvaluationAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the last evaluation specifications from the current model. asynchronously
   * 
   *
   * @return Future(EvaluationResultsEntity)
   */
  def getLastEvaluationAsync(): Future[EvaluationResultsEntity] = {
      helper.getLastEvaluation()
  }

  /**
   * Gets a minibatch for the model
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return MinibatchEntity
   */
  def getMinibatch(ModelHistoryServerId: String, MinibatchId: String): Option[MinibatchEntity] = {
    val await = Try(Await.result(getMinibatchAsync(ModelHistoryServerId, MinibatchId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a minibatch for the model asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return Future(MinibatchEntity)
   */
  def getMinibatchAsync(ModelHistoryServerId: String, MinibatchId: String): Future[MinibatchEntity] = {
      helper.getMinibatch(ModelHistoryServerId, MinibatchId)
  }

  /**
   * Get model details
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @return ModelEntity
   */
  def getModelDetails(DeploymentId: String, ModelId: String): Option[ModelEntity] = {
    val await = Try(Await.result(getModelDetailsAsync(DeploymentId, ModelId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get model details asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @return Future(ModelEntity)
   */
  def getModelDetailsAsync(DeploymentId: String, ModelId: String): Future[ModelEntity] = {
      helper.getModelDetails(DeploymentId, ModelId)
  }

  /**
   * Gets a model history, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID GUID of the model history to get information of. 
   * @return ModelHistoryEntity
   */
  def getModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(getModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a model history, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID GUID of the model history to get information of. 
   * @return Future(ModelHistoryEntity)
   */
  def getModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[ModelHistoryEntity] = {
      helper.getModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Gets a model instance, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get information of. 
   * @return ModelInstanceEntity
   */
  def getModelInstance(ModelHistoryServerId: String, ModelInstanceID: String): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(getModelInstanceAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a model instance, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get information of. 
   * @return Future(ModelInstanceEntity)
   */
  def getModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceID: String): Future[ModelInstanceEntity] = {
      helper.getModelInstance(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Obtain a list of all the models for an experiment
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment 
   * @return List[ModelInstanceEntity]
   */
  def getModelsForExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[List[ModelInstanceEntity]] = {
    val await = Try(Await.result(getModelsForExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain a list of all the models for an experiment asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment 
   * @return Future(List[ModelInstanceEntity])
   */
  def getModelsForExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[List[ModelInstanceEntity]] = {
      helper.getModelsForExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * Get the resource with the specified resource ID
   * 
   *
   * @param ResourceId ID of the resource 
   * @return Resource
   */
  def getResourceById(ResourceId: Long): Option[Resource] = {
    val await = Try(Await.result(getResourceByIdAsync(ResourceId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the resource with the specified resource ID asynchronously
   * 
   *
   * @param ResourceId ID of the resource 
   * @return Future(Resource)
   */
  def getResourceByIdAsync(ResourceId: Long): Future[Resource] = {
      helper.getResourceById(ResourceId)
  }

  /**
   * Get all the resources with the specified resource subtype
   * 
   *
   * @param ResourceSubType Subtype of the resource 
   * @return List[Resource]
   */
  def getResourceBySubType(ResourceSubType: String): Option[List[Resource]] = {
    val await = Try(Await.result(getResourceBySubTypeAsync(ResourceSubType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all the resources with the specified resource subtype asynchronously
   * 
   *
   * @param ResourceSubType Subtype of the resource 
   * @return Future(List[Resource])
   */
  def getResourceBySubTypeAsync(ResourceSubType: String): Future[List[Resource]] = {
      helper.getResourceBySubType(ResourceSubType)
  }

  /**
   * Get all the resources with the specified resource type
   * 
   *
   * @param ResourceType Type of the resource 
   * @return List[Resource]
   */
  def getResourceByType(ResourceType: String): Option[List[Resource]] = {
    val await = Try(Await.result(getResourceByTypeAsync(ResourceType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all the resources with the specified resource type asynchronously
   * 
   *
   * @param ResourceType Type of the resource 
   * @return Future(List[Resource])
   */
  def getResourceByTypeAsync(ResourceType: String): Future[List[Resource]] = {
      helper.getResourceByType(ResourceType)
  }

  /**
   * Get the resource details with the specified resource ID
   * Get the details for the resource, for the given ID. Note that a &#39;ResourceDetails&#39; object contains specific information about the resource (such as region for an AWS resource, or URI for a HDFS resource), where as the &#39;Resource&#39; object contains only general information (name, id, type, subtype). 
   *
   * @param ResourceId ID of the resource 
   * @return Any
   */
  def getResourceDetailsById(ResourceId: Long): Option[Any] = {
    val await = Try(Await.result(getResourceDetailsByIdAsync(ResourceId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the resource details with the specified resource ID asynchronously
   * Get the details for the resource, for the given ID. Note that a &#39;ResourceDetails&#39; object contains specific information about the resource (such as region for an AWS resource, or URI for a HDFS resource), where as the &#39;Resource&#39; object contains only general information (name, id, type, subtype). 
   *
   * @param ResourceId ID of the resource 
   * @return Future(Any)
   */
  def getResourceDetailsByIdAsync(ResourceId: Long): Future[Any] = {
      helper.getResourceDetailsById(ResourceId)
  }

  /**
   * Get the resource group with the specified resource group ID
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @return ResourceGroup
   */
  def getResourceGroupById(ResourceGroupId: Long): Option[ResourceGroup] = {
    val await = Try(Await.result(getResourceGroupByIdAsync(ResourceGroupId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the resource group with the specified resource group ID asynchronously
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @return Future(ResourceGroup)
   */
  def getResourceGroupByIdAsync(ResourceGroupId: Long): Future[ResourceGroup] = {
      helper.getResourceGroupById(ResourceGroupId)
  }

  /**
   * Get a list of all the resource groups
   * 
   *
   * @return List[ResourceGroup]
   */
  def getResourceGroups(): Option[List[ResourceGroup]] = {
    val await = Try(Await.result(getResourceGroupsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a list of all the resource groups asynchronously
   * 
   *
   * @return Future(List[ResourceGroup])
   */
  def getResourceGroupsAsync(): Future[List[ResourceGroup]] = {
      helper.getResourceGroups()
  }

  /**
   * A list of all known/registered resources, of all types
   * 
   *
   * @return List[Resource]
   */
  def getResources(): Option[List[Resource]] = {
    val await = Try(Await.result(getResourcesAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * A list of all known/registered resources, of all types asynchronously
   * 
   *
   * @return Future(List[Resource])
   */
  def getResourcesAsync(): Future[List[Resource]] = {
      helper.getResources()
  }

  /**
   * Get all resources from a resource group
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @return List[Resource]
   */
  def getResourcesFromGroup(ResourceGroupId: Long): Option[List[Resource]] = {
    val await = Try(Await.result(getResourcesFromGroupAsync(ResourceGroupId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all resources from a resource group asynchronously
   * 
   *
   * @param ResourceGroupId ID of the resource group 
   * @return Future(List[Resource])
   */
  def getResourcesFromGroupAsync(ResourceGroupId: Long): Future[List[Resource]] = {
      helper.getResourcesFromGroup(ResourceGroupId)
  }

  /**
   * Get all roles.
   * 
   *
   * @return List[Role]
   */
  def getRoles(): Option[List[Role]] = {
    val await = Try(Await.result(getRolesAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all roles. asynchronously
   * 
   *
   * @return Future(List[Role])
   */
  def getRolesAsync(): Future[List[Role]] = {
      helper.getRoles()
  }

  /**
   * Get a user by user ID
   * 
   *
   * @param UserId User&#39;s ID 
   * @return User
   */
  def getUser(UserId: String): Option[User] = {
    val await = Try(Await.result(getUserAsync(UserId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a user by user ID asynchronously
   * 
   *
   * @param UserId User&#39;s ID 
   * @return Future(User)
   */
  def getUserAsync(UserId: String): Future[User] = {
      helper.getUser(UserId)
  }

  /**
   * Get auth tokens for a user.
   * 
   *
   * @param UserId User&#39;s ID 
   * @param OnlyValid True if you only want the valid tokens. (optional)
   * @return List[Token]
   */
  def getUserAuthTokens(UserId: String, OnlyValid: Option[Boolean] = None): Option[List[Token]] = {
    val await = Try(Await.result(getUserAuthTokensAsync(UserId, OnlyValid), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get auth tokens for a user. asynchronously
   * 
   *
   * @param UserId User&#39;s ID 
   * @param OnlyValid True if you only want the valid tokens. (optional)
   * @return Future(List[Token])
   */
  def getUserAuthTokensAsync(UserId: String, OnlyValid: Option[Boolean] = None): Future[List[Token]] = {
      helper.getUserAuthTokens(UserId, OnlyValid)
  }

  /**
   * Get all users.
   * 
   *
   * @return List[User]
   */
  def getUsers(): Option[List[User]] = {
    val await = Try(Await.result(getUsersAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all users. asynchronously
   * 
   *
   * @return Future(List[User])
   */
  def getUsersAsync(): Future[List[User]] = {
      helper.getUsers()
  }

  /**
   * Get the retraining status
   * 
   *
   * @return RetrainingStatus
   */
  def isTraining(): Option[RetrainingStatus] = {
    val await = Try(Await.result(isTrainingAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the retraining status asynchronously
   * 
   *
   * @return Future(RetrainingStatus)
   */
  def isTrainingAsync(): Future[RetrainingStatus] = {
      helper.isTraining()
  }

  /**
   * Run inference on the input and returns it as a JsonArrayResponse
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return JsonArrayResponse
   */
  def jsonarray(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[JsonArrayResponse] = {
    val await = Try(Await.result(jsonarrayAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run inference on the input and returns it as a JsonArrayResponse asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(JsonArrayResponse)
   */
  def jsonarrayAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[JsonArrayResponse] = {
      helper.jsonarray(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Runs knn on the given index with the given k
   * Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param KnnName ID or name of the deployed knn 
   * @param Body  
   * @return NearestNeighborsResults
   */
  def knn(DeploymentName: String, VersionName: String, KnnName: String, Body: NearestNeighborRequest): Option[NearestNeighborsResults] = {
    val await = Try(Await.result(knnAsync(DeploymentName, VersionName, KnnName, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Runs knn on the given index with the given k asynchronously
   * Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param KnnName ID or name of the deployed knn 
   * @param Body  
   * @return Future(NearestNeighborsResults)
   */
  def knnAsync(DeploymentName: String, VersionName: String, KnnName: String, Body: NearestNeighborRequest): Future[NearestNeighborsResults] = {
      helper.knn(DeploymentName, VersionName, KnnName, Body)
  }

  /**
   * Run a k nearest neighbors search on a NEW data point
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param KnnName ID or name of the deployed knn 
   * @param Body The input NDArray 
   * @return NearestNeighborsResults
   */
  def knnnew(DeploymentName: String, VersionName: String, KnnName: String, Body: Base64NDArrayBodyKNN): Option[NearestNeighborsResults] = {
    val await = Try(Await.result(knnnewAsync(DeploymentName, VersionName, KnnName, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run a k nearest neighbors search on a NEW data point asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param KnnName ID or name of the deployed knn 
   * @param Body The input NDArray 
   * @return Future(NearestNeighborsResults)
   */
  def knnnewAsync(DeploymentName: String, VersionName: String, KnnName: String, Body: Base64NDArrayBodyKNN): Future[NearestNeighborsResults] = {
      helper.knnnew(DeploymentName, VersionName, KnnName, Body)
  }

  /**
   * List all of the experiments in every model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @return List[ExperimentEntity]
   */
  def listAllExperiments(ModelHistoryServerId: String): Option[List[ExperimentEntity]] = {
    val await = Try(Await.result(listAllExperimentsAsync(ModelHistoryServerId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List all of the experiments in every model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @return Future(List[ExperimentEntity])
   */
  def listAllExperimentsAsync(ModelHistoryServerId: String): Future[List[ExperimentEntity]] = {
      helper.listAllExperiments(ModelHistoryServerId)
  }

  /**
   * Get logs file path
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return String
   */
  def logfilepath(DeploymentName: String, VersionName: String, ModelName: String): Option[String] = {
    val await = Try(Await.result(logfilepathAsync(DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get logs file path asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(String)
   */
  def logfilepathAsync(DeploymentName: String, VersionName: String, ModelName: String): Future[String] = {
      helper.logfilepath(DeploymentName, VersionName, ModelName)
  }

  /**
   * Post JSON credentials and obtain a JWT authorization token.
   * 
   *
   * @param LoginRequest Login credentials. 
   * @return LoginResponse
   */
  def login(LoginRequest: LoginRequest): Option[LoginResponse] = {
    val await = Try(Await.result(loginAsync(LoginRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Post JSON credentials and obtain a JWT authorization token. asynchronously
   * 
   *
   * @param LoginRequest Login credentials. 
   * @return Future(LoginResponse)
   */
  def loginAsync(LoginRequest: LoginRequest): Future[LoginResponse] = {
      helper.login(LoginRequest)
  }

  /**
   * Get logs
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param LogRequest The log object 
   * @return LogBatch
   */
  def logs(DeploymentName: String, VersionName: String, ModelName: String, LogRequest: LogRequest): Option[LogBatch] = {
    val await = Try(Await.result(logsAsync(DeploymentName, VersionName, ModelName, LogRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get logs asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param LogRequest The log object 
   * @return Future(LogBatch)
   */
  def logsAsync(DeploymentName: String, VersionName: String, ModelName: String, LogRequest: LogRequest): Future[LogBatch] = {
      helper.logs(DeploymentName, VersionName, ModelName, LogRequest)
  }

  /**
   * this method can be used to get the meta data for the current model which set to the server
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MetaData
   */
  def metaGet(DeploymentName: String, VersionName: String, ModelName: String): Option[MetaData] = {
    val await = Try(Await.result(metaGetAsync(DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * this method can be used to get the meta data for the current model which set to the server asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MetaData)
   */
  def metaGetAsync(DeploymentName: String, VersionName: String, ModelName: String): Future[MetaData] = {
      helper.metaGet(DeploymentName, VersionName, ModelName)
  }

  /**
   * This method can be used to set meta data for the current model which is set to the server
   * 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60; 
   * @param Body the meta data object 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MetaData
   */
  def metaPost(`ContentType`: String, Body: String, DeploymentName: String, VersionName: String, ModelName: String): Option[MetaData] = {
    val await = Try(Await.result(metaPostAsync(`ContentType`, Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * This method can be used to set meta data for the current model which is set to the server asynchronously
   * 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60; 
   * @param Body the meta data object 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MetaData)
   */
  def metaPostAsync(`ContentType`: String, Body: String, DeploymentName: String, VersionName: String, ModelName: String): Future[MetaData] = {
      helper.metaPost(`ContentType`, Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Modify the state (start/stop) of a deployed model
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @param Body the model state object 
   * @return ModelEntity
   */
  def modelStateChange(DeploymentId: String, ModelId: String, Body: SetState): Option[ModelEntity] = {
    val await = Try(Await.result(modelStateChangeAsync(DeploymentId, ModelId, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Modify the state (start/stop) of a deployed model asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @param Body the model state object 
   * @return Future(ModelEntity)
   */
  def modelStateChangeAsync(DeploymentId: String, ModelId: String, Body: SetState): Future[ModelEntity] = {
      helper.modelStateChange(DeploymentId, ModelId, Body)
  }

  /**
   * Retrieve a list of all the deployed models given a deployment id
   * 
   *
   * @param DeploymentId ID deployment group 
   * @return List[ModelEntity]
   */
  def models(DeploymentId: String): Option[List[ModelEntity]] = {
    val await = Try(Await.result(modelsAsync(DeploymentId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve a list of all the deployed models given a deployment id asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @return Future(List[ModelEntity])
   */
  def modelsAsync(DeploymentId: String): Future[List[ModelEntity]] = {
      helper.models(DeploymentId)
  }

  /**
   * Set the model to be served
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param File The model file to upload (.pb file) (optional)
   * @return ModelStatus
   */
  def modelset(DeploymentName: String, VersionName: String, ModelName: String, File: Option[File] = None): Option[ModelStatus] = {
    val await = Try(Await.result(modelsetAsync(DeploymentName, VersionName, ModelName, File), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the model to be served asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param File The model file to upload (.pb file) (optional)
   * @return Future(ModelStatus)
   */
  def modelsetAsync(DeploymentName: String, VersionName: String, ModelName: String, File: Option[File] = None): Future[ModelStatus] = {
      helper.modelset(DeploymentName, VersionName, ModelName, File)
  }

  /**
   * Update the model to be served
   * 
   *
   * @param File The model file to update with (.pb file) 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return ModelStatus
   */
  def modelupdate(File: File, DeploymentName: String, VersionName: String, ModelName: String): Option[ModelStatus] = {
    val await = Try(Await.result(modelupdateAsync(File, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update the model to be served asynchronously
   * 
   *
   * @param File The model file to update with (.pb file) 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(ModelStatus)
   */
  def modelupdateAsync(File: File, DeploymentName: String, VersionName: String, ModelName: String): Future[ModelStatus] = {
      helper.modelupdate(File, DeploymentName, VersionName, ModelName)
  }

  /**
   * Represents all of the labels for a given classification
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MultiClassClassificationResult
   */
  def multiclassify(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[MultiClassClassificationResult] = {
    val await = Try(Await.result(multiclassifyAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Represents all of the labels for a given classification asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MultiClassClassificationResult)
   */
  def multiclassifyAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[MultiClassClassificationResult] = {
      helper.multiclassify(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Get the output from the network, based on the given INDArray[] input
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   *
   * @param Body The multiple input arrays with mask inputs to run inferences on 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MultiPredictResponse
   */
  def multipredict(Body: MultiPredictRequest, DeploymentName: String, VersionName: String, ModelName: String): Option[MultiPredictResponse] = {
    val await = Try(Await.result(multipredictAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the output from the network, based on the given INDArray[] input asynchronously
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   *
   * @param Body The multiple input arrays with mask inputs to run inferences on 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MultiPredictResponse)
   */
  def multipredictAsync(Body: MultiPredictRequest, DeploymentName: String, VersionName: String, ModelName: String): Future[MultiPredictResponse] = {
      helper.multipredict(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Get the output from the network using the given image file using the /multipredict endpoint&#39;s method
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   *
   * @param File The image file to run the prediction on 
   * @param Id The id of the request (could be self generated) 
   * @param NeedsPreprocessing Whether or not the preprocessing is required (either &#39;true&#39; or &#39;false&#39;) 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MultiPredictResponse
   */
  def multipredictimage(File: File, Id: String, NeedsPreprocessing: Boolean, DeploymentName: String, VersionName: String, ModelName: String): Option[MultiPredictResponse] = {
    val await = Try(Await.result(multipredictimageAsync(File, Id, NeedsPreprocessing, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the output from the network using the given image file using the /multipredict endpoint&#39;s method asynchronously
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   *
   * @param File The image file to run the prediction on 
   * @param Id The id of the request (could be self generated) 
   * @param NeedsPreprocessing Whether or not the preprocessing is required (either &#39;true&#39; or &#39;false&#39;) 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MultiPredictResponse)
   */
  def multipredictimageAsync(File: File, Id: String, NeedsPreprocessing: Boolean, DeploymentName: String, VersionName: String, ModelName: String): Future[MultiPredictResponse] = {
      helper.multipredictimage(File, Id, NeedsPreprocessing, DeploymentName, VersionName, ModelName)
  }

  /**
   * Gets the number of retrained models written with retraining.
   * 
   *
   * @return RevisionsWritten
   */
  def numRevisions(): Option[RevisionsWritten] = {
    val await = Try(Await.result(numRevisionsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the number of retrained models written with retraining. asynchronously
   * 
   *
   * @return Future(RevisionsWritten)
   */
  def numRevisionsAsync(): Future[RevisionsWritten] = {
      helper.numRevisions()
  }

  /**
   * Run inference on the input array.
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Prediction
   */
  def predict(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[Prediction] = {
    val await = Try(Await.result(predictAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run inference on the input array. asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(Prediction)
   */
  def predictAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[Prediction] = {
      helper.predict(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Runs inference and find invalid rows based on the input data. Output is defined relative to the output adapter specified.
   * These \&quot;error\&quot; endpoints are slower for inference, but will also ignore invalid rows that are found. They will output skipped rows where errors were encountered so users can fix problems with input data pipelines. 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;. 
   * @param Operation Operation to perform on the input data. 
   * @param InputType Type of the input data. 
   * @param InputData  (optional)
   * @return void
   */
  def predictError(`ContentType`: String, Operation: String, InputType: String, InputData: Option[String] = None) = {
    val await = Try(Await.result(predictErrorAsync(`ContentType`, Operation, InputType, InputData), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Runs inference and find invalid rows based on the input data. Output is defined relative to the output adapter specified. asynchronously
   * These \&quot;error\&quot; endpoints are slower for inference, but will also ignore invalid rows that are found. They will output skipped rows where errors were encountered so users can fix problems with input data pipelines. 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;. 
   * @param Operation Operation to perform on the input data. 
   * @param InputType Type of the input data. 
   * @param InputData  (optional)
   * @return Future(void)
   */
  def predictErrorAsync(`ContentType`: String, Operation: String, InputType: String, InputData: Option[String] = None) = {
      helper.predictError(`ContentType`, Operation, InputType, InputData)
  }

  /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified.
   * 
   *
   * @param Operation The operation to perform on the input data.  
   * @param InputTypeFile Type of the input data.  
   * @param InputData The input data to run inference on. 
   * @return void
   */
  def predictV2File(Operation: String, InputTypeFile: String, InputData: File) = {
    val await = Try(Await.result(predictV2FileAsync(Operation, InputTypeFile, InputData), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified. asynchronously
   * 
   *
   * @param Operation The operation to perform on the input data.  
   * @param InputTypeFile Type of the input data.  
   * @param InputData The input data to run inference on. 
   * @return Future(void)
   */
  def predictV2FileAsync(Operation: String, InputTypeFile: String, InputData: File) = {
      helper.predictV2File(Operation, InputTypeFile, InputData)
  }

  /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified.
   * 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;. 
   * @param Operation The operation to perform on the input data.  
   * @param InputTypeJson Type of the input data.  
   * @param InputData The input data to run inference on. (Specify a JSON string here) 
   * @return void
   */
  def predictV2Json(`ContentType`: String, Operation: String, InputTypeJson: String, InputData: String) = {
    val await = Try(Await.result(predictV2JsonAsync(`ContentType`, Operation, InputTypeJson, InputData), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified. asynchronously
   * 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;. 
   * @param Operation The operation to perform on the input data.  
   * @param InputTypeJson Type of the input data.  
   * @param InputData The input data to run inference on. (Specify a JSON string here) 
   * @return Future(void)
   */
  def predictV2JsonAsync(`ContentType`: String, Operation: String, InputTypeJson: String, InputData: String) = {
      helper.predictV2Json(`ContentType`, Operation, InputTypeJson, InputData)
  }

  /**
   * Run inference on the input array, using input image file from multipart form data.
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param Image The file to upload. (optional)
   * @return Prediction
   */
  def predictimage(DeploymentName: String, VersionName: String, ModelName: String, Image: Option[File] = None): Option[Prediction] = {
    val await = Try(Await.result(predictimageAsync(DeploymentName, VersionName, ModelName, Image), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run inference on the input array, using input image file from multipart form data. asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param Image The file to upload. (optional)
   * @return Future(Prediction)
   */
  def predictimageAsync(DeploymentName: String, VersionName: String, ModelName: String, Image: Option[File] = None): Future[Prediction] = {
      helper.predictimage(DeploymentName, VersionName, ModelName, Image)
  }

  /**
   * Preprocesses the input and run inference on it
   * 
   *
   * @param Body The input array 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Prediction
   */
  def predictwithpreprocess(Body: List[String], DeploymentName: String, VersionName: String, ModelName: String): Option[Prediction] = {
    val await = Try(Await.result(predictwithpreprocessAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Preprocesses the input and run inference on it asynchronously
   * 
   *
   * @param Body The input array 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(Prediction)
   */
  def predictwithpreprocessAsync(Body: List[String], DeploymentName: String, VersionName: String, ModelName: String): Future[Prediction] = {
      helper.predictwithpreprocess(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Preprocesses the input and run inference on it and returns it as a JsonArrayResponse
   * 
   *
   * @param Body The input array 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return JsonArrayResponse
   */
  def predictwithpreprocessjson(Body: List[String], DeploymentName: String, VersionName: String, ModelName: String): Option[JsonArrayResponse] = {
    val await = Try(Await.result(predictwithpreprocessjsonAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Preprocesses the input and run inference on it and returns it as a JsonArrayResponse asynchronously
   * 
   *
   * @param Body The input array 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(JsonArrayResponse)
   */
  def predictwithpreprocessjsonAsync(Body: List[String], DeploymentName: String, VersionName: String, ModelName: String): Future[JsonArrayResponse] = {
      helper.predictwithpreprocessjson(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified.
   * 
   *
   * @param InputType Input data type. 
   * @param OutputType Binary output data type. 
   * @param InputData The input file to upload. (optional)
   * @return void
   */
  def rawPredictBinary(InputType: String, OutputType: String, InputData: Option[File] = None) = {
    val await = Try(Await.result(rawPredictBinaryAsync(InputType, OutputType, InputData), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified. asynchronously
   * 
   *
   * @param InputType Input data type. 
   * @param OutputType Binary output data type. 
   * @param InputData The input file to upload. (optional)
   * @return Future(void)
   */
  def rawPredictBinaryAsync(InputType: String, OutputType: String, InputData: Option[File] = None) = {
      helper.rawPredictBinary(InputType, OutputType, InputData)
  }

  /**
   * Refresh the remote job status. Can be used for monitoring.
   * 
   *
   * @param JobId Job ID 
   * @return JobEntity
   */
  def refreshJobStatus(JobId: Long): Option[JobEntity] = {
    val await = Try(Await.result(refreshJobStatusAsync(JobId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Refresh the remote job status. Can be used for monitoring. asynchronously
   * 
   *
   * @param JobId Job ID 
   * @return Future(JobEntity)
   */
  def refreshJobStatusAsync(JobId: Long): Future[JobEntity] = {
      helper.refreshJobStatus(JobId)
  }

  /**
   * Register a new user
   * 
   *
   * @param User User details 
   * @return User
   */
  def registerUser(User: User): Option[User] = {
    val await = Try(Await.result(registerUserAsync(User), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Register a new user asynchronously
   * 
   *
   * @param User User details 
   * @return Future(User)
   */
  def registerUserAsync(User: User): Future[User] = {
      helper.registerUser(User)
  }

  /**
   * Reimport a model to a previous deployed model in a deployment
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @param Body the deployment request 
   * @return ModelEntity
   */
  def reimportModel(DeploymentId: String, ModelId: String, Body: ImportModelRequest): Option[ModelEntity] = {
    val await = Try(Await.result(reimportModelAsync(DeploymentId, ModelId, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Reimport a model to a previous deployed model in a deployment asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @param Body the deployment request 
   * @return Future(ModelEntity)
   */
  def reimportModelAsync(DeploymentId: String, ModelId: String, Body: ImportModelRequest): Future[ModelEntity] = {
      helper.reimportModel(DeploymentId, ModelId, Body)
  }

  /**
   * Revoke a user token.
   * 
   *
   * @param TokenId Token ID 
   * @return Token
   */
  def revokeUserToken(TokenId: Long): Option[Token] = {
    val await = Try(Await.result(revokeUserTokenAsync(TokenId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Revoke a user token. asynchronously
   * 
   *
   * @param TokenId Token ID 
   * @return Future(Token)
   */
  def revokeUserTokenAsync(TokenId: Long): Future[Token] = {
      helper.revokeUserToken(TokenId)
  }

  /**
   * Rollback to a previous revision of the model.
   * 
   *
   * @param Index Model revision index. 
   * @return RollbackStatus
   */
  def rollback(Index: Integer): Option[RollbackStatus] = {
    val await = Try(Await.result(rollbackAsync(Index), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Rollback to a previous revision of the model. asynchronously
   * 
   *
   * @param Index Model revision index. 
   * @return Future(RollbackStatus)
   */
  def rollbackAsync(Index: Integer): Future[RollbackStatus] = {
      helper.rollback(Index)
  }

  /**
   * Start running an (already created) job on the remote resource
   * 
   *
   * @param JobId Job ID 
   * @return JobEntity
   */
  def runAJob(JobId: Long): Option[JobEntity] = {
    val await = Try(Await.result(runAJobAsync(JobId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Start running an (already created) job on the remote resource asynchronously
   * 
   *
   * @param JobId Job ID 
   * @return Future(JobEntity)
   */
  def runAJobAsync(JobId: Long): Future[JobEntity] = {
      helper.runAJob(JobId)
  }

  /**
   * Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord
   * Takes a batch of SingleCSVRecord object and transforms it into the desired format
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param BatchCSVRecord The input batch of record arrays (optional)
   * @return BatchCSVRecord
   */
  def transformCsv(DeploymentName: String, VersionName: String, TransformName: String, BatchCSVRecord: Option[BatchCSVRecord] = None): Option[BatchCSVRecord] = {
    val await = Try(Await.result(transformCsvAsync(DeploymentName, VersionName, TransformName, BatchCSVRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord asynchronously
   * Takes a batch of SingleCSVRecord object and transforms it into the desired format
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param BatchCSVRecord The input batch of record arrays (optional)
   * @return Future(BatchCSVRecord)
   */
  def transformCsvAsync(DeploymentName: String, VersionName: String, TransformName: String, BatchCSVRecord: Option[BatchCSVRecord] = None): Future[BatchCSVRecord] = {
      helper.transformCsv(DeploymentName, VersionName, TransformName, BatchCSVRecord)
  }

  /**
   * Takes a batch input arrays and transforms it
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param BatchRecord The input batch of record arrays (optional)
   * @return Base64NDArrayBody
   */
  def transformarray(DeploymentName: String, VersionName: String, TransformName: String, BatchRecord: Option[BatchRecord] = None): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformarrayAsync(DeploymentName, VersionName, TransformName, BatchRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes a batch input arrays and transforms it asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param BatchRecord The input batch of record arrays (optional)
   * @return Future(Base64NDArrayBody)
   */
  def transformarrayAsync(DeploymentName: String, VersionName: String, TransformName: String, BatchRecord: Option[BatchRecord] = None): Future[Base64NDArrayBody] = {
      helper.transformarray(DeploymentName, VersionName, TransformName, BatchRecord)
  }

  /**
   * Takes multiple multipart image file to transform and returns Base64NDArrayBody
   * Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param Files The image files to upload 
   * @return Base64NDArrayBody
   */
  def transformimage(DeploymentName: String, VersionName: String, ImageTransformName: String, Files: List[Array[Byte]]): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformimageAsync(DeploymentName, VersionName, ImageTransformName, Files), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes multiple multipart image file to transform and returns Base64NDArrayBody asynchronously
   * Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param Files The image files to upload 
   * @return Future(Base64NDArrayBody)
   */
  def transformimageAsync(DeploymentName: String, VersionName: String, ImageTransformName: String, Files: List[Array[Byte]]): Future[Base64NDArrayBody] = {
      helper.transformimage(DeploymentName, VersionName, ImageTransformName, Files)
  }

  /**
   * Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord
   * Takes a SingleCSVRecord object and transforms it into the desired format
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param SingleCSVRecord The input record array (optional)
   * @return SingleCSVRecord
   */
  def transformincrementalCsv(DeploymentName: String, VersionName: String, TransformName: String, SingleCSVRecord: Option[SingleCSVRecord] = None): Option[SingleCSVRecord] = {
    val await = Try(Await.result(transformincrementalCsvAsync(DeploymentName, VersionName, TransformName, SingleCSVRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord asynchronously
   * Takes a SingleCSVRecord object and transforms it into the desired format
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param SingleCSVRecord The input record array (optional)
   * @return Future(SingleCSVRecord)
   */
  def transformincrementalCsvAsync(DeploymentName: String, VersionName: String, TransformName: String, SingleCSVRecord: Option[SingleCSVRecord] = None): Future[SingleCSVRecord] = {
      helper.transformincrementalCsv(DeploymentName, VersionName, TransformName, SingleCSVRecord)
  }

  /**
   * Same as /transformincremental but returns Base64NDArrayBody.
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param SingleRecord The input record array (optional)
   * @return Base64NDArrayBody
   */
  def transformincrementalarray(DeploymentName: String, VersionName: String, TransformName: String, SingleRecord: Option[SingleRecord] = None): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformincrementalarrayAsync(DeploymentName, VersionName, TransformName, SingleRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Same as /transformincremental but returns Base64NDArrayBody. asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param SingleRecord The input record array (optional)
   * @return Future(Base64NDArrayBody)
   */
  def transformincrementalarrayAsync(DeploymentName: String, VersionName: String, TransformName: String, SingleRecord: Option[SingleRecord] = None): Future[Base64NDArrayBody] = {
      helper.transformincrementalarray(DeploymentName, VersionName, TransformName, SingleRecord)
  }

  /**
   * Takes a single multipart image file to transform and returns Base64NDArrayBody
   * Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param File The image file to upload 
   * @return Base64NDArrayBody
   */
  def transformincrementalimage(DeploymentName: String, VersionName: String, ImageTransformName: String, File: File): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformincrementalimageAsync(DeploymentName, VersionName, ImageTransformName, File), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes a single multipart image file to transform and returns Base64NDArrayBody asynchronously
   * Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param File The image file to upload 
   * @return Future(Base64NDArrayBody)
   */
  def transformincrementalimageAsync(DeploymentName: String, VersionName: String, ImageTransformName: String, File: File): Future[Base64NDArrayBody] = {
      helper.transformincrementalimage(DeploymentName, VersionName, ImageTransformName, File)
  }

  /**
   * Gets the JSON string of the deployed transform process (CSV or Image)
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @return Any
   */
  def transformprocessGet(DeploymentName: String, VersionName: String, TransformName: String): Option[Any] = {
    val await = Try(Await.result(transformprocessGetAsync(DeploymentName, VersionName, TransformName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the JSON string of the deployed transform process (CSV or Image) asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @return Future(Any)
   */
  def transformprocessGetAsync(DeploymentName: String, VersionName: String, TransformName: String): Future[Any] = {
      helper.transformprocessGet(DeploymentName, VersionName, TransformName)
  }

  /**
   * Sets the deployed (CSV or Image) transform process through the provided JSON string
   * 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should be &#x60;application/json&#x60;. 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param TransformProcess The transform process to set (Specify a JSON string here). (optional)
   * @return Any
   */
  def transformprocessPost(`ContentType`: String, DeploymentName: String, VersionName: String, TransformName: String, TransformProcess: Option[String] = None): Option[Any] = {
    val await = Try(Await.result(transformprocessPostAsync(`ContentType`, DeploymentName, VersionName, TransformName, TransformProcess), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Sets the deployed (CSV or Image) transform process through the provided JSON string asynchronously
   * 
   *
   * @param `ContentType` The &#x60;Content-Type&#x60; should be &#x60;application/json&#x60;. 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param TransformProcess The transform process to set (Specify a JSON string here). (optional)
   * @return Future(Any)
   */
  def transformprocessPostAsync(`ContentType`: String, DeploymentName: String, VersionName: String, TransformName: String, TransformProcess: Option[String] = None): Future[Any] = {
      helper.transformprocessPost(`ContentType`, DeploymentName, VersionName, TransformName, TransformProcess)
  }

  /**
   * Update auth policy
   * 
   *
   * @param AuthPolicy Auth policy object 
   * @return AuthPolicy
   */
  def updateAuthPolicy(AuthPolicy: AuthPolicy): Option[AuthPolicy] = {
    val await = Try(Await.result(updateAuthPolicyAsync(AuthPolicy), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update auth policy asynchronously
   * 
   *
   * @param AuthPolicy Auth policy object 
   * @return Future(AuthPolicy)
   */
  def updateAuthPolicyAsync(AuthPolicy: AuthPolicy): Future[AuthPolicy] = {
      helper.updateAuthPolicy(AuthPolicy)
  }

  /**
   * Updates the best model for an experiment
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param UpdateBestModel Model encapsulating the experiment id to update and the best model id. 
   * @return ExperimentEntity
   */
  def updateBestModelForExperiment(ModelHistoryServerId: String, UpdateBestModel: UpdateBestModel): Option[ExperimentEntity] = {
    val await = Try(Await.result(updateBestModelForExperimentAsync(ModelHistoryServerId, UpdateBestModel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates the best model for an experiment asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param UpdateBestModel Model encapsulating the experiment id to update and the best model id. 
   * @return Future(ExperimentEntity)
   */
  def updateBestModelForExperimentAsync(ModelHistoryServerId: String, UpdateBestModel: UpdateBestModel): Future[ExperimentEntity] = {
      helper.updateBestModelForExperiment(ModelHistoryServerId, UpdateBestModel)
  }

  /**
   * Updates an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to update 
   * @param ExperimentEntity The experiment entity to update with 
   * @return ExperimentEntity
   */
  def updateExperiment(ModelHistoryServerId: String, ExperimentID: String, ExperimentEntity: ExperimentEntity): Option[ExperimentEntity] = {
    val await = Try(Await.result(updateExperimentAsync(ModelHistoryServerId, ExperimentID, ExperimentEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to update 
   * @param ExperimentEntity The experiment entity to update with 
   * @return Future(ExperimentEntity)
   */
  def updateExperimentAsync(ModelHistoryServerId: String, ExperimentID: String, ExperimentEntity: ExperimentEntity): Future[ExperimentEntity] = {
      helper.updateExperiment(ModelHistoryServerId, ExperimentID, ExperimentEntity)
  }

  /**
   * Update a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to update 
   * @param UpdateModelHistoryRequest The model history request object 
   * @return ModelHistoryEntity
   */
  def updateModelHistory(ModelHistoryServerId: String, ModelHistoryID: String, UpdateModelHistoryRequest: AddModelHistoryRequest): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(updateModelHistoryAsync(ModelHistoryServerId, ModelHistoryID, UpdateModelHistoryRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to update 
   * @param UpdateModelHistoryRequest The model history request object 
   * @return Future(ModelHistoryEntity)
   */
  def updateModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String, UpdateModelHistoryRequest: AddModelHistoryRequest): Future[ModelHistoryEntity] = {
      helper.updateModelHistory(ModelHistoryServerId, ModelHistoryID, UpdateModelHistoryRequest)
  }

  /**
   * Update a user
   * 
   *
   * @param User User details 
   * @return User
   */
  def updateUser(User: User): Option[User] = {
    val await = Try(Await.result(updateUserAsync(User), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a user asynchronously
   * 
   *
   * @param User User details 
   * @return Future(User)
   */
  def updateUserAsync(User: User): Future[User] = {
      helper.updateUser(User)
  }

  /**
   * Upload a model file to SKIL for import.
   * 
   *
   * @param File The file to upload. (optional)
   * @return FileUploadList
   */
  def upload(File: Option[File] = None): Option[FileUploadList] = {
    val await = Try(Await.result(uploadAsync(File), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Upload a model file to SKIL for import. asynchronously
   * 
   *
   * @param File The file to upload. (optional)
   * @return Future(FileUploadList)
   */
  def uploadAsync(File: Option[File] = None): Future[FileUploadList] = {
      helper.upload(File)
  }

}

class DefaultApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def accumulatedResults()(implicit reader: ClientResponseReader[AccumulatedResults]): Future[AccumulatedResults] = {
    // create path and map variables
    val path = (addFmt("/accumulatedresults"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addCredentials(AddCredentialsRequest: AddCredentialsRequest)(implicit reader: ClientResponseReader[ResourceCredentials], writer: RequestWriter[AddCredentialsRequest]): Future[ResourceCredentials] = {
    // create path and map variables
    val path = (addFmt("/resources/credentials"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (AddCredentialsRequest == null) throw new Exception("Missing required parameter 'AddCredentialsRequest' when calling DefaultApi->addCredentials")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AddCredentialsRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addEvaluationResult(ModelHistoryServerId: String,
    EvaluationResultsEntity: EvaluationResultsEntity)(implicit reader: ClientResponseReader[EvaluationResultsEntity], writer: RequestWriter[EvaluationResultsEntity]): Future[EvaluationResultsEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions/evaluations/")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addEvaluationResult")

    if (EvaluationResultsEntity == null) throw new Exception("Missing required parameter 'EvaluationResultsEntity' when calling DefaultApi->addEvaluationResult")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(EvaluationResultsEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExampleForBatch(ModelHistoryServerId: String,
    AddExampleRequest: AddExampleRequest)(implicit reader: ClientResponseReader[AddExampleRequest], writer: RequestWriter[AddExampleRequest]): Future[AddExampleRequest] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/exampleForBatch")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addExampleForBatch")

    if (AddExampleRequest == null) throw new Exception("Missing required parameter 'AddExampleRequest' when calling DefaultApi->addExampleForBatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AddExampleRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExampleToMinibatch(ModelHistoryServerId: String,
    ExampleEntity: ExampleEntity)(implicit reader: ClientResponseReader[ExampleEntity], writer: RequestWriter[ExampleEntity]): Future[ExampleEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/example")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addExampleToMinibatch")

    if (ExampleEntity == null) throw new Exception("Missing required parameter 'ExampleEntity' when calling DefaultApi->addExampleToMinibatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ExampleEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExperiment(ModelHistoryServerId: String,
    ExperimentEntity: ExperimentEntity)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addExperiment")

    if (ExperimentEntity == null) throw new Exception("Missing required parameter 'ExperimentEntity' when calling DefaultApi->addExperiment")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ExperimentEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addFeedbackBinary(Id: String,
    `Type`: String,
    File: Option[File] = None
    )(implicit reader: ClientResponseReader[FeedbackResponse]): Future[FeedbackResponse] = {
    // create path and map variables
    val path = (addFmt("/feedback/{id}/{type}")
      replaceAll("\\{" + "id" + "\\}", Id.toString)
      replaceAll("\\{" + "type" + "\\}", `Type`.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Id == null) throw new Exception("Missing required parameter 'Id' when calling DefaultApi->addFeedbackBinary")

    if (`Type` == null) throw new Exception("Missing required parameter '`Type`' when calling DefaultApi->addFeedbackBinary")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addFeedbackJson(Id: String,
    Labels: Option[List[List[Double]]] = None
    )(implicit reader: ClientResponseReader[FeedbackResponse], writer: RequestWriter[Option[List[List[Double]]]]): Future[FeedbackResponse] = {
    // create path and map variables
    val path = (addFmt("/feedback/{id}/json")
      replaceAll("\\{" + "id" + "\\}", Id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Id == null) throw new Exception("Missing required parameter 'Id' when calling DefaultApi->addFeedbackJson")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Labels))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addMinibatch(ModelHistoryServerId: String,
    MinibatchEntity: MinibatchEntity)(implicit reader: ClientResponseReader[MinibatchEntity], writer: RequestWriter[MinibatchEntity]): Future[MinibatchEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/minibatch")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addMinibatch")

    if (MinibatchEntity == null) throw new Exception("Missing required parameter 'MinibatchEntity' when calling DefaultApi->addMinibatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(MinibatchEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelFeedback(ModelHistoryServerId: String,
    ModelFeedBackRequest: ModelFeedBackRequest)(implicit reader: ClientResponseReader[ModelFeedBackRequest], writer: RequestWriter[ModelFeedBackRequest]): Future[ModelFeedBackRequest] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/feedback")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addModelFeedback")

    if (ModelFeedBackRequest == null) throw new Exception("Missing required parameter 'ModelFeedBackRequest' when calling DefaultApi->addModelFeedback")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelFeedBackRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelHistory(ModelHistoryServerId: String,
    AddModelHistoryRequest: AddModelHistoryRequest)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[AddModelHistoryRequest]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addModelHistory")

    if (AddModelHistoryRequest == null) throw new Exception("Missing required parameter 'AddModelHistoryRequest' when calling DefaultApi->addModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AddModelHistoryRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelInstance(ModelHistoryServerId: String,
    ModelInstanceEntity: ModelInstanceEntity)(implicit reader: ClientResponseReader[ModelInstanceEntity], writer: RequestWriter[ModelInstanceEntity]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addModelInstance")

    if (ModelInstanceEntity == null) throw new Exception("Missing required parameter 'ModelInstanceEntity' when calling DefaultApi->addModelInstance")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelInstanceEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addResource(AddResourceRequest: AddResourceRequest)(implicit reader: ClientResponseReader[Any], writer: RequestWriter[AddResourceRequest]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/resources/add/resource"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (AddResourceRequest == null) throw new Exception("Missing required parameter 'AddResourceRequest' when calling DefaultApi->addResource")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AddResourceRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addResourceGroup(GroupName: String)(implicit reader: ClientResponseReader[ResourceGroup], writer: RequestWriter[String]): Future[ResourceGroup] = {
    // create path and map variables
    val path = (addFmt("/resources/add/group"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (GroupName == null) throw new Exception("Missing required parameter 'GroupName' when calling DefaultApi->addResourceGroup")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(GroupName))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addResourceToGroup(ResourceGroupId: Long,
    ResourceId: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/resources/add/resourcetogroup/{resourceGroupId}/{resourceId}")
      replaceAll("\\{" + "resourceGroupId" + "\\}", ResourceGroupId.toString)
      replaceAll("\\{" + "resourceId" + "\\}", ResourceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def aggregateModelResults(ModelHistoryServerId: String,
    AggregatePrediction: AggregatePrediction)(implicit reader: ClientResponseReader[EvaluationResultsEntity], writer: RequestWriter[AggregatePrediction]): Future[EvaluationResultsEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/aggregateresults")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->aggregateModelResults")

    if (AggregatePrediction == null) throw new Exception("Missing required parameter 'AggregatePrediction' when calling DefaultApi->aggregateModelResults")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AggregatePrediction))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def changeUserPassword(UserId: String,
    ChangePasswordRequest: ChangePasswordRequest)(implicit reader: ClientResponseReader[User], writer: RequestWriter[ChangePasswordRequest]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user/{userId}/password")
      replaceAll("\\{" + "userId" + "\\}", UserId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (UserId == null) throw new Exception("Missing required parameter 'UserId' when calling DefaultApi->changeUserPassword")

    if (ChangePasswordRequest == null) throw new Exception("Missing required parameter 'ChangePasswordRequest' when calling DefaultApi->changeUserPassword")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ChangePasswordRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def classify(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[ClassificationResult], writer: RequestWriter[Prediction]): Future[ClassificationResult] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/classify")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->classify")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->classify")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->classify")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->classify")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def classifyarray(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[Base64NDArrayBody], writer: RequestWriter[Prediction]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->classifyarray")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->classifyarray")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->classifyarray")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->classifyarray")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def classifyimage(DeploymentName: String,
    VersionName: String,
    ModelName: String,
    Image: Option[File] = None
    )(implicit reader: ClientResponseReader[ClassificationResult]): Future[ClassificationResult] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->classifyimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->classifyimage")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->classifyimage")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def clearState()(implicit reader: ClientResponseReader[FeedbackResponse]): Future[FeedbackResponse] = {
    // create path and map variables
    val path = (addFmt("/clear"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createJob(JobIdOrType: String,
    CreateJobRequest: CreateJobRequest)(implicit reader: ClientResponseReader[JobEntity], writer: RequestWriter[CreateJobRequest]): Future[JobEntity] = {
    // create path and map variables
    val path = (addFmt("/jobs/{jobIdOrType}")
      replaceAll("\\{" + "jobIdOrType" + "\\}", JobIdOrType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (JobIdOrType == null) throw new Exception("Missing required parameter 'JobIdOrType' when calling DefaultApi->createJob")

    if (CreateJobRequest == null) throw new Exception("Missing required parameter 'CreateJobRequest' when calling DefaultApi->createJob")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(CreateJobRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createModelHistory(ModelHistoryServerId: String,
    ModelHistoryEntity: ModelHistoryEntity)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[ModelHistoryEntity]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->createModelHistory")

    if (ModelHistoryEntity == null) throw new Exception("Missing required parameter 'ModelHistoryEntity' when calling DefaultApi->createModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelHistoryEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteCredentialsById(CredentialId: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/resources/credentials/{credentialId}")
      replaceAll("\\{" + "credentialId" + "\\}", CredentialId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->deleteExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling DefaultApi->deleteExperiment")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteJobById(JobIdOrType: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/jobs/{jobIdOrType}")
      replaceAll("\\{" + "jobIdOrType" + "\\}", JobIdOrType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModel(DeploymentId: String,
    ModelId: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model/{modelId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString)
      replaceAll("\\{" + "modelId" + "\\}", ModelId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->deleteModel")

    if (ModelId == null) throw new Exception("Missing required parameter 'ModelId' when calling DefaultApi->deleteModel")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->deleteModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling DefaultApi->deleteModelHistory")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModelInstance(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->deleteModelInstance")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling DefaultApi->deleteModelInstance")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteResourceById(ResourceId: Long)(implicit reader: ClientResponseReader[Resource]): Future[Resource] = {
    // create path and map variables
    val path = (addFmt("/resources/remove/resource/{resourceId}")
      replaceAll("\\{" + "resourceId" + "\\}", ResourceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteResourceFromGroup(ResourceGroupId: Long,
    ResourceId: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/resources/remove/resourcefromgroup/{resourceGroupId}/{resourceId}")
      replaceAll("\\{" + "resourceGroupId" + "\\}", ResourceGroupId.toString)
      replaceAll("\\{" + "resourceId" + "\\}", ResourceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteResourceGroupById(ResourceGroupId: Long)(implicit reader: ClientResponseReader[ResourceGroup]): Future[ResourceGroup] = {
    // create path and map variables
    val path = (addFmt("/resources/remove/group/{resourceGroupId}")
      replaceAll("\\{" + "resourceGroupId" + "\\}", ResourceGroupId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deployModel(DeploymentId: String,
    Body: ImportModelRequest)(implicit reader: ClientResponseReader[ModelEntity], writer: RequestWriter[ImportModelRequest]): Future[ModelEntity] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->deployModel")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->deployModel")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deploymentCreate(Body: CreateDeploymentRequest)(implicit reader: ClientResponseReader[DeploymentResponse], writer: RequestWriter[CreateDeploymentRequest]): Future[DeploymentResponse] = {
    // create path and map variables
    val path = (addFmt("/deployment"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->deploymentCreate")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deploymentDelete(DeploymentId: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->deploymentDelete")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deploymentGet(DeploymentId: String)(implicit reader: ClientResponseReader[DeploymentResponse]): Future[DeploymentResponse] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->deploymentGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deployments()(implicit reader: ClientResponseReader[List[DeploymentResponse]]): Future[List[DeploymentResponse]] = {
    // create path and map variables
    val path = (addFmt("/deployments"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def detectobjects(Id: String,
    NeedsPreprocessing: Boolean,
    Threshold: Float,
    File: File,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[DetectionResult]): Future[DetectionResult] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/detectobjects")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Id == null) throw new Exception("Missing required parameter 'Id' when calling DefaultApi->detectobjects")

    if (File == null) throw new Exception("Missing required parameter 'File' when calling DefaultApi->detectobjects")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->detectobjects")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->detectobjects")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->detectobjects")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def downloadJobOutputFile(JobId: Long,
    DownloadOutputFileRequest: DownloadOutputFileRequest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[DownloadOutputFileRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/jobs/{jobId}/outputfile")
      replaceAll("\\{" + "jobId" + "\\}", JobId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DownloadOutputFileRequest == null) throw new Exception("Missing required parameter 'DownloadOutputFileRequest' when calling DefaultApi->downloadJobOutputFile")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(DownloadOutputFileRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def generateAuthToken(TokenGenerateRequest: TokenGenerateRequest)(implicit reader: ClientResponseReader[Token], writer: RequestWriter[TokenGenerateRequest]): Future[Token] = {
    // create path and map variables
    val path = (addFmt("/auth/token"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (TokenGenerateRequest == null) throw new Exception("Missing required parameter 'TokenGenerateRequest' when calling DefaultApi->generateAuthToken")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(TokenGenerateRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getAllJobs()(implicit reader: ClientResponseReader[List[JobEntity]]): Future[List[JobEntity]] = {
    // create path and map variables
    val path = (addFmt("/jobs"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getArray(Accept: String,
    ArrayType: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/array/{arrayType}")
      replaceAll("\\{" + "arrayType" + "\\}", ArrayType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Accept == null) throw new Exception("Missing required parameter 'Accept' when calling DefaultApi->getArray")

    if (ArrayType == null) throw new Exception("Missing required parameter 'ArrayType' when calling DefaultApi->getArray")

    headerParams += "accept" -> Accept.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getArrayIndices(`ContentType`: String,
    Accept: String,
    ArrayType: String,
    Input: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[String]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/array/indices/{arrayType}")
      replaceAll("\\{" + "arrayType" + "\\}", ArrayType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`ContentType` == null) throw new Exception("Missing required parameter '`ContentType`' when calling DefaultApi->getArrayIndices")

    if (Accept == null) throw new Exception("Missing required parameter 'Accept' when calling DefaultApi->getArrayIndices")

    if (ArrayType == null) throw new Exception("Missing required parameter 'ArrayType' when calling DefaultApi->getArrayIndices")

    headerParams += "Content-Type" -> `ContentType`.toString
    headerParams += "accept" -> Accept.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Input))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getArrayRange(Accept: String,
    ArrayType: String,
    From: Integer,
    To: Integer)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/array/range/{from}/{to}/{arrayType}")
      replaceAll("\\{" + "arrayType" + "\\}", ArrayType.toString)
      replaceAll("\\{" + "from" + "\\}", From.toString)
      replaceAll("\\{" + "to" + "\\}", To.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Accept == null) throw new Exception("Missing required parameter 'Accept' when calling DefaultApi->getArrayRange")

    if (ArrayType == null) throw new Exception("Missing required parameter 'ArrayType' when calling DefaultApi->getArrayRange")

    headerParams += "accept" -> Accept.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getAuthPolicy()(implicit reader: ClientResponseReader[AuthPolicy]): Future[AuthPolicy] = {
    // create path and map variables
    val path = (addFmt("/auth/policy"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getBestModelAmongModelIds(ModelHistoryServerId: String,
    BestModel: BestModel)(implicit reader: ClientResponseReader[ModelInstanceEntity], writer: RequestWriter[BestModel]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/best")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getBestModelAmongModelIds")

    if (BestModel == null) throw new Exception("Missing required parameter 'BestModel' when calling DefaultApi->getBestModelAmongModelIds")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(BestModel))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getCredentialsById(CredentialId: Long)(implicit reader: ClientResponseReader[ResourceCredentials]): Future[ResourceCredentials] = {
    // create path and map variables
    val path = (addFmt("/resources/credentials/{credentialId}")
      replaceAll("\\{" + "credentialId" + "\\}", CredentialId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getCurrentModel()(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/model"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEvaluationForModelID(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[List[EvaluationResultsEntity]]): Future[List[EvaluationResultsEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions/evaluations/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getEvaluationForModelID")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling DefaultApi->getEvaluationForModelID")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExamplesForMinibatch(ModelHistoryServerId: String,
    MinibatchId: String)(implicit reader: ClientResponseReader[List[ExampleEntity]]): Future[List[ExampleEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/example/{minibatchId}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "minibatchId" + "\\}", MinibatchId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getExamplesForMinibatch")

    if (MinibatchId == null) throw new Exception("Missing required parameter 'MinibatchId' when calling DefaultApi->getExamplesForMinibatch")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling DefaultApi->getExperiment")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExperimentsForModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiments/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getExperimentsForModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling DefaultApi->getExperimentsForModelHistory")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getJobById(JobIdOrType: Long)(implicit reader: ClientResponseReader[JobEntity]): Future[JobEntity] = {
    // create path and map variables
    val path = (addFmt("/jobs/{jobIdOrType}")
      replaceAll("\\{" + "jobIdOrType" + "\\}", JobIdOrType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getLastEvaluation()(implicit reader: ClientResponseReader[EvaluationResultsEntity]): Future[EvaluationResultsEntity] = {
    // create path and map variables
    val path = (addFmt("/lastevaluation"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getMinibatch(ModelHistoryServerId: String,
    MinibatchId: String)(implicit reader: ClientResponseReader[MinibatchEntity]): Future[MinibatchEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/minibatch/{minibatchId}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "minibatchId" + "\\}", MinibatchId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getMinibatch")

    if (MinibatchId == null) throw new Exception("Missing required parameter 'MinibatchId' when calling DefaultApi->getMinibatch")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelDetails(DeploymentId: String,
    ModelId: String)(implicit reader: ClientResponseReader[ModelEntity]): Future[ModelEntity] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model/{modelId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString)
      replaceAll("\\{" + "modelId" + "\\}", ModelId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->getModelDetails")

    if (ModelId == null) throw new Exception("Missing required parameter 'ModelId' when calling DefaultApi->getModelDetails")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[ModelHistoryEntity]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revision/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling DefaultApi->getModelHistory")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelInstance(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[ModelInstanceEntity]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getModelInstance")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling DefaultApi->getModelInstance")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelsForExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[List[ModelInstanceEntity]]): Future[List[ModelInstanceEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}/models")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getModelsForExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling DefaultApi->getModelsForExperiment")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getResourceById(ResourceId: Long)(implicit reader: ClientResponseReader[Resource]): Future[Resource] = {
    // create path and map variables
    val path = (addFmt("/resources/resource/{resourceId}")
      replaceAll("\\{" + "resourceId" + "\\}", ResourceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getResourceBySubType(ResourceSubType: String)(implicit reader: ClientResponseReader[List[Resource]]): Future[List[Resource]] = {
    // create path and map variables
    val path = (addFmt("/resources/resources/subtype/{resourceSubType}")
      replaceAll("\\{" + "resourceSubType" + "\\}", ResourceSubType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ResourceSubType == null) throw new Exception("Missing required parameter 'ResourceSubType' when calling DefaultApi->getResourceBySubType")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getResourceByType(ResourceType: String)(implicit reader: ClientResponseReader[List[Resource]]): Future[List[Resource]] = {
    // create path and map variables
    val path = (addFmt("/resources/resources/type/{resourceType}")
      replaceAll("\\{" + "resourceType" + "\\}", ResourceType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ResourceType == null) throw new Exception("Missing required parameter 'ResourceType' when calling DefaultApi->getResourceByType")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getResourceDetailsById(ResourceId: Long)(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/resources/details/{resourceId}")
      replaceAll("\\{" + "resourceId" + "\\}", ResourceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getResourceGroupById(ResourceGroupId: Long)(implicit reader: ClientResponseReader[ResourceGroup]): Future[ResourceGroup] = {
    // create path and map variables
    val path = (addFmt("/resources/group/{resourceGroupId}")
      replaceAll("\\{" + "resourceGroupId" + "\\}", ResourceGroupId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getResourceGroups()(implicit reader: ClientResponseReader[List[ResourceGroup]]): Future[List[ResourceGroup]] = {
    // create path and map variables
    val path = (addFmt("/resources/groups"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getResources()(implicit reader: ClientResponseReader[List[Resource]]): Future[List[Resource]] = {
    // create path and map variables
    val path = (addFmt("/resources/resources"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getResourcesFromGroup(ResourceGroupId: Long)(implicit reader: ClientResponseReader[List[Resource]]): Future[List[Resource]] = {
    // create path and map variables
    val path = (addFmt("/resources/group/{resourceGroupId}/resources")
      replaceAll("\\{" + "resourceGroupId" + "\\}", ResourceGroupId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getRoles()(implicit reader: ClientResponseReader[List[Role]]): Future[List[Role]] = {
    // create path and map variables
    val path = (addFmt("/security/roles"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUser(UserId: String)(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user/{userId}")
      replaceAll("\\{" + "userId" + "\\}", UserId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (UserId == null) throw new Exception("Missing required parameter 'UserId' when calling DefaultApi->getUser")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserAuthTokens(UserId: String,
    OnlyValid: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[List[Token]]): Future[List[Token]] = {
    // create path and map variables
    val path = (addFmt("/auth/{userId}/tokens")
      replaceAll("\\{" + "userId" + "\\}", UserId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (UserId == null) throw new Exception("Missing required parameter 'UserId' when calling DefaultApi->getUserAuthTokens")

    OnlyValid match {
      case Some(param) => queryParams += "onlyValid" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUsers()(implicit reader: ClientResponseReader[List[User]]): Future[List[User]] = {
    // create path and map variables
    val path = (addFmt("/security/users"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def isTraining()(implicit reader: ClientResponseReader[RetrainingStatus]): Future[RetrainingStatus] = {
    // create path and map variables
    val path = (addFmt("/istraining"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def jsonarray(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[JsonArrayResponse], writer: RequestWriter[Prediction]): Future[JsonArrayResponse] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/jsonarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->jsonarray")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->jsonarray")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->jsonarray")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->jsonarray")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def knn(DeploymentName: String,
    VersionName: String,
    KnnName: String,
    Body: NearestNeighborRequest)(implicit reader: ClientResponseReader[NearestNeighborsResults], writer: RequestWriter[NearestNeighborRequest]): Future[NearestNeighborsResults] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knn")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "knnName" + "\\}", KnnName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->knn")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->knn")

    if (KnnName == null) throw new Exception("Missing required parameter 'KnnName' when calling DefaultApi->knn")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->knn")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def knnnew(DeploymentName: String,
    VersionName: String,
    KnnName: String,
    Body: Base64NDArrayBodyKNN)(implicit reader: ClientResponseReader[NearestNeighborsResults], writer: RequestWriter[Base64NDArrayBodyKNN]): Future[NearestNeighborsResults] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knnnew")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "knnName" + "\\}", KnnName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->knnnew")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->knnnew")

    if (KnnName == null) throw new Exception("Missing required parameter 'KnnName' when calling DefaultApi->knnnew")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->knnnew")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listAllExperiments(ModelHistoryServerId: String)(implicit reader: ClientResponseReader[List[ExperimentEntity]]): Future[List[ExperimentEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiments")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->listAllExperiments")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def logfilepath(DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/logfilepath")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->logfilepath")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->logfilepath")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->logfilepath")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def login(LoginRequest: LoginRequest)(implicit reader: ClientResponseReader[LoginResponse], writer: RequestWriter[LoginRequest]): Future[LoginResponse] = {
    // create path and map variables
    val path = (addFmt("/login"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (LoginRequest == null) throw new Exception("Missing required parameter 'LoginRequest' when calling DefaultApi->login")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(LoginRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def logs(DeploymentName: String,
    VersionName: String,
    ModelName: String,
    LogRequest: LogRequest)(implicit reader: ClientResponseReader[LogBatch], writer: RequestWriter[LogRequest]): Future[LogBatch] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/logs")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->logs")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->logs")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->logs")

    if (LogRequest == null) throw new Exception("Missing required parameter 'LogRequest' when calling DefaultApi->logs")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(LogRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def metaGet(DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MetaData]): Future[MetaData] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->metaGet")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->metaGet")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->metaGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def metaPost(`ContentType`: String,
    Body: String,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MetaData], writer: RequestWriter[String]): Future[MetaData] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`ContentType` == null) throw new Exception("Missing required parameter '`ContentType`' when calling DefaultApi->metaPost")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->metaPost")

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->metaPost")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->metaPost")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->metaPost")

    headerParams += "Content-Type" -> `ContentType`.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def modelStateChange(DeploymentId: String,
    ModelId: String,
    Body: SetState)(implicit reader: ClientResponseReader[ModelEntity], writer: RequestWriter[SetState]): Future[ModelEntity] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model/{modelId}/state")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString)
      replaceAll("\\{" + "modelId" + "\\}", ModelId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->modelStateChange")

    if (ModelId == null) throw new Exception("Missing required parameter 'ModelId' when calling DefaultApi->modelStateChange")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->modelStateChange")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def models(DeploymentId: String)(implicit reader: ClientResponseReader[List[ModelEntity]]): Future[List[ModelEntity]] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/models")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->models")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def modelset(DeploymentName: String,
    VersionName: String,
    ModelName: String,
    File: Option[File] = None
    )(implicit reader: ClientResponseReader[ModelStatus]): Future[ModelStatus] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelset")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->modelset")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->modelset")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->modelset")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def modelupdate(File: File,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[ModelStatus]): Future[ModelStatus] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelupdate")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (File == null) throw new Exception("Missing required parameter 'File' when calling DefaultApi->modelupdate")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->modelupdate")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->modelupdate")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->modelupdate")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def multiclassify(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MultiClassClassificationResult], writer: RequestWriter[Prediction]): Future[MultiClassClassificationResult] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/multiclassify")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->multiclassify")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->multiclassify")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->multiclassify")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->multiclassify")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def multipredict(Body: MultiPredictRequest,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MultiPredictResponse], writer: RequestWriter[MultiPredictRequest]): Future[MultiPredictResponse] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredict")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->multipredict")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->multipredict")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->multipredict")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->multipredict")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def multipredictimage(File: File,
    Id: String,
    NeedsPreprocessing: Boolean,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MultiPredictResponse]): Future[MultiPredictResponse] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredictimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (File == null) throw new Exception("Missing required parameter 'File' when calling DefaultApi->multipredictimage")
    if (Id == null) throw new Exception("Missing required parameter 'Id' when calling DefaultApi->multipredictimage")

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->multipredictimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->multipredictimage")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->multipredictimage")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def numRevisions()(implicit reader: ClientResponseReader[RevisionsWritten]): Future[RevisionsWritten] = {
    // create path and map variables
    val path = (addFmt("/numrevisions"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predict(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[Prediction], writer: RequestWriter[Prediction]): Future[Prediction] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/predict")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->predict")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->predict")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->predict")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->predict")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictError(`ContentType`: String,
    Operation: String,
    InputType: String,
    InputData: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[String]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/{operation}/{inputType}/error")
      replaceAll("\\{" + "operation" + "\\}", Operation.toString)
      replaceAll("\\{" + "inputType" + "\\}", InputType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`ContentType` == null) throw new Exception("Missing required parameter '`ContentType`' when calling DefaultApi->predictError")

    if (Operation == null) throw new Exception("Missing required parameter 'Operation' when calling DefaultApi->predictError")

    if (InputType == null) throw new Exception("Missing required parameter 'InputType' when calling DefaultApi->predictError")

    headerParams += "Content-Type" -> `ContentType`.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(InputData))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictV2File(Operation: String,
    InputTypeFile: String,
    InputData: File)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/{operation}/{inputTypeFile}")
      replaceAll("\\{" + "operation" + "\\}", Operation.toString)
      replaceAll("\\{" + "inputTypeFile" + "\\}", InputTypeFile.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Operation == null) throw new Exception("Missing required parameter 'Operation' when calling DefaultApi->predictV2File")

    if (InputTypeFile == null) throw new Exception("Missing required parameter 'InputTypeFile' when calling DefaultApi->predictV2File")

    if (InputData == null) throw new Exception("Missing required parameter 'InputData' when calling DefaultApi->predictV2File")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictV2Json(`ContentType`: String,
    Operation: String,
    InputTypeJson: String,
    InputData: String)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[String]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/{operation}/{inputTypeJson}")
      replaceAll("\\{" + "operation" + "\\}", Operation.toString)
      replaceAll("\\{" + "inputTypeJson" + "\\}", InputTypeJson.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`ContentType` == null) throw new Exception("Missing required parameter '`ContentType`' when calling DefaultApi->predictV2Json")

    if (Operation == null) throw new Exception("Missing required parameter 'Operation' when calling DefaultApi->predictV2Json")

    if (InputTypeJson == null) throw new Exception("Missing required parameter 'InputTypeJson' when calling DefaultApi->predictV2Json")

    if (InputData == null) throw new Exception("Missing required parameter 'InputData' when calling DefaultApi->predictV2Json")

    headerParams += "Content-Type" -> `ContentType`.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(InputData))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictimage(DeploymentName: String,
    VersionName: String,
    ModelName: String,
    Image: Option[File] = None
    )(implicit reader: ClientResponseReader[Prediction]): Future[Prediction] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->predictimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->predictimage")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->predictimage")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictwithpreprocess(Body: List[String],
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[Prediction], writer: RequestWriter[List[String]]): Future[Prediction] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocess")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->predictwithpreprocess")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->predictwithpreprocess")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->predictwithpreprocess")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictwithpreprocessjson(Body: List[String],
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[JsonArrayResponse], writer: RequestWriter[List[String]]): Future[JsonArrayResponse] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocessjson")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->predictwithpreprocessjson")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->predictwithpreprocessjson")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->predictwithpreprocessjson")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def rawPredictBinary(InputType: String,
    OutputType: String,
    InputData: Option[File] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/raw/{inputType}/{outputType}")
      replaceAll("\\{" + "inputType" + "\\}", InputType.toString)
      replaceAll("\\{" + "outputType" + "\\}", OutputType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (InputType == null) throw new Exception("Missing required parameter 'InputType' when calling DefaultApi->rawPredictBinary")

    if (OutputType == null) throw new Exception("Missing required parameter 'OutputType' when calling DefaultApi->rawPredictBinary")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def refreshJobStatus(JobId: Long)(implicit reader: ClientResponseReader[JobEntity]): Future[JobEntity] = {
    // create path and map variables
    val path = (addFmt("/jobs/{jobId}/refresh")
      replaceAll("\\{" + "jobId" + "\\}", JobId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def registerUser(User: User)(implicit reader: ClientResponseReader[User], writer: RequestWriter[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user/register"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (User == null) throw new Exception("Missing required parameter 'User' when calling DefaultApi->registerUser")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(User))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def reimportModel(DeploymentId: String,
    ModelId: String,
    Body: ImportModelRequest)(implicit reader: ClientResponseReader[ModelEntity], writer: RequestWriter[ImportModelRequest]): Future[ModelEntity] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model/{modelId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString)
      replaceAll("\\{" + "modelId" + "\\}", ModelId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->reimportModel")

    if (ModelId == null) throw new Exception("Missing required parameter 'ModelId' when calling DefaultApi->reimportModel")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->reimportModel")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def revokeUserToken(TokenId: Long)(implicit reader: ClientResponseReader[Token]): Future[Token] = {
    // create path and map variables
    val path = (addFmt("/auth/token/{tokenId}")
      replaceAll("\\{" + "tokenId" + "\\}", TokenId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def rollback(Index: Integer)(implicit reader: ClientResponseReader[RollbackStatus]): Future[RollbackStatus] = {
    // create path and map variables
    val path = (addFmt("/rollback/{index}")
      replaceAll("\\{" + "index" + "\\}", Index.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def runAJob(JobId: Long)(implicit reader: ClientResponseReader[JobEntity]): Future[JobEntity] = {
    // create path and map variables
    val path = (addFmt("/jobs/{jobId}/run")
      replaceAll("\\{" + "jobId" + "\\}", JobId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformCsv(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    BatchCSVRecord: Option[BatchCSVRecord] = None
    )(implicit reader: ClientResponseReader[BatchCSVRecord], writer: RequestWriter[Option[BatchCSVRecord]]): Future[BatchCSVRecord] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transform")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformCsv")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformCsv")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformCsv")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(BatchCSVRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformarray(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    BatchRecord: Option[BatchRecord] = None
    )(implicit reader: ClientResponseReader[Base64NDArrayBody], writer: RequestWriter[Option[BatchRecord]]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformarray")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformarray")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformarray")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(BatchRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformimage(DeploymentName: String,
    VersionName: String,
    ImageTransformName: String,
    Files: List[Array[Byte]])(implicit reader: ClientResponseReader[Base64NDArrayBody]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "imageTransformName" + "\\}", ImageTransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformimage")

    if (ImageTransformName == null) throw new Exception("Missing required parameter 'ImageTransformName' when calling DefaultApi->transformimage")

    if (Files == null) throw new Exception("Missing required parameter 'Files' when calling DefaultApi->transformimage")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformincrementalCsv(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    SingleCSVRecord: Option[SingleCSVRecord] = None
    )(implicit reader: ClientResponseReader[SingleCSVRecord], writer: RequestWriter[Option[SingleCSVRecord]]): Future[SingleCSVRecord] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincremental")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformincrementalCsv")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformincrementalCsv")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformincrementalCsv")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(SingleCSVRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformincrementalarray(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    SingleRecord: Option[SingleRecord] = None
    )(implicit reader: ClientResponseReader[Base64NDArrayBody], writer: RequestWriter[Option[SingleRecord]]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincrementalarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformincrementalarray")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformincrementalarray")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformincrementalarray")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(SingleRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformincrementalimage(DeploymentName: String,
    VersionName: String,
    ImageTransformName: String,
    File: File)(implicit reader: ClientResponseReader[Base64NDArrayBody]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformincrementalimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "imageTransformName" + "\\}", ImageTransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformincrementalimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformincrementalimage")

    if (ImageTransformName == null) throw new Exception("Missing required parameter 'ImageTransformName' when calling DefaultApi->transformincrementalimage")

    if (File == null) throw new Exception("Missing required parameter 'File' when calling DefaultApi->transformincrementalimage")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformprocessGet(DeploymentName: String,
    VersionName: String,
    TransformName: String)(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformprocessGet")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformprocessGet")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformprocessGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformprocessPost(`ContentType`: String,
    DeploymentName: String,
    VersionName: String,
    TransformName: String,
    TransformProcess: Option[String] = None
    )(implicit reader: ClientResponseReader[Any], writer: RequestWriter[Option[String]]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`ContentType` == null) throw new Exception("Missing required parameter '`ContentType`' when calling DefaultApi->transformprocessPost")

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformprocessPost")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformprocessPost")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformprocessPost")

    headerParams += "Content-Type" -> `ContentType`.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(TransformProcess))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateAuthPolicy(AuthPolicy: AuthPolicy)(implicit reader: ClientResponseReader[AuthPolicy], writer: RequestWriter[AuthPolicy]): Future[AuthPolicy] = {
    // create path and map variables
    val path = (addFmt("/auth/policy"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (AuthPolicy == null) throw new Exception("Missing required parameter 'AuthPolicy' when calling DefaultApi->updateAuthPolicy")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(AuthPolicy))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateBestModelForExperiment(ModelHistoryServerId: String,
    UpdateBestModel: UpdateBestModel)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[UpdateBestModel]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/best")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->updateBestModelForExperiment")

    if (UpdateBestModel == null) throw new Exception("Missing required parameter 'UpdateBestModel' when calling DefaultApi->updateBestModelForExperiment")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(UpdateBestModel))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateExperiment(ModelHistoryServerId: String,
    ExperimentID: String,
    ExperimentEntity: ExperimentEntity)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->updateExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling DefaultApi->updateExperiment")

    if (ExperimentEntity == null) throw new Exception("Missing required parameter 'ExperimentEntity' when calling DefaultApi->updateExperiment")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(ExperimentEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String,
    UpdateModelHistoryRequest: AddModelHistoryRequest)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[AddModelHistoryRequest]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->updateModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling DefaultApi->updateModelHistory")

    if (UpdateModelHistoryRequest == null) throw new Exception("Missing required parameter 'UpdateModelHistoryRequest' when calling DefaultApi->updateModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(UpdateModelHistoryRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUser(User: User)(implicit reader: ClientResponseReader[User], writer: RequestWriter[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (User == null) throw new Exception("Missing required parameter 'User' when calling DefaultApi->updateUser")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(User))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def upload(File: Option[File] = None
    )(implicit reader: ClientResponseReader[FileUploadList]): Future[FileUploadList] = {
    // create path and map variables
    val path = (addFmt("/api/upload/model"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
