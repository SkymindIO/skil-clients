/**
 * Endpoints
 * Endpoints API for different services in SKIL
 *
 * OpenAPI spec version: 1.2.0-beta
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ai.skymind.skil

import java.text.SimpleDateFormat

import ai.skymind.skil.model.AddExampleRequest
import ai.skymind.skil.model.AddModelHistoryRequest
import ai.skymind.skil.model.AggregatePrediction
import ai.skymind.skil.model.BestModel
import ai.skymind.skil.model.EvaluationResultsEntity
import ai.skymind.skil.model.ExampleEntity
import ai.skymind.skil.model.ExperimentEntity
import ai.skymind.skil.model.InlineResponse200
import ai.skymind.skil.model.MinibatchEntity
import ai.skymind.skil.model.ModelFeedBackRequest
import ai.skymind.skil.model.ModelHistoryEntity
import ai.skymind.skil.model.ModelInstanceEntity
import ai.skymind.skil.model.UpdateBestModel
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class ModelHistoryApi(
  val defBasePath: String = "http://localhost:9008",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new ModelHistoryApiAsyncHelper(client, config)

  /**
   * Adds an evaluation result
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param EvaluationResultsEntity The evaluation result entity 
   * @return EvaluationResultsEntity
   */
  def addEvaluationResult(ModelHistoryServerId: String, EvaluationResultsEntity: EvaluationResultsEntity): Option[EvaluationResultsEntity] = {
    val await = Try(Await.result(addEvaluationResultAsync(ModelHistoryServerId, EvaluationResultsEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an evaluation result asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param EvaluationResultsEntity The evaluation result entity 
   * @return Future(EvaluationResultsEntity)
   */
  def addEvaluationResultAsync(ModelHistoryServerId: String, EvaluationResultsEntity: EvaluationResultsEntity): Future[EvaluationResultsEntity] = {
      helper.addEvaluationResult(ModelHistoryServerId, EvaluationResultsEntity)
  }

  /**
   * Adds a number of examples to a minibatch ID given an AddExampleRequest.
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddExampleRequest The add example request, encapsulating minibatch details and examples batch size 
   * @return AddExampleRequest
   */
  def addExampleForBatch(ModelHistoryServerId: String, AddExampleRequest: AddExampleRequest): Option[AddExampleRequest] = {
    val await = Try(Await.result(addExampleForBatchAsync(ModelHistoryServerId, AddExampleRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a number of examples to a minibatch ID given an AddExampleRequest. asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddExampleRequest The add example request, encapsulating minibatch details and examples batch size 
   * @return Future(AddExampleRequest)
   */
  def addExampleForBatchAsync(ModelHistoryServerId: String, AddExampleRequest: AddExampleRequest): Future[AddExampleRequest] = {
      helper.addExampleForBatch(ModelHistoryServerId, AddExampleRequest)
  }

  /**
   * Adds an example to a minibatch
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExampleEntity The example to add to the minibatch 
   * @return ExampleEntity
   */
  def addExampleToMinibatch(ModelHistoryServerId: String, ExampleEntity: ExampleEntity): Option[ExampleEntity] = {
    val await = Try(Await.result(addExampleToMinibatchAsync(ModelHistoryServerId, ExampleEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an example to a minibatch asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExampleEntity The example to add to the minibatch 
   * @return Future(ExampleEntity)
   */
  def addExampleToMinibatchAsync(ModelHistoryServerId: String, ExampleEntity: ExampleEntity): Future[ExampleEntity] = {
      helper.addExampleToMinibatch(ModelHistoryServerId, ExampleEntity)
  }

  /**
   * Add an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentEntity The experiment entity to add 
   * @return ExperimentEntity
   */
  def addExperiment(ModelHistoryServerId: String, ExperimentEntity: ExperimentEntity): Option[ExperimentEntity] = {
    val await = Try(Await.result(addExperimentAsync(ModelHistoryServerId, ExperimentEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentEntity The experiment entity to add 
   * @return Future(ExperimentEntity)
   */
  def addExperimentAsync(ModelHistoryServerId: String, ExperimentEntity: ExperimentEntity): Future[ExperimentEntity] = {
      helper.addExperiment(ModelHistoryServerId, ExperimentEntity)
  }

  /**
   * Adds a minibatch
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchEntity The minibatch entity to add 
   * @return MinibatchEntity
   */
  def addMinibatch(ModelHistoryServerId: String, MinibatchEntity: MinibatchEntity): Option[MinibatchEntity] = {
    val await = Try(Await.result(addMinibatchAsync(ModelHistoryServerId, MinibatchEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a minibatch asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchEntity The minibatch entity to add 
   * @return Future(MinibatchEntity)
   */
  def addMinibatchAsync(ModelHistoryServerId: String, MinibatchEntity: MinibatchEntity): Future[MinibatchEntity] = {
      helper.addMinibatch(ModelHistoryServerId, MinibatchEntity)
  }

  /**
   * Adds an evaluation feedback to the model against a given minibatch id.
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelFeedBackRequest The model feedback request object 
   * @return ModelFeedBackRequest
   */
  def addModelFeedback(ModelHistoryServerId: String, ModelFeedBackRequest: ModelFeedBackRequest): Option[ModelFeedBackRequest] = {
    val await = Try(Await.result(addModelFeedbackAsync(ModelHistoryServerId, ModelFeedBackRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an evaluation feedback to the model against a given minibatch id. asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelFeedBackRequest The model feedback request object 
   * @return Future(ModelFeedBackRequest)
   */
  def addModelFeedbackAsync(ModelHistoryServerId: String, ModelFeedBackRequest: ModelFeedBackRequest): Future[ModelFeedBackRequest] = {
      helper.addModelFeedback(ModelHistoryServerId, ModelFeedBackRequest)
  }

  /**
   * Add a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddModelHistoryRequest The model history request object 
   * @return ModelHistoryEntity
   */
  def addModelHistory(ModelHistoryServerId: String, AddModelHistoryRequest: AddModelHistoryRequest): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(addModelHistoryAsync(ModelHistoryServerId, AddModelHistoryRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddModelHistoryRequest The model history request object 
   * @return Future(ModelHistoryEntity)
   */
  def addModelHistoryAsync(ModelHistoryServerId: String, AddModelHistoryRequest: AddModelHistoryRequest): Future[ModelHistoryEntity] = {
      helper.addModelHistory(ModelHistoryServerId, AddModelHistoryRequest)
  }

  /**
   * Adds a model
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceEntity The object encapsulating the model instance id and evaluation type to aggregate 
   * @return ModelInstanceEntity
   */
  def addModelInstance(ModelHistoryServerId: String, ModelInstanceEntity: ModelInstanceEntity): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(addModelInstanceAsync(ModelHistoryServerId, ModelInstanceEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a model asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceEntity The object encapsulating the model instance id and evaluation type to aggregate 
   * @return Future(ModelInstanceEntity)
   */
  def addModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceEntity: ModelInstanceEntity): Future[ModelInstanceEntity] = {
      helper.addModelInstance(ModelHistoryServerId, ModelInstanceEntity)
  }

  /**
   * Aggregates the evaluaition results of a model instance, based on the evaluation type
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AggregatePrediction The object encapsulating the model instance id and evaluation type to aggregate 
   * @return EvaluationResultsEntity
   */
  def aggregateModelResults(ModelHistoryServerId: String, AggregatePrediction: AggregatePrediction): Option[EvaluationResultsEntity] = {
    val await = Try(Await.result(aggregateModelResultsAsync(ModelHistoryServerId, AggregatePrediction), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Aggregates the evaluaition results of a model instance, based on the evaluation type asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AggregatePrediction The object encapsulating the model instance id and evaluation type to aggregate 
   * @return Future(EvaluationResultsEntity)
   */
  def aggregateModelResultsAsync(ModelHistoryServerId: String, AggregatePrediction: AggregatePrediction): Future[EvaluationResultsEntity] = {
      helper.aggregateModelResults(ModelHistoryServerId, AggregatePrediction)
  }

  /**
   * Creates model History
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryEntity The model history entity 
   * @return ModelHistoryEntity
   */
  def createModelHistory(ModelHistoryServerId: String, ModelHistoryEntity: ModelHistoryEntity): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(createModelHistoryAsync(ModelHistoryServerId, ModelHistoryEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Creates model History asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryEntity The model history entity 
   * @return Future(ModelHistoryEntity)
   */
  def createModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryEntity: ModelHistoryEntity): Future[ModelHistoryEntity] = {
      helper.createModelHistory(ModelHistoryServerId, ModelHistoryEntity)
  }

  /**
   * Deletes an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to delete 
   * @return InlineResponse200
   */
  def deleteExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deleteExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to delete 
   * @return Future(InlineResponse200)
   */
  def deleteExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[InlineResponse200] = {
      helper.deleteExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * Deletes a model history / workspace, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to delete 
   * @return InlineResponse200
   */
  def deleteModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deleteModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a model history / workspace, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to delete 
   * @return Future(InlineResponse200)
   */
  def deleteModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[InlineResponse200] = {
      helper.deleteModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Deletes a model instance, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to delete. 
   * @return void
   */
  def deleteModelInstance(ModelHistoryServerId: String, ModelInstanceID: String) = {
    val await = Try(Await.result(deleteModelInstanceAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a model instance, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to delete. 
   * @return Future(void)
   */
  def deleteModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceID: String) = {
      helper.deleteModelInstance(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Gets the best model among the given model instance IDs, based on the evaluation type and column metric
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param BestModel Object encapsulating the model ids, eval type and column metric name 
   * @return ModelInstanceEntity
   */
  def getBestModelAmongModelIds(ModelHistoryServerId: String, BestModel: BestModel): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(getBestModelAmongModelIdsAsync(ModelHistoryServerId, BestModel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the best model among the given model instance IDs, based on the evaluation type and column metric asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param BestModel Object encapsulating the model ids, eval type and column metric name 
   * @return Future(ModelInstanceEntity)
   */
  def getBestModelAmongModelIdsAsync(ModelHistoryServerId: String, BestModel: BestModel): Future[ModelInstanceEntity] = {
      helper.getBestModelAmongModelIds(ModelHistoryServerId, BestModel)
  }

  /**
   * Gets the list of evaluation results entity, given a model instance ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get evaluation results for. 
   * @return List[EvaluationResultsEntity]
   */
  def getEvaluationForModelID(ModelHistoryServerId: String, ModelInstanceID: String): Option[List[EvaluationResultsEntity]] = {
    val await = Try(Await.result(getEvaluationForModelIDAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the list of evaluation results entity, given a model instance ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get evaluation results for. 
   * @return Future(List[EvaluationResultsEntity])
   */
  def getEvaluationForModelIDAsync(ModelHistoryServerId: String, ModelInstanceID: String): Future[List[EvaluationResultsEntity]] = {
      helper.getEvaluationForModelID(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Gets all the examples for a minibatch ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return List[ExampleEntity]
   */
  def getExamplesForMinibatch(ModelHistoryServerId: String, MinibatchId: String): Option[List[ExampleEntity]] = {
    val await = Try(Await.result(getExamplesForMinibatchAsync(ModelHistoryServerId, MinibatchId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets all the examples for a minibatch ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return Future(List[ExampleEntity])
   */
  def getExamplesForMinibatchAsync(ModelHistoryServerId: String, MinibatchId: String): Future[List[ExampleEntity]] = {
      helper.getExamplesForMinibatch(ModelHistoryServerId, MinibatchId)
  }

  /**
   * Obtain an experiment&#39;s details, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to obtain 
   * @return ExperimentEntity
   */
  def getExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[ExperimentEntity] = {
    val await = Try(Await.result(getExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain an experiment&#39;s details, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to obtain 
   * @return Future(ExperimentEntity)
   */
  def getExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[ExperimentEntity] = {
      helper.getExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * Obtain all experiments for a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace 
   * @return ExperimentEntity
   */
  def getExperimentsForModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[ExperimentEntity] = {
    val await = Try(Await.result(getExperimentsForModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain all experiments for a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace 
   * @return Future(ExperimentEntity)
   */
  def getExperimentsForModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[ExperimentEntity] = {
      helper.getExperimentsForModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Gets a minibatch for the model
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return MinibatchEntity
   */
  def getMinibatch(ModelHistoryServerId: String, MinibatchId: String): Option[MinibatchEntity] = {
    val await = Try(Await.result(getMinibatchAsync(ModelHistoryServerId, MinibatchId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a minibatch for the model asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return Future(MinibatchEntity)
   */
  def getMinibatchAsync(ModelHistoryServerId: String, MinibatchId: String): Future[MinibatchEntity] = {
      helper.getMinibatch(ModelHistoryServerId, MinibatchId)
  }

  /**
   * Gets a model history, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID GUID of the model history to get information of. 
   * @return ModelHistoryEntity
   */
  def getModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(getModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a model history, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID GUID of the model history to get information of. 
   * @return Future(ModelHistoryEntity)
   */
  def getModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[ModelHistoryEntity] = {
      helper.getModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Gets a model instance, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get information of. 
   * @return ModelInstanceEntity
   */
  def getModelInstance(ModelHistoryServerId: String, ModelInstanceID: String): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(getModelInstanceAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a model instance, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get information of. 
   * @return Future(ModelInstanceEntity)
   */
  def getModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceID: String): Future[ModelInstanceEntity] = {
      helper.getModelInstance(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Obtain a list of all the models for an experiment
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment 
   * @return List[ModelInstanceEntity]
   */
  def getModelsForExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[List[ModelInstanceEntity]] = {
    val await = Try(Await.result(getModelsForExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain a list of all the models for an experiment asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment 
   * @return Future(List[ModelInstanceEntity])
   */
  def getModelsForExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[List[ModelInstanceEntity]] = {
      helper.getModelsForExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * List all of the experiments in every model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @return List[ExperimentEntity]
   */
  def listAllExperiments(ModelHistoryServerId: String): Option[List[ExperimentEntity]] = {
    val await = Try(Await.result(listAllExperimentsAsync(ModelHistoryServerId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List all of the experiments in every model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @return Future(List[ExperimentEntity])
   */
  def listAllExperimentsAsync(ModelHistoryServerId: String): Future[List[ExperimentEntity]] = {
      helper.listAllExperiments(ModelHistoryServerId)
  }

  /**
   * Updates the best model for an experiment
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param UpdateBestModel Model encapsulating the experiment id to update and the best model id. 
   * @return ExperimentEntity
   */
  def updateBestModelForExperiment(ModelHistoryServerId: String, UpdateBestModel: UpdateBestModel): Option[ExperimentEntity] = {
    val await = Try(Await.result(updateBestModelForExperimentAsync(ModelHistoryServerId, UpdateBestModel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates the best model for an experiment asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param UpdateBestModel Model encapsulating the experiment id to update and the best model id. 
   * @return Future(ExperimentEntity)
   */
  def updateBestModelForExperimentAsync(ModelHistoryServerId: String, UpdateBestModel: UpdateBestModel): Future[ExperimentEntity] = {
      helper.updateBestModelForExperiment(ModelHistoryServerId, UpdateBestModel)
  }

  /**
   * Updates an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to update 
   * @param ExperimentEntity The experiment entity to update with 
   * @return ExperimentEntity
   */
  def updateExperiment(ModelHistoryServerId: String, ExperimentID: String, ExperimentEntity: ExperimentEntity): Option[ExperimentEntity] = {
    val await = Try(Await.result(updateExperimentAsync(ModelHistoryServerId, ExperimentID, ExperimentEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to update 
   * @param ExperimentEntity The experiment entity to update with 
   * @return Future(ExperimentEntity)
   */
  def updateExperimentAsync(ModelHistoryServerId: String, ExperimentID: String, ExperimentEntity: ExperimentEntity): Future[ExperimentEntity] = {
      helper.updateExperiment(ModelHistoryServerId, ExperimentID, ExperimentEntity)
  }

  /**
   * Update a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to update 
   * @param UpdateModelHistoryRequest The model history request object 
   * @return ModelHistoryEntity
   */
  def updateModelHistory(ModelHistoryServerId: String, ModelHistoryID: String, UpdateModelHistoryRequest: AddModelHistoryRequest): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(updateModelHistoryAsync(ModelHistoryServerId, ModelHistoryID, UpdateModelHistoryRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to update 
   * @param UpdateModelHistoryRequest The model history request object 
   * @return Future(ModelHistoryEntity)
   */
  def updateModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String, UpdateModelHistoryRequest: AddModelHistoryRequest): Future[ModelHistoryEntity] = {
      helper.updateModelHistory(ModelHistoryServerId, ModelHistoryID, UpdateModelHistoryRequest)
  }

}

class ModelHistoryApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def addEvaluationResult(ModelHistoryServerId: String,
    EvaluationResultsEntity: EvaluationResultsEntity)(implicit reader: ClientResponseReader[EvaluationResultsEntity], writer: RequestWriter[EvaluationResultsEntity]): Future[EvaluationResultsEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions/evaluations/")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->addEvaluationResult")

    if (EvaluationResultsEntity == null) throw new Exception("Missing required parameter 'EvaluationResultsEntity' when calling ModelHistoryApi->addEvaluationResult")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(EvaluationResultsEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExampleForBatch(ModelHistoryServerId: String,
    AddExampleRequest: AddExampleRequest)(implicit reader: ClientResponseReader[AddExampleRequest], writer: RequestWriter[AddExampleRequest]): Future[AddExampleRequest] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/exampleForBatch")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->addExampleForBatch")

    if (AddExampleRequest == null) throw new Exception("Missing required parameter 'AddExampleRequest' when calling ModelHistoryApi->addExampleForBatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AddExampleRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExampleToMinibatch(ModelHistoryServerId: String,
    ExampleEntity: ExampleEntity)(implicit reader: ClientResponseReader[ExampleEntity], writer: RequestWriter[ExampleEntity]): Future[ExampleEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/example")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->addExampleToMinibatch")

    if (ExampleEntity == null) throw new Exception("Missing required parameter 'ExampleEntity' when calling ModelHistoryApi->addExampleToMinibatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ExampleEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExperiment(ModelHistoryServerId: String,
    ExperimentEntity: ExperimentEntity)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->addExperiment")

    if (ExperimentEntity == null) throw new Exception("Missing required parameter 'ExperimentEntity' when calling ModelHistoryApi->addExperiment")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ExperimentEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addMinibatch(ModelHistoryServerId: String,
    MinibatchEntity: MinibatchEntity)(implicit reader: ClientResponseReader[MinibatchEntity], writer: RequestWriter[MinibatchEntity]): Future[MinibatchEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/minibatch")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->addMinibatch")

    if (MinibatchEntity == null) throw new Exception("Missing required parameter 'MinibatchEntity' when calling ModelHistoryApi->addMinibatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(MinibatchEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelFeedback(ModelHistoryServerId: String,
    ModelFeedBackRequest: ModelFeedBackRequest)(implicit reader: ClientResponseReader[ModelFeedBackRequest], writer: RequestWriter[ModelFeedBackRequest]): Future[ModelFeedBackRequest] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/feedback")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->addModelFeedback")

    if (ModelFeedBackRequest == null) throw new Exception("Missing required parameter 'ModelFeedBackRequest' when calling ModelHistoryApi->addModelFeedback")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelFeedBackRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelHistory(ModelHistoryServerId: String,
    AddModelHistoryRequest: AddModelHistoryRequest)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[AddModelHistoryRequest]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->addModelHistory")

    if (AddModelHistoryRequest == null) throw new Exception("Missing required parameter 'AddModelHistoryRequest' when calling ModelHistoryApi->addModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AddModelHistoryRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelInstance(ModelHistoryServerId: String,
    ModelInstanceEntity: ModelInstanceEntity)(implicit reader: ClientResponseReader[ModelInstanceEntity], writer: RequestWriter[ModelInstanceEntity]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->addModelInstance")

    if (ModelInstanceEntity == null) throw new Exception("Missing required parameter 'ModelInstanceEntity' when calling ModelHistoryApi->addModelInstance")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelInstanceEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def aggregateModelResults(ModelHistoryServerId: String,
    AggregatePrediction: AggregatePrediction)(implicit reader: ClientResponseReader[EvaluationResultsEntity], writer: RequestWriter[AggregatePrediction]): Future[EvaluationResultsEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/aggregateresults")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->aggregateModelResults")

    if (AggregatePrediction == null) throw new Exception("Missing required parameter 'AggregatePrediction' when calling ModelHistoryApi->aggregateModelResults")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AggregatePrediction))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createModelHistory(ModelHistoryServerId: String,
    ModelHistoryEntity: ModelHistoryEntity)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[ModelHistoryEntity]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->createModelHistory")

    if (ModelHistoryEntity == null) throw new Exception("Missing required parameter 'ModelHistoryEntity' when calling ModelHistoryApi->createModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelHistoryEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->deleteExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling ModelHistoryApi->deleteExperiment")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->deleteModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling ModelHistoryApi->deleteModelHistory")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModelInstance(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->deleteModelInstance")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling ModelHistoryApi->deleteModelInstance")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getBestModelAmongModelIds(ModelHistoryServerId: String,
    BestModel: BestModel)(implicit reader: ClientResponseReader[ModelInstanceEntity], writer: RequestWriter[BestModel]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/best")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getBestModelAmongModelIds")

    if (BestModel == null) throw new Exception("Missing required parameter 'BestModel' when calling ModelHistoryApi->getBestModelAmongModelIds")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(BestModel))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEvaluationForModelID(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[List[EvaluationResultsEntity]]): Future[List[EvaluationResultsEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions/evaluations/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getEvaluationForModelID")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling ModelHistoryApi->getEvaluationForModelID")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExamplesForMinibatch(ModelHistoryServerId: String,
    MinibatchId: String)(implicit reader: ClientResponseReader[List[ExampleEntity]]): Future[List[ExampleEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/example/{minibatchId}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "minibatchId" + "\\}", MinibatchId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getExamplesForMinibatch")

    if (MinibatchId == null) throw new Exception("Missing required parameter 'MinibatchId' when calling ModelHistoryApi->getExamplesForMinibatch")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling ModelHistoryApi->getExperiment")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExperimentsForModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiments/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getExperimentsForModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling ModelHistoryApi->getExperimentsForModelHistory")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getMinibatch(ModelHistoryServerId: String,
    MinibatchId: String)(implicit reader: ClientResponseReader[MinibatchEntity]): Future[MinibatchEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/minibatch/{minibatchId}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "minibatchId" + "\\}", MinibatchId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getMinibatch")

    if (MinibatchId == null) throw new Exception("Missing required parameter 'MinibatchId' when calling ModelHistoryApi->getMinibatch")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[ModelHistoryEntity]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revision/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling ModelHistoryApi->getModelHistory")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelInstance(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[ModelInstanceEntity]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getModelInstance")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling ModelHistoryApi->getModelInstance")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelsForExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[List[ModelInstanceEntity]]): Future[List[ModelInstanceEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}/models")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->getModelsForExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling ModelHistoryApi->getModelsForExperiment")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listAllExperiments(ModelHistoryServerId: String)(implicit reader: ClientResponseReader[List[ExperimentEntity]]): Future[List[ExperimentEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiments")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->listAllExperiments")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateBestModelForExperiment(ModelHistoryServerId: String,
    UpdateBestModel: UpdateBestModel)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[UpdateBestModel]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/best")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->updateBestModelForExperiment")

    if (UpdateBestModel == null) throw new Exception("Missing required parameter 'UpdateBestModel' when calling ModelHistoryApi->updateBestModelForExperiment")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(UpdateBestModel))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateExperiment(ModelHistoryServerId: String,
    ExperimentID: String,
    ExperimentEntity: ExperimentEntity)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->updateExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling ModelHistoryApi->updateExperiment")

    if (ExperimentEntity == null) throw new Exception("Missing required parameter 'ExperimentEntity' when calling ModelHistoryApi->updateExperiment")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(ExperimentEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String,
    UpdateModelHistoryRequest: AddModelHistoryRequest)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[AddModelHistoryRequest]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling ModelHistoryApi->updateModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling ModelHistoryApi->updateModelHistory")

    if (UpdateModelHistoryRequest == null) throw new Exception("Missing required parameter 'UpdateModelHistoryRequest' when calling ModelHistoryApi->updateModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(UpdateModelHistoryRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
