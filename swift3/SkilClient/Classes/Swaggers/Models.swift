// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }

        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [AccumulatedResults]
        Decoders.addDecoder(clazz: [AccumulatedResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AccumulatedResults]> in
            return Decoders.decode(clazz: [AccumulatedResults].self, source: source)
        }

        // Decoder for AccumulatedResults
        Decoders.addDecoder(clazz: AccumulatedResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AccumulatedResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AccumulatedResults() : instance as! AccumulatedResults
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["accumulatedDataWithLabels"] as AnyObject?) {
                
                case let .success(value): _result.accumulatedDataWithLabels = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["accumulatedDataWithOutLabels"] as AnyObject?) {
                
                case let .success(value): _result.accumulatedDataWithOutLabels = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AccumulatedResults", actual: "\(source)"))
            }
        }
        // Decoder for [AddCredentialsRequest]
        Decoders.addDecoder(clazz: [AddCredentialsRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddCredentialsRequest]> in
            return Decoders.decode(clazz: [AddCredentialsRequest].self, source: source)
        }

        // Decoder for AddCredentialsRequest
        Decoders.addDecoder(clazz: AddCredentialsRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddCredentialsRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddCredentialsRequest() : instance as! AddCredentialsRequest
                switch Decoders.decodeOptional(clazz: AddCredentialsRequest.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): _result.uri = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddCredentialsRequest", actual: "\(source)"))
            }
        }
        // Decoder for [AddExampleRequest]
        Decoders.addDecoder(clazz: [AddExampleRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddExampleRequest]> in
            return Decoders.decode(clazz: [AddExampleRequest].self, source: source)
        }

        // Decoder for AddExampleRequest
        Decoders.addDecoder(clazz: AddExampleRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddExampleRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddExampleRequest() : instance as! AddExampleRequest
                switch Decoders.decodeOptional(clazz: MinibatchEntity.self, source: sourceDictionary["minibatch"] as AnyObject?) {
                
                case let .success(value): _result.minibatch = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["batchSize"] as AnyObject?) {
                
                case let .success(value): _result.batchSize = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddExampleRequest", actual: "\(source)"))
            }
        }
        // Decoder for [AddModelHistoryRequest]
        Decoders.addDecoder(clazz: [AddModelHistoryRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddModelHistoryRequest]> in
            return Decoders.decode(clazz: [AddModelHistoryRequest].self, source: source)
        }

        // Decoder for AddModelHistoryRequest
        Decoders.addDecoder(clazz: AddModelHistoryRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddModelHistoryRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddModelHistoryRequest() : instance as! AddModelHistoryRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelName"] as AnyObject?) {
                
                case let .success(value): _result.modelName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelLabels"] as AnyObject?) {
                
                case let .success(value): _result.modelLabels = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddModelHistoryRequest", actual: "\(source)"))
            }
        }
        // Decoder for [AddResourceRequest]
        Decoders.addDecoder(clazz: [AddResourceRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddResourceRequest]> in
            return Decoders.decode(clazz: [AddResourceRequest].self, source: source)
        }

        // Decoder for AddResourceRequest
        Decoders.addDecoder(clazz: AddResourceRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddResourceRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddResourceRequest() : instance as! AddResourceRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["resourceName"] as AnyObject?) {
                
                case let .success(value): _result.resourceName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["resourceDetails"] as AnyObject?) {
                
                case let .success(value): _result.resourceDetails = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["credentialUri"] as AnyObject?) {
                
                case let .success(value): _result.credentialUri = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AddResourceRequest.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AddResourceRequest.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["credentialId"] as AnyObject?) {
                
                case let .success(value): _result.credentialId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddResourceRequest", actual: "\(source)"))
            }
        }
        // Decoder for [AggregatePrediction]
        Decoders.addDecoder(clazz: [AggregatePrediction].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AggregatePrediction]> in
            return Decoders.decode(clazz: [AggregatePrediction].self, source: source)
        }

        // Decoder for AggregatePrediction
        Decoders.addDecoder(clazz: AggregatePrediction.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AggregatePrediction> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AggregatePrediction() : instance as! AggregatePrediction
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelId"] as AnyObject?) {
                
                case let .success(value): _result.modelId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AggregatePrediction.EvalType.self, source: sourceDictionary["evalType"] as AnyObject?) {
                
                case let .success(value): _result.evalType = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AggregatePrediction", actual: "\(source)"))
            }
        }
        // Decoder for [AuthPolicy]
        Decoders.addDecoder(clazz: [AuthPolicy].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AuthPolicy]> in
            return Decoders.decode(clazz: [AuthPolicy].self, source: source)
        }

        // Decoder for AuthPolicy
        Decoders.addDecoder(clazz: AuthPolicy.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AuthPolicy> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AuthPolicy() : instance as! AuthPolicy
                switch Decoders.decodeOptional(clazz: AuthPolicy.ModelClass.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AuthPolicy", actual: "\(source)"))
            }
        }
        // Decoder for [AzureStorageResourceDetails]
        Decoders.addDecoder(clazz: [AzureStorageResourceDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AzureStorageResourceDetails]> in
            return Decoders.decode(clazz: [AzureStorageResourceDetails].self, source: source)
        }

        // Decoder for AzureStorageResourceDetails
        Decoders.addDecoder(clazz: AzureStorageResourceDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AzureStorageResourceDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AzureStorageResourceDetails() : instance as! AzureStorageResourceDetails
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AzureStorageResourceDetails.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AzureStorageResourceDetails.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["containerName"] as AnyObject?) {
                
                case let .success(value): _result.containerName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AzureStorageResourceDetails", actual: "\(source)"))
            }
        }
        // Decoder for [Base64NDArrayBody]
        Decoders.addDecoder(clazz: [Base64NDArrayBody].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Base64NDArrayBody]> in
            return Decoders.decode(clazz: [Base64NDArrayBody].self, source: source)
        }

        // Decoder for Base64NDArrayBody
        Decoders.addDecoder(clazz: Base64NDArrayBody.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Base64NDArrayBody> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Base64NDArrayBody() : instance as! Base64NDArrayBody
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ndarray"] as AnyObject?) {
                
                case let .success(value): _result.ndarray = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Base64NDArrayBody", actual: "\(source)"))
            }
        }
        // Decoder for [Base64NDArrayBodyKNN]
        Decoders.addDecoder(clazz: [Base64NDArrayBodyKNN].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Base64NDArrayBodyKNN]> in
            return Decoders.decode(clazz: [Base64NDArrayBodyKNN].self, source: source)
        }

        // Decoder for Base64NDArrayBodyKNN
        Decoders.addDecoder(clazz: Base64NDArrayBodyKNN.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Base64NDArrayBodyKNN> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Base64NDArrayBodyKNN() : instance as! Base64NDArrayBodyKNN
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ndarray"] as AnyObject?) {
                
                case let .success(value): _result.ndarray = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["k"] as AnyObject?) {
                
                case let .success(value): _result.k = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["forceFillK"] as AnyObject?) {
                
                case let .success(value): _result.forceFillK = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Base64NDArrayBodyKNN", actual: "\(source)"))
            }
        }
        // Decoder for [BatchCSVRecord]
        Decoders.addDecoder(clazz: [BatchCSVRecord].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[BatchCSVRecord]> in
            return Decoders.decode(clazz: [BatchCSVRecord].self, source: source)
        }

        // Decoder for BatchCSVRecord
        Decoders.addDecoder(clazz: BatchCSVRecord.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BatchCSVRecord> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? BatchCSVRecord() : instance as! BatchCSVRecord
                switch Decoders.decodeOptional(clazz: [SingleCSVRecord].self, source: sourceDictionary["records"] as AnyObject?) {
                
                case let .success(value): _result.records = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "BatchCSVRecord", actual: "\(source)"))
            }
        }
        // Decoder for [BatchRecord]
        Decoders.addDecoder(clazz: [BatchRecord].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[BatchRecord]> in
            return Decoders.decode(clazz: [BatchRecord].self, source: source)
        }

        // Decoder for BatchRecord
        Decoders.addDecoder(clazz: BatchRecord.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BatchRecord> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? BatchRecord() : instance as! BatchRecord
                switch Decoders.decodeOptional(clazz: [SingleRecord].self, source: sourceDictionary["records"] as AnyObject?) {
                
                case let .success(value): _result.records = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "BatchRecord", actual: "\(source)"))
            }
        }
        // Decoder for [BestModel]
        Decoders.addDecoder(clazz: [BestModel].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[BestModel]> in
            return Decoders.decode(clazz: [BestModel].self, source: source)
        }

        // Decoder for BestModel
        Decoders.addDecoder(clazz: BestModel.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BestModel> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? BestModel() : instance as! BestModel
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["ids"] as AnyObject?) {
                
                case let .success(value): _result.ids = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: BestModel.ColumnNameMetric.self, source: sourceDictionary["columnNameMetric"] as AnyObject?) {
                
                case let .success(value): _result.columnNameMetric = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: BestModel.EvalType.self, source: sourceDictionary["evalType"] as AnyObject?) {
                
                case let .success(value): _result.evalType = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "BestModel", actual: "\(source)"))
            }
        }
        // Decoder for [ChangePasswordRequest]
        Decoders.addDecoder(clazz: [ChangePasswordRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChangePasswordRequest]> in
            return Decoders.decode(clazz: [ChangePasswordRequest].self, source: source)
        }

        // Decoder for ChangePasswordRequest
        Decoders.addDecoder(clazz: ChangePasswordRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChangePasswordRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChangePasswordRequest() : instance as! ChangePasswordRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): _result.password = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChangePasswordRequest", actual: "\(source)"))
            }
        }
        // Decoder for [ClassificationResult]
        Decoders.addDecoder(clazz: [ClassificationResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ClassificationResult]> in
            return Decoders.decode(clazz: [ClassificationResult].self, source: source)
        }

        // Decoder for ClassificationResult
        Decoders.addDecoder(clazz: ClassificationResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ClassificationResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ClassificationResult() : instance as! ClassificationResult
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Double].self, source: sourceDictionary["probabilities"] as AnyObject?) {
                
                case let .success(value): _result.probabilities = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["minibatchId"] as AnyObject?) {
                
                case let .success(value): _result.minibatchId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ClassificationResult", actual: "\(source)"))
            }
        }
        // Decoder for [CreateDeploymentRequest]
        Decoders.addDecoder(clazz: [CreateDeploymentRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CreateDeploymentRequest]> in
            return Decoders.decode(clazz: [CreateDeploymentRequest].self, source: source)
        }

        // Decoder for CreateDeploymentRequest
        Decoders.addDecoder(clazz: CreateDeploymentRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CreateDeploymentRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CreateDeploymentRequest() : instance as! CreateDeploymentRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CreateDeploymentRequest", actual: "\(source)"))
            }
        }
        // Decoder for [CreateJobRequest]
        Decoders.addDecoder(clazz: [CreateJobRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CreateJobRequest]> in
            return Decoders.decode(clazz: [CreateJobRequest].self, source: source)
        }

        // Decoder for CreateJobRequest
        Decoders.addDecoder(clazz: CreateJobRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CreateJobRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CreateJobRequest() : instance as! CreateJobRequest
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["computeResourceId"] as AnyObject?) {
                
                case let .success(value): _result.computeResourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["storageResourceId"] as AnyObject?) {
                
                case let .success(value): _result.storageResourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["jobArgs"] as AnyObject?) {
                
                case let .success(value): _result.jobArgs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outputFileName"] as AnyObject?) {
                
                case let .success(value): _result.outputFileName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CreateJobRequest", actual: "\(source)"))
            }
        }
        // Decoder for [DataProcResourceDetails]
        Decoders.addDecoder(clazz: [DataProcResourceDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DataProcResourceDetails]> in
            return Decoders.decode(clazz: [DataProcResourceDetails].self, source: source)
        }

        // Decoder for DataProcResourceDetails
        Decoders.addDecoder(clazz: DataProcResourceDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DataProcResourceDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DataProcResourceDetails() : instance as! DataProcResourceDetails
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DataProcResourceDetails.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DataProcResourceDetails.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["projectId"] as AnyObject?) {
                
                case let .success(value): _result.projectId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["region"] as AnyObject?) {
                
                case let .success(value): _result.region = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sparkClusterName"] as AnyObject?) {
                
                case let .success(value): _result.sparkClusterName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DataProcResourceDetails", actual: "\(source)"))
            }
        }
        // Decoder for [DeploymentObjects]
        Decoders.addDecoder(clazz: [DeploymentObjects].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DeploymentObjects]> in
            return Decoders.decode(clazz: [DeploymentObjects].self, source: source)
        }

        // Decoder for DeploymentObjects
        Decoders.addDecoder(clazz: DeploymentObjects.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DeploymentObjects> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DeploymentObjects() : instance as! DeploymentObjects
                switch Decoders.decodeOptional(clazz: [ModelResponse].self, source: sourceDictionary["models"] as AnyObject?) {
                
                case let .success(value): _result.models = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ModelResponse].self, source: sourceDictionary["transforms"] as AnyObject?) {
                
                case let .success(value): _result.transforms = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ModelResponse].self, source: sourceDictionary["knn"] as AnyObject?) {
                
                case let .success(value): _result.knn = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DeploymentObjects", actual: "\(source)"))
            }
        }
        // Decoder for [DeploymentResponse]
        Decoders.addDecoder(clazz: [DeploymentResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DeploymentResponse]> in
            return Decoders.decode(clazz: [DeploymentResponse].self, source: source)
        }

        // Decoder for DeploymentResponse
        Decoders.addDecoder(clazz: DeploymentResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DeploymentResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DeploymentResponse() : instance as! DeploymentResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["deploymentSlug"] as AnyObject?) {
                
                case let .success(value): _result.deploymentSlug = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DeploymentObjects.self, source: sourceDictionary["body"] as AnyObject?) {
                
                case let .success(value): _result.body = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DeploymentResponse", actual: "\(source)"))
            }
        }
        // Decoder for [DetectedObject]
        Decoders.addDecoder(clazz: [DetectedObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DetectedObject]> in
            return Decoders.decode(clazz: [DetectedObject].self, source: source)
        }

        // Decoder for DetectedObject
        Decoders.addDecoder(clazz: DetectedObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DetectedObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DetectedObject() : instance as! DetectedObject
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["centerX"] as AnyObject?) {
                
                case let .success(value): _result.centerX = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["centerY"] as AnyObject?) {
                
                case let .success(value): _result.centerY = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["width"] as AnyObject?) {
                
                case let .success(value): _result.width = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["height"] as AnyObject?) {
                
                case let .success(value): _result.height = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["predictedClasses"] as AnyObject?) {
                
                case let .success(value): _result.predictedClasses = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Float].self, source: sourceDictionary["confidences"] as AnyObject?) {
                
                case let .success(value): _result.confidences = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DetectedObject", actual: "\(source)"))
            }
        }
        // Decoder for [DetectionResult]
        Decoders.addDecoder(clazz: [DetectionResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DetectionResult]> in
            return Decoders.decode(clazz: [DetectionResult].self, source: source)
        }

        // Decoder for DetectionResult
        Decoders.addDecoder(clazz: DetectionResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DetectionResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DetectionResult() : instance as! DetectionResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [DetectedObject].self, source: sourceDictionary["objects"] as AnyObject?) {
                
                case let .success(value): _result.objects = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DetectionResult", actual: "\(source)"))
            }
        }
        // Decoder for [DownloadOutputFileRequest]
        Decoders.addDecoder(clazz: [DownloadOutputFileRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DownloadOutputFileRequest]> in
            return Decoders.decode(clazz: [DownloadOutputFileRequest].self, source: source)
        }

        // Decoder for DownloadOutputFileRequest
        Decoders.addDecoder(clazz: DownloadOutputFileRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DownloadOutputFileRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DownloadOutputFileRequest() : instance as! DownloadOutputFileRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["localDownloadPath"] as AnyObject?) {
                
                case let .success(value): _result.localDownloadPath = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DownloadOutputFileRequest", actual: "\(source)"))
            }
        }
        // Decoder for [EMRResourceDetails]
        Decoders.addDecoder(clazz: [EMRResourceDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EMRResourceDetails]> in
            return Decoders.decode(clazz: [EMRResourceDetails].self, source: source)
        }

        // Decoder for EMRResourceDetails
        Decoders.addDecoder(clazz: EMRResourceDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EMRResourceDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EMRResourceDetails() : instance as! EMRResourceDetails
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: EMRResourceDetails.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: EMRResourceDetails.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["clusterId"] as AnyObject?) {
                
                case let .success(value): _result.clusterId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["region"] as AnyObject?) {
                
                case let .success(value): _result.region = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EMRResourceDetails", actual: "\(source)"))
            }
        }
        // Decoder for [EvaluationResultsEntity]
        Decoders.addDecoder(clazz: [EvaluationResultsEntity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EvaluationResultsEntity]> in
            return Decoders.decode(clazz: [EvaluationResultsEntity].self, source: source)
        }

        // Decoder for EvaluationResultsEntity
        Decoders.addDecoder(clazz: EvaluationResultsEntity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EvaluationResultsEntity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EvaluationResultsEntity() : instance as! EvaluationResultsEntity
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["evaluation"] as AnyObject?) {
                
                case let .success(value): _result.evaluation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["evalName"] as AnyObject?) {
                
                case let .success(value): _result.evalName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelInstanceId"] as AnyObject?) {
                
                case let .success(value): _result.modelInstanceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["f1"] as AnyObject?) {
                
                case let .success(value): _result.f1 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["precision"] as AnyObject?) {
                
                case let .success(value): _result.precision = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["recall"] as AnyObject?) {
                
                case let .success(value): _result.recall = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["accuracy"] as AnyObject?) {
                
                case let .success(value): _result.accuracy = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["rmse"] as AnyObject?) {
                
                case let .success(value): _result.rmse = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["auc"] as AnyObject?) {
                
                case let .success(value): _result.auc = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["meanAbsoluteError"] as AnyObject?) {
                
                case let .success(value): _result.meanAbsoluteError = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["meanRelativeError"] as AnyObject?) {
                
                case let .success(value): _result.meanRelativeError = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["r2"] as AnyObject?) {
                
                case let .success(value): _result.r2 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["evalId"] as AnyObject?) {
                
                case let .success(value): _result.evalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["evalVersion"] as AnyObject?) {
                
                case let .success(value): _result.evalVersion = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["binaryThreshold"] as AnyObject?) {
                
                case let .success(value): _result.binaryThreshold = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["binaryThresholds"] as AnyObject?) {
                
                case let .success(value): _result.binaryThresholds = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EvaluationResultsEntity", actual: "\(source)"))
            }
        }
        // Decoder for [ExampleEntity]
        Decoders.addDecoder(clazz: [ExampleEntity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExampleEntity]> in
            return Decoders.decode(clazz: [ExampleEntity].self, source: source)
        }

        // Decoder for ExampleEntity
        Decoders.addDecoder(clazz: ExampleEntity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExampleEntity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExampleEntity() : instance as! ExampleEntity
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["exampleId"] as AnyObject?) {
                
                case let .success(value): _result.exampleId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["exampleVersion"] as AnyObject?) {
                
                case let .success(value): _result.exampleVersion = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["rowNumber"] as AnyObject?) {
                
                case let .success(value): _result.rowNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["miniBatchId"] as AnyObject?) {
                
                case let .success(value): _result.miniBatchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["miniBatchVersion"] as AnyObject?) {
                
                case let .success(value): _result.miniBatchVersion = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExampleEntity", actual: "\(source)"))
            }
        }
        // Decoder for [ExperimentEntity]
        Decoders.addDecoder(clazz: [ExperimentEntity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExperimentEntity]> in
            return Decoders.decode(clazz: [ExperimentEntity].self, source: source)
        }

        // Decoder for ExperimentEntity
        Decoders.addDecoder(clazz: ExperimentEntity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExperimentEntity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExperimentEntity() : instance as! ExperimentEntity
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bestModelId"] as AnyObject?) {
                
                case let .success(value): _result.bestModelId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["inputDataUri"] as AnyObject?) {
                
                case let .success(value): _result.inputDataUri = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["experimentId"] as AnyObject?) {
                
                case let .success(value): _result.experimentId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["experimentName"] as AnyObject?) {
                
                case let .success(value): _result.experimentName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["experimentDescription"] as AnyObject?) {
                
                case let .success(value): _result.experimentDescription = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notebookJson"] as AnyObject?) {
                
                case let .success(value): _result.notebookJson = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notebookUrl"] as AnyObject?) {
                
                case let .success(value): _result.notebookUrl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zeppelinId"] as AnyObject?) {
                
                case let .success(value): _result.zeppelinId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelHistoryId"] as AnyObject?) {
                
                case let .success(value): _result.modelHistoryId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["lastUpdated"] as AnyObject?) {
                
                case let .success(value): _result.lastUpdated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExperimentEntity", actual: "\(source)"))
            }
        }
        // Decoder for [FeedbackResponse]
        Decoders.addDecoder(clazz: [FeedbackResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FeedbackResponse]> in
            return Decoders.decode(clazz: [FeedbackResponse].self, source: source)
        }

        // Decoder for FeedbackResponse
        Decoders.addDecoder(clazz: FeedbackResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FeedbackResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FeedbackResponse() : instance as! FeedbackResponse
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["retrainThreshold"] as AnyObject?) {
                
                case let .success(value): _result.retrainThreshold = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["accumulatedSoFar"] as AnyObject?) {
                
                case let .success(value): _result.accumulatedSoFar = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FeedbackResponse", actual: "\(source)"))
            }
        }
        // Decoder for [FileUpload]
        Decoders.addDecoder(clazz: [FileUpload].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FileUpload]> in
            return Decoders.decode(clazz: [FileUpload].self, source: source)
        }

        // Decoder for FileUpload
        Decoders.addDecoder(clazz: FileUpload.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FileUpload> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FileUpload() : instance as! FileUpload
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["key"] as AnyObject?) {
                
                case let .success(value): _result.key = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fileName"] as AnyObject?) {
                
                case let .success(value): _result.fileName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["path"] as AnyObject?) {
                
                case let .success(value): _result.path = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fileContent"] as AnyObject?) {
                
                case let .success(value): _result.fileContent = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FileUpload", actual: "\(source)"))
            }
        }
        // Decoder for [FileUploadList]
        Decoders.addDecoder(clazz: [FileUploadList].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FileUploadList]> in
            return Decoders.decode(clazz: [FileUploadList].self, source: source)
        }

        // Decoder for FileUploadList
        Decoders.addDecoder(clazz: FileUploadList.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FileUploadList> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FileUploadList() : instance as! FileUploadList
                switch Decoders.decodeOptional(clazz: [FileUpload].self, source: sourceDictionary["fileUploadResponseList"] as AnyObject?) {
                
                case let .success(value): _result.fileUploadResponseList = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FileUploadList", actual: "\(source)"))
            }
        }
        // Decoder for [GoogleStorageResourceDetails]
        Decoders.addDecoder(clazz: [GoogleStorageResourceDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GoogleStorageResourceDetails]> in
            return Decoders.decode(clazz: [GoogleStorageResourceDetails].self, source: source)
        }

        // Decoder for GoogleStorageResourceDetails
        Decoders.addDecoder(clazz: GoogleStorageResourceDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GoogleStorageResourceDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GoogleStorageResourceDetails() : instance as! GoogleStorageResourceDetails
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GoogleStorageResourceDetails.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GoogleStorageResourceDetails.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["projectId"] as AnyObject?) {
                
                case let .success(value): _result.projectId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bucketName"] as AnyObject?) {
                
                case let .success(value): _result.bucketName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GoogleStorageResourceDetails", actual: "\(source)"))
            }
        }
        // Decoder for [HDFSResourceDetails]
        Decoders.addDecoder(clazz: [HDFSResourceDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HDFSResourceDetails]> in
            return Decoders.decode(clazz: [HDFSResourceDetails].self, source: source)
        }

        // Decoder for HDFSResourceDetails
        Decoders.addDecoder(clazz: HDFSResourceDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HDFSResourceDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HDFSResourceDetails() : instance as! HDFSResourceDetails
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: HDFSResourceDetails.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: HDFSResourceDetails.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["nameNodeHost"] as AnyObject?) {
                
                case let .success(value): _result.nameNodeHost = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["nameNodePort"] as AnyObject?) {
                
                case let .success(value): _result.nameNodePort = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HDFSResourceDetails", actual: "\(source)"))
            }
        }
        // Decoder for [HDInsightResourceDetails]
        Decoders.addDecoder(clazz: [HDInsightResourceDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HDInsightResourceDetails]> in
            return Decoders.decode(clazz: [HDInsightResourceDetails].self, source: source)
        }

        // Decoder for HDInsightResourceDetails
        Decoders.addDecoder(clazz: HDInsightResourceDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HDInsightResourceDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HDInsightResourceDetails() : instance as! HDInsightResourceDetails
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: HDInsightResourceDetails.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: HDInsightResourceDetails.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subscriptionId"] as AnyObject?) {
                
                case let .success(value): _result.subscriptionId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["resourceGroupName"] as AnyObject?) {
                
                case let .success(value): _result.resourceGroupName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["clusterName"] as AnyObject?) {
                
                case let .success(value): _result.clusterName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HDInsightResourceDetails", actual: "\(source)"))
            }
        }
        // Decoder for [INDArray]
        Decoders.addDecoder(clazz: [INDArray].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[INDArray]> in
            return Decoders.decode(clazz: [INDArray].self, source: source)
        }

        // Decoder for INDArray
        Decoders.addDecoder(clazz: INDArray.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<INDArray> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? INDArray() : instance as! INDArray
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["array"] as AnyObject?) {
                
                case let .success(value): _result.array = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["shape"] as AnyObject?) {
                
                case let .success(value): _result.shape = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: INDArray.Ordering.self, source: sourceDictionary["ordering"] as AnyObject?) {
                
                case let .success(value): _result.ordering = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Float].self, source: sourceDictionary["data"] as AnyObject?) {
                
                case let .success(value): _result.data = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: INDArray.DataType.self, source: sourceDictionary["dataType"] as AnyObject?) {
                
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "INDArray", actual: "\(source)"))
            }
        }
        // Decoder for [ImageTransformProcess]
        Decoders.addDecoder(clazz: [ImageTransformProcess].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ImageTransformProcess]> in
            return Decoders.decode(clazz: [ImageTransformProcess].self, source: source)
        }

        // Decoder for ImageTransformProcess
        Decoders.addDecoder(clazz: ImageTransformProcess.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ImageTransformProcess> in
            if let source = source as? ImageTransformProcess {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias ImageTransformProcess", actual: "\(source)"))
            }
        }
        // Decoder for [ImportModelRequest]
        Decoders.addDecoder(clazz: [ImportModelRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ImportModelRequest]> in
            return Decoders.decode(clazz: [ImportModelRequest].self, source: source)
        }

        // Decoder for ImportModelRequest
        Decoders.addDecoder(clazz: ImportModelRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ImportModelRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ImportModelRequest() : instance as! ImportModelRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["scale"] as AnyObject?) {
                
                case let .success(value): _result.scale = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): _result.uri = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelType"] as AnyObject?) {
                
                case let .success(value): _result.modelType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fileLocation"] as AnyObject?) {
                
                case let .success(value): _result.fileLocation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["jvmArgs"] as AnyObject?) {
                
                case let .success(value): _result.jvmArgs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["labelsFileLocation"] as AnyObject?) {
                
                case let .success(value): _result.labelsFileLocation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["extraArgs"] as AnyObject?) {
                
                case let .success(value): _result.extraArgs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["etlJson"] as AnyObject?) {
                
                case let .success(value): _result.etlJson = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["inputNames"] as AnyObject?) {
                
                case let .success(value): _result.inputNames = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["outputNames"] as AnyObject?) {
                
                case let .success(value): _result.outputNames = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ImportModelRequest", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse200]
        Decoders.addDecoder(clazz: [InlineResponse200].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse200]> in
            return Decoders.decode(clazz: [InlineResponse200].self, source: source)
        }

        // Decoder for InlineResponse200
        Decoders.addDecoder(clazz: InlineResponse200.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse200> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse200() : instance as! InlineResponse200
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse200", actual: "\(source)"))
            }
        }
        // Decoder for [JobEntity]
        Decoders.addDecoder(clazz: [JobEntity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[JobEntity]> in
            return Decoders.decode(clazz: [JobEntity].self, source: source)
        }

        // Decoder for JobEntity
        Decoders.addDecoder(clazz: JobEntity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<JobEntity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? JobEntity() : instance as! JobEntity
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["jobId"] as AnyObject?) {
                
                case let .success(value): _result.jobId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: JobEntity.JobType.self, source: sourceDictionary["jobType"] as AnyObject?) {
                
                case let .success(value): _result.jobType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["computeResourceId"] as AnyObject?) {
                
                case let .success(value): _result.computeResourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["storageResourceId"] as AnyObject?) {
                
                case let .success(value): _result.storageResourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["jobArgs"] as AnyObject?) {
                
                case let .success(value): _result.jobArgs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["runId"] as AnyObject?) {
                
                case let .success(value): _result.runId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: JobEntity.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outputFileName"] as AnyObject?) {
                
                case let .success(value): _result.outputFileName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "JobEntity", actual: "\(source)"))
            }
        }
        // Decoder for [JsonArrayResponse]
        Decoders.addDecoder(clazz: [JsonArrayResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[JsonArrayResponse]> in
            return Decoders.decode(clazz: [JsonArrayResponse].self, source: source)
        }

        // Decoder for JsonArrayResponse
        Decoders.addDecoder(clazz: JsonArrayResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<JsonArrayResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? JsonArrayResponse() : instance as! JsonArrayResponse
                switch Decoders.decodeOptional(clazz: INDArray.self, source: sourceDictionary["array"] as AnyObject?) {
                
                case let .success(value): _result.array = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "JsonArrayResponse", actual: "\(source)"))
            }
        }
        // Decoder for [LogBatch]
        Decoders.addDecoder(clazz: [LogBatch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LogBatch]> in
            return Decoders.decode(clazz: [LogBatch].self, source: source)
        }

        // Decoder for LogBatch
        Decoders.addDecoder(clazz: LogBatch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LogBatch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LogBatch() : instance as! LogBatch
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["offset"] as AnyObject?) {
                
                case let .success(value): _result.offset = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["rowCount"] as AnyObject?) {
                
                case let .success(value): _result.rowCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["logs"] as AnyObject?) {
                
                case let .success(value): _result.logs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LogBatch", actual: "\(source)"))
            }
        }
        // Decoder for [LogRequest]
        Decoders.addDecoder(clazz: [LogRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LogRequest]> in
            return Decoders.decode(clazz: [LogRequest].self, source: source)
        }

        // Decoder for LogRequest
        Decoders.addDecoder(clazz: LogRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LogRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LogRequest() : instance as! LogRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["offset"] as AnyObject?) {
                
                case let .success(value): _result.offset = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["rowCount"] as AnyObject?) {
                
                case let .success(value): _result.rowCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["head"] as AnyObject?) {
                
                case let .success(value): _result.head = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LogRequest", actual: "\(source)"))
            }
        }
        // Decoder for [LoginRequest]
        Decoders.addDecoder(clazz: [LoginRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LoginRequest]> in
            return Decoders.decode(clazz: [LoginRequest].self, source: source)
        }

        // Decoder for LoginRequest
        Decoders.addDecoder(clazz: LoginRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LoginRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LoginRequest() : instance as! LoginRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["userId"] as AnyObject?) {
                
                case let .success(value): _result.userId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): _result.password = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LoginRequest", actual: "\(source)"))
            }
        }
        // Decoder for [LoginResponse]
        Decoders.addDecoder(clazz: [LoginResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LoginResponse]> in
            return Decoders.decode(clazz: [LoginResponse].self, source: source)
        }

        // Decoder for LoginResponse
        Decoders.addDecoder(clazz: LoginResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LoginResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LoginResponse() : instance as! LoginResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): _result.token = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LoginResponse", actual: "\(source)"))
            }
        }
        // Decoder for [MetaData]
        Decoders.addDecoder(clazz: [MetaData].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MetaData]> in
            return Decoders.decode(clazz: [MetaData].self, source: source)
        }

        // Decoder for MetaData
        Decoders.addDecoder(clazz: MetaData.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MetaData> in
            if let source = source as? MetaData {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias MetaData", actual: "\(source)"))
            }
        }
        // Decoder for [MinibatchEntity]
        Decoders.addDecoder(clazz: [MinibatchEntity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MinibatchEntity]> in
            return Decoders.decode(clazz: [MinibatchEntity].self, source: source)
        }

        // Decoder for MinibatchEntity
        Decoders.addDecoder(clazz: MinibatchEntity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MinibatchEntity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MinibatchEntity() : instance as! MinibatchEntity
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["miniBatchId"] as AnyObject?) {
                
                case let .success(value): _result.miniBatchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["evalId"] as AnyObject?) {
                
                case let .success(value): _result.evalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["evalVersion"] as AnyObject?) {
                
                case let .success(value): _result.evalVersion = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["batchVersion"] as AnyObject?) {
                
                case let .success(value): _result.batchVersion = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MinibatchEntity", actual: "\(source)"))
            }
        }
        // Decoder for [ModelEntity]
        Decoders.addDecoder(clazz: [ModelEntity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModelEntity]> in
            return Decoders.decode(clazz: [ModelEntity].self, source: source)
        }

        // Decoder for ModelEntity
        Decoders.addDecoder(clazz: ModelEntity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModelEntity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModelEntity() : instance as! ModelEntity
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ModelEntity.ModelType.self, source: sourceDictionary["modelType"] as AnyObject?) {
                
                case let .success(value): _result.modelType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["deploymentId"] as AnyObject?) {
                
                case let .success(value): _result.deploymentId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["scale"] as AnyObject?) {
                
                case let .success(value): _result.scale = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fileLocation"] as AnyObject?) {
                
                case let .success(value): _result.fileLocation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ModelEntity.State.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["jvmArgs"] as AnyObject?) {
                
                case let .success(value): _result.jvmArgs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["labelsFileLocation"] as AnyObject?) {
                
                case let .success(value): _result.labelsFileLocation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["extraArgs"] as AnyObject?) {
                
                case let .success(value): _result.extraArgs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["launchPolicy"] as AnyObject?) {
                
                case let .success(value): _result.launchPolicy = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ModelEntity.ModelState.self, source: sourceDictionary["modelState"] as AnyObject?) {
                
                case let .success(value): _result.modelState = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModelEntity", actual: "\(source)"))
            }
        }
        // Decoder for [ModelFeedBackRequest]
        Decoders.addDecoder(clazz: [ModelFeedBackRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModelFeedBackRequest]> in
            return Decoders.decode(clazz: [ModelFeedBackRequest].self, source: source)
        }

        // Decoder for ModelFeedBackRequest
        Decoders.addDecoder(clazz: ModelFeedBackRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModelFeedBackRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModelFeedBackRequest() : instance as! ModelFeedBackRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["batchId"] as AnyObject?) {
                
                case let .success(value): _result.batchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["guesses"] as AnyObject?) {
                
                case let .success(value): _result.guesses = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["correct"] as AnyObject?) {
                
                case let .success(value): _result.correct = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModelFeedBackRequest", actual: "\(source)"))
            }
        }
        // Decoder for [ModelHistoryEntity]
        Decoders.addDecoder(clazz: [ModelHistoryEntity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModelHistoryEntity]> in
            return Decoders.decode(clazz: [ModelHistoryEntity].self, source: source)
        }

        // Decoder for ModelHistoryEntity
        Decoders.addDecoder(clazz: ModelHistoryEntity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModelHistoryEntity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModelHistoryEntity() : instance as! ModelHistoryEntity
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelHistoryId"] as AnyObject?) {
                
                case let .success(value): _result.modelHistoryId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelName"] as AnyObject?) {
                
                case let .success(value): _result.modelName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelLabels"] as AnyObject?) {
                
                case let .success(value): _result.modelLabels = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModelHistoryEntity", actual: "\(source)"))
            }
        }
        // Decoder for [ModelInstanceEntity]
        Decoders.addDecoder(clazz: [ModelInstanceEntity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModelInstanceEntity]> in
            return Decoders.decode(clazz: [ModelInstanceEntity].self, source: source)
        }

        // Decoder for ModelInstanceEntity
        Decoders.addDecoder(clazz: ModelInstanceEntity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModelInstanceEntity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModelInstanceEntity() : instance as! ModelInstanceEntity
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): _result.uri = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["etlJson"] as AnyObject?) {
                
                case let .success(value): _result.etlJson = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelId"] as AnyObject?) {
                
                case let .success(value): _result.modelId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelLabels"] as AnyObject?) {
                
                case let .success(value): _result.modelLabels = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["inputFormats"] as AnyObject?) {
                
                case let .success(value): _result.inputFormats = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notebookJson"] as AnyObject?) {
                
                case let .success(value): _result.notebookJson = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["evalId"] as AnyObject?) {
                
                case let .success(value): _result.evalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelName"] as AnyObject?) {
                
                case let .success(value): _result.modelName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["originalModelId"] as AnyObject?) {
                
                case let .success(value): _result.originalModelId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modelVersion"] as AnyObject?) {
                
                case let .success(value): _result.modelVersion = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["experimentId"] as AnyObject?) {
                
                case let .success(value): _result.experimentId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModelInstanceEntity", actual: "\(source)"))
            }
        }
        // Decoder for [ModelResponse]
        Decoders.addDecoder(clazz: [ModelResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModelResponse]> in
            return Decoders.decode(clazz: [ModelResponse].self, source: source)
        }

        // Decoder for ModelResponse
        Decoders.addDecoder(clazz: ModelResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModelResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModelResponse() : instance as! ModelResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["scale"] as AnyObject?) {
                
                case let .success(value): _result.scale = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): _result.uri = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModelResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ModelStatus]
        Decoders.addDecoder(clazz: [ModelStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModelStatus]> in
            return Decoders.decode(clazz: [ModelStatus].self, source: source)
        }

        // Decoder for ModelStatus
        Decoders.addDecoder(clazz: ModelStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModelStatus> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModelStatus() : instance as! ModelStatus
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModelStatus", actual: "\(source)"))
            }
        }
        // Decoder for [MultiClassClassificationResult]
        Decoders.addDecoder(clazz: [MultiClassClassificationResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MultiClassClassificationResult]> in
            return Decoders.decode(clazz: [MultiClassClassificationResult].self, source: source)
        }

        // Decoder for MultiClassClassificationResult
        Decoders.addDecoder(clazz: MultiClassClassificationResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MultiClassClassificationResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MultiClassClassificationResult() : instance as! MultiClassClassificationResult
                switch Decoders.decodeOptional(clazz: [[String]].self, source: sourceDictionary["rankedOutcomes"] as AnyObject?) {
                
                case let .success(value): _result.rankedOutcomes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["maxOutcomes"] as AnyObject?) {
                
                case let .success(value): _result.maxOutcomes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [[Double]].self, source: sourceDictionary["probabilities"] as AnyObject?) {
                
                case let .success(value): _result.probabilities = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MultiClassClassificationResult", actual: "\(source)"))
            }
        }
        // Decoder for [MultiPredictRequest]
        Decoders.addDecoder(clazz: [MultiPredictRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MultiPredictRequest]> in
            return Decoders.decode(clazz: [MultiPredictRequest].self, source: source)
        }

        // Decoder for MultiPredictRequest
        Decoders.addDecoder(clazz: MultiPredictRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MultiPredictRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MultiPredictRequest() : instance as! MultiPredictRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["needsPreProcessing"] as AnyObject?) {
                
                case let .success(value): _result.needsPreProcessing = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [INDArray].self, source: sourceDictionary["inputs"] as AnyObject?) {
                
                case let .success(value): _result.inputs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [INDArray].self, source: sourceDictionary["inputMasks"] as AnyObject?) {
                
                case let .success(value): _result.inputMasks = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MultiPredictRequest", actual: "\(source)"))
            }
        }
        // Decoder for [MultiPredictResponse]
        Decoders.addDecoder(clazz: [MultiPredictResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MultiPredictResponse]> in
            return Decoders.decode(clazz: [MultiPredictResponse].self, source: source)
        }

        // Decoder for MultiPredictResponse
        Decoders.addDecoder(clazz: MultiPredictResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MultiPredictResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MultiPredictResponse() : instance as! MultiPredictResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["needsPreProcessing"] as AnyObject?) {
                
                case let .success(value): _result.needsPreProcessing = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [INDArray].self, source: sourceDictionary["outputs"] as AnyObject?) {
                
                case let .success(value): _result.outputs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MultiPredictResponse", actual: "\(source)"))
            }
        }
        // Decoder for [NearestNeighborRequest]
        Decoders.addDecoder(clazz: [NearestNeighborRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[NearestNeighborRequest]> in
            return Decoders.decode(clazz: [NearestNeighborRequest].self, source: source)
        }

        // Decoder for NearestNeighborRequest
        Decoders.addDecoder(clazz: NearestNeighborRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NearestNeighborRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? NearestNeighborRequest() : instance as! NearestNeighborRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["k"] as AnyObject?) {
                
                case let .success(value): _result.k = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["inputIndex"] as AnyObject?) {
                
                case let .success(value): _result.inputIndex = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "NearestNeighborRequest", actual: "\(source)"))
            }
        }
        // Decoder for [NearestNeighborsResult]
        Decoders.addDecoder(clazz: [NearestNeighborsResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[NearestNeighborsResult]> in
            return Decoders.decode(clazz: [NearestNeighborsResult].self, source: source)
        }

        // Decoder for NearestNeighborsResult
        Decoders.addDecoder(clazz: NearestNeighborsResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NearestNeighborsResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? NearestNeighborsResult() : instance as! NearestNeighborsResult
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["index"] as AnyObject?) {
                
                case let .success(value): _result.index = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["distance"] as AnyObject?) {
                
                case let .success(value): _result.distance = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["label"] as AnyObject?) {
                
                case let .success(value): _result.label = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "NearestNeighborsResult", actual: "\(source)"))
            }
        }
        // Decoder for [NearestNeighborsResults]
        Decoders.addDecoder(clazz: [NearestNeighborsResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[NearestNeighborsResults]> in
            return Decoders.decode(clazz: [NearestNeighborsResults].self, source: source)
        }

        // Decoder for NearestNeighborsResults
        Decoders.addDecoder(clazz: NearestNeighborsResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NearestNeighborsResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? NearestNeighborsResults() : instance as! NearestNeighborsResults
                switch Decoders.decodeOptional(clazz: [NearestNeighborsResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "NearestNeighborsResults", actual: "\(source)"))
            }
        }
        // Decoder for [NewDeployment]
        Decoders.addDecoder(clazz: [NewDeployment].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[NewDeployment]> in
            return Decoders.decode(clazz: [NewDeployment].self, source: source)
        }

        // Decoder for NewDeployment
        Decoders.addDecoder(clazz: NewDeployment.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NewDeployment> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? NewDeployment() : instance as! NewDeployment
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "NewDeployment", actual: "\(source)"))
            }
        }
        // Decoder for [Prediction]
        Decoders.addDecoder(clazz: [Prediction].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Prediction]> in
            return Decoders.decode(clazz: [Prediction].self, source: source)
        }

        // Decoder for Prediction
        Decoders.addDecoder(clazz: Prediction.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Prediction> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Prediction() : instance as! Prediction
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["needsPreProcessing"] as AnyObject?) {
                
                case let .success(value): _result.needsPreProcessing = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: INDArray.self, source: sourceDictionary["prediction"] as AnyObject?) {
                
                case let .success(value): _result.prediction = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: INDArray.self, source: sourceDictionary["inputMask"] as AnyObject?) {
                
                case let .success(value): _result.inputMask = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Prediction", actual: "\(source)"))
            }
        }
        // Decoder for [Resource]
        Decoders.addDecoder(clazz: [Resource].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Resource]> in
            return Decoders.decode(clazz: [Resource].self, source: source)
        }

        // Decoder for Resource
        Decoders.addDecoder(clazz: Resource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Resource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Resource() : instance as! Resource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Resource.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Resource.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["credentialId"] as AnyObject?) {
                
                case let .success(value): _result.credentialId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Resource", actual: "\(source)"))
            }
        }
        // Decoder for [ResourceCredentials]
        Decoders.addDecoder(clazz: [ResourceCredentials].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResourceCredentials]> in
            return Decoders.decode(clazz: [ResourceCredentials].self, source: source)
        }

        // Decoder for ResourceCredentials
        Decoders.addDecoder(clazz: ResourceCredentials.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResourceCredentials> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResourceCredentials() : instance as! ResourceCredentials
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["credentialId"] as AnyObject?) {
                
                case let .success(value): _result.credentialId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResourceCredentials.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): _result.uri = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResourceCredentials", actual: "\(source)"))
            }
        }
        // Decoder for [ResourceGroup]
        Decoders.addDecoder(clazz: [ResourceGroup].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResourceGroup]> in
            return Decoders.decode(clazz: [ResourceGroup].self, source: source)
        }

        // Decoder for ResourceGroup
        Decoders.addDecoder(clazz: ResourceGroup.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResourceGroup> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResourceGroup() : instance as! ResourceGroup
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["groupName"] as AnyObject?) {
                
                case let .success(value): _result.groupName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["added"] as AnyObject?) {
                
                case let .success(value): _result.added = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResourceGroup", actual: "\(source)"))
            }
        }
        // Decoder for [RetrainingStatus]
        Decoders.addDecoder(clazz: [RetrainingStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RetrainingStatus]> in
            return Decoders.decode(clazz: [RetrainingStatus].self, source: source)
        }

        // Decoder for RetrainingStatus
        Decoders.addDecoder(clazz: RetrainingStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RetrainingStatus> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RetrainingStatus() : instance as! RetrainingStatus
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["istraining"] as AnyObject?) {
                
                case let .success(value): _result.istraining = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RetrainingStatus", actual: "\(source)"))
            }
        }
        // Decoder for [RevisionsWritten]
        Decoders.addDecoder(clazz: [RevisionsWritten].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RevisionsWritten]> in
            return Decoders.decode(clazz: [RevisionsWritten].self, source: source)
        }

        // Decoder for RevisionsWritten
        Decoders.addDecoder(clazz: RevisionsWritten.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RevisionsWritten> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RevisionsWritten() : instance as! RevisionsWritten
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numRevisions"] as AnyObject?) {
                
                case let .success(value): _result.numRevisions = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RevisionsWritten", actual: "\(source)"))
            }
        }
        // Decoder for [Role]
        Decoders.addDecoder(clazz: [Role].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Role]> in
            return Decoders.decode(clazz: [Role].self, source: source)
        }

        // Decoder for Role
        Decoders.addDecoder(clazz: Role.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Role> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Role() : instance as! Role
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["roleId"] as AnyObject?) {
                
                case let .success(value): _result.roleId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["roleName"] as AnyObject?) {
                
                case let .success(value): _result.roleName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Role", actual: "\(source)"))
            }
        }
        // Decoder for [RollbackStatus]
        Decoders.addDecoder(clazz: [RollbackStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RollbackStatus]> in
            return Decoders.decode(clazz: [RollbackStatus].self, source: source)
        }

        // Decoder for RollbackStatus
        Decoders.addDecoder(clazz: RollbackStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RollbackStatus> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RollbackStatus() : instance as! RollbackStatus
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RollbackStatus", actual: "\(source)"))
            }
        }
        // Decoder for [S3ResourceDetails]
        Decoders.addDecoder(clazz: [S3ResourceDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[S3ResourceDetails]> in
            return Decoders.decode(clazz: [S3ResourceDetails].self, source: source)
        }

        // Decoder for S3ResourceDetails
        Decoders.addDecoder(clazz: S3ResourceDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<S3ResourceDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? S3ResourceDetails() : instance as! S3ResourceDetails
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: S3ResourceDetails.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: S3ResourceDetails.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bucket"] as AnyObject?) {
                
                case let .success(value): _result.bucket = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["region"] as AnyObject?) {
                
                case let .success(value): _result.region = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "S3ResourceDetails", actual: "\(source)"))
            }
        }
        // Decoder for [SetState]
        Decoders.addDecoder(clazz: [SetState].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SetState]> in
            return Decoders.decode(clazz: [SetState].self, source: source)
        }

        // Decoder for SetState
        Decoders.addDecoder(clazz: SetState.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SetState> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SetState() : instance as! SetState
                switch Decoders.decodeOptional(clazz: SetState.State.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SetState", actual: "\(source)"))
            }
        }
        // Decoder for [SingleCSVRecord]
        Decoders.addDecoder(clazz: [SingleCSVRecord].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SingleCSVRecord]> in
            return Decoders.decode(clazz: [SingleCSVRecord].self, source: source)
        }

        // Decoder for SingleCSVRecord
        Decoders.addDecoder(clazz: SingleCSVRecord.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SingleCSVRecord> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SingleCSVRecord() : instance as! SingleCSVRecord
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["values"] as AnyObject?) {
                
                case let .success(value): _result.values = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SingleCSVRecord", actual: "\(source)"))
            }
        }
        // Decoder for [SingleRecord]
        Decoders.addDecoder(clazz: [SingleRecord].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SingleRecord]> in
            return Decoders.decode(clazz: [SingleRecord].self, source: source)
        }

        // Decoder for SingleRecord
        Decoders.addDecoder(clazz: SingleRecord.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SingleRecord> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SingleRecord() : instance as! SingleRecord
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["values"] as AnyObject?) {
                
                case let .success(value): _result.values = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): _result.uri = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SingleRecord", actual: "\(source)"))
            }
        }
        // Decoder for [Token]
        Decoders.addDecoder(clazz: [Token].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Token]> in
            return Decoders.decode(clazz: [Token].self, source: source)
        }

        // Decoder for Token
        Decoders.addDecoder(clazz: Token.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Token> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Token() : instance as! Token
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["tokenId"] as AnyObject?) {
                
                case let .success(value): _result.tokenId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["issued"] as AnyObject?) {
                
                case let .success(value): _result.issued = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["expire"] as AnyObject?) {
                
                case let .success(value): _result.expire = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): _result.token = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["userId"] as AnyObject?) {
                
                case let .success(value): _result.userId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["isRevoked"] as AnyObject?) {
                
                case let .success(value): _result.isRevoked = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Token", actual: "\(source)"))
            }
        }
        // Decoder for [TokenGenerateRequest]
        Decoders.addDecoder(clazz: [TokenGenerateRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TokenGenerateRequest]> in
            return Decoders.decode(clazz: [TokenGenerateRequest].self, source: source)
        }

        // Decoder for TokenGenerateRequest
        Decoders.addDecoder(clazz: TokenGenerateRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TokenGenerateRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TokenGenerateRequest() : instance as! TokenGenerateRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["userId"] as AnyObject?) {
                
                case let .success(value): _result.userId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["expiry"] as AnyObject?) {
                
                case let .success(value): _result.expiry = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TokenGenerateRequest", actual: "\(source)"))
            }
        }
        // Decoder for [TransformProcess]
        Decoders.addDecoder(clazz: [TransformProcess].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TransformProcess]> in
            return Decoders.decode(clazz: [TransformProcess].self, source: source)
        }

        // Decoder for TransformProcess
        Decoders.addDecoder(clazz: TransformProcess.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TransformProcess> in
            if let source = source as? TransformProcess {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias TransformProcess", actual: "\(source)"))
            }
        }
        // Decoder for [UpdateBestModel]
        Decoders.addDecoder(clazz: [UpdateBestModel].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UpdateBestModel]> in
            return Decoders.decode(clazz: [UpdateBestModel].self, source: source)
        }

        // Decoder for UpdateBestModel
        Decoders.addDecoder(clazz: UpdateBestModel.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UpdateBestModel> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UpdateBestModel() : instance as! UpdateBestModel
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["experimentId"] as AnyObject?) {
                
                case let .success(value): _result.experimentId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bestModelId"] as AnyObject?) {
                
                case let .success(value): _result.bestModelId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UpdateBestModel", actual: "\(source)"))
            }
        }
        // Decoder for [User]
        Decoders.addDecoder(clazz: [User].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[User]> in
            return Decoders.decode(clazz: [User].self, source: source)
        }

        // Decoder for User
        Decoders.addDecoder(clazz: User.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<User> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? User() : instance as! User
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["userId"] as AnyObject?) {
                
                case let .success(value): _result.userId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["userName"] as AnyObject?) {
                
                case let .success(value): _result.userName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): _result.password = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["role"] as AnyObject?) {
                
                case let .success(value): _result.role = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["scope"] as AnyObject?) {
                
                case let .success(value): _result.scope = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "User", actual: "\(source)"))
            }
        }
        // Decoder for [YARNResourceDetails]
        Decoders.addDecoder(clazz: [YARNResourceDetails].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[YARNResourceDetails]> in
            return Decoders.decode(clazz: [YARNResourceDetails].self, source: source)
        }

        // Decoder for YARNResourceDetails
        Decoders.addDecoder(clazz: YARNResourceDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<YARNResourceDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? YARNResourceDetails() : instance as! YARNResourceDetails
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["@class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resourceId"] as AnyObject?) {
                
                case let .success(value): _result.resourceId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: YARNResourceDetails.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: YARNResourceDetails.SubType.self, source: sourceDictionary["subType"] as AnyObject?) {
                
                case let .success(value): _result.subType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["localSparkHome"] as AnyObject?) {
                
                case let .success(value): _result.localSparkHome = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "YARNResourceDetails", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
