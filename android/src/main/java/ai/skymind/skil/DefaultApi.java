/**
 * Endpoints
 * Endpoints API for different services in SKIL
 *
 * The version of the OpenAPI document: 1.2.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package ai.skymind.skil;

import ai.skymind.ApiInvoker;
import ai.skymind.ApiException;
import ai.skymind.Pair;

import ai.skymind.skil.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import ai.skymind.skil.model.AccumulatedResults;
import ai.skymind.skil.model.AddCredentialsRequest;
import ai.skymind.skil.model.AddExampleRequest;
import ai.skymind.skil.model.AddModelHistoryRequest;
import ai.skymind.skil.model.AddResourceRequest;
import ai.skymind.skil.model.AggregatePrediction;
import ai.skymind.skil.model.AuthPolicy;
import ai.skymind.skil.model.Base64NDArrayBody;
import ai.skymind.skil.model.Base64NDArrayBodyKNN;
import ai.skymind.skil.model.BatchCSVRecord;
import ai.skymind.skil.model.BatchRecord;
import ai.skymind.skil.model.BestModel;
import ai.skymind.skil.model.ChangePasswordRequest;
import ai.skymind.skil.model.ClassificationResult;
import ai.skymind.skil.model.CreateDeploymentRequest;
import ai.skymind.skil.model.CreateJobRequest;
import ai.skymind.skil.model.DeploymentResponse;
import ai.skymind.skil.model.DetectionResult;
import ai.skymind.skil.model.DownloadOutputFileRequest;
import ai.skymind.skil.model.EvaluationResultsEntity;
import ai.skymind.skil.model.ExampleEntity;
import ai.skymind.skil.model.ExperimentEntity;
import ai.skymind.skil.model.FeedbackResponse;
import java.io.File;
import ai.skymind.skil.model.FileUploadList;
import ai.skymind.skil.model.ImportModelRequest;
import ai.skymind.skil.model.InlineResponse200;
import ai.skymind.skil.model.JobEntity;
import ai.skymind.skil.model.JsonArrayResponse;
import java.util.*;
import ai.skymind.skil.model.LogBatch;
import ai.skymind.skil.model.LogRequest;
import ai.skymind.skil.model.LoginRequest;
import ai.skymind.skil.model.LoginResponse;
import ai.skymind.skil.model.MinibatchEntity;
import ai.skymind.skil.model.ModelEntity;
import ai.skymind.skil.model.ModelFeedBackRequest;
import ai.skymind.skil.model.ModelHistoryEntity;
import ai.skymind.skil.model.ModelInstanceEntity;
import ai.skymind.skil.model.ModelStatus;
import ai.skymind.skil.model.MultiClassClassificationResult;
import ai.skymind.skil.model.MultiPredictRequest;
import ai.skymind.skil.model.MultiPredictResponse;
import ai.skymind.skil.model.NearestNeighborRequest;
import ai.skymind.skil.model.NearestNeighborsResults;
import ai.skymind.skil.model.Prediction;
import ai.skymind.skil.model.Resource;
import ai.skymind.skil.model.ResourceCredentials;
import ai.skymind.skil.model.ResourceGroup;
import ai.skymind.skil.model.RetrainingStatus;
import ai.skymind.skil.model.RevisionsWritten;
import ai.skymind.skil.model.Role;
import ai.skymind.skil.model.RollbackStatus;
import ai.skymind.skil.model.SetState;
import ai.skymind.skil.model.SingleCSVRecord;
import ai.skymind.skil.model.SingleRecord;
import ai.skymind.skil.model.Token;
import ai.skymind.skil.model.TokenGenerateRequest;
import ai.skymind.skil.model.UpdateBestModel;
import ai.skymind.skil.model.User;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class DefaultApi {
  String basePath = "http://localhost:9008";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Tells how many retraining examples have labels associated with them.
  * 
   * @return AccumulatedResults
  */
  public AccumulatedResults accumulatedResults () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/accumulatedresults";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AccumulatedResults) ApiInvoker.deserialize(localVarResponse, "", AccumulatedResults.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Tells how many retraining examples have labels associated with them.
   * 

  */
  public void accumulatedResults (final Response.Listener<AccumulatedResults> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/accumulatedresults".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AccumulatedResults) ApiInvoker.deserialize(localVarResponse,  "", AccumulatedResults.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds credentials
  * 
   * @param addCredentialsRequest Add credentials request object
   * @return ResourceCredentials
  */
  public ResourceCredentials addCredentials (AddCredentialsRequest addCredentialsRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = addCredentialsRequest;
    // verify the required parameter 'addCredentialsRequest' is set
    if (addCredentialsRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'addCredentialsRequest' when calling addCredentials",
        new ApiException(400, "Missing the required parameter 'addCredentialsRequest' when calling addCredentials"));
    }

    // create path and map variables
    String path = "/resources/credentials";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ResourceCredentials) ApiInvoker.deserialize(localVarResponse, "", ResourceCredentials.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds credentials
   * 
   * @param addCredentialsRequest Add credentials request object
  */
  public void addCredentials (AddCredentialsRequest addCredentialsRequest, final Response.Listener<ResourceCredentials> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = addCredentialsRequest;

    // verify the required parameter 'addCredentialsRequest' is set
    if (addCredentialsRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'addCredentialsRequest' when calling addCredentials",
        new ApiException(400, "Missing the required parameter 'addCredentialsRequest' when calling addCredentials"));
    }

    // create path and map variables
    String path = "/resources/credentials".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ResourceCredentials) ApiInvoker.deserialize(localVarResponse,  "", ResourceCredentials.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds an evaluation result
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param evaluationResultsEntity The evaluation result entity
   * @return EvaluationResultsEntity
  */
  public EvaluationResultsEntity addEvaluationResult (String modelHistoryServerId, EvaluationResultsEntity evaluationResultsEntity) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = evaluationResultsEntity;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addEvaluationResult",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addEvaluationResult"));
    }
    // verify the required parameter 'evaluationResultsEntity' is set
    if (evaluationResultsEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'evaluationResultsEntity' when calling addEvaluationResult",
        new ApiException(400, "Missing the required parameter 'evaluationResultsEntity' when calling addEvaluationResult"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/revisions/evaluations/".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (EvaluationResultsEntity) ApiInvoker.deserialize(localVarResponse, "", EvaluationResultsEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds an evaluation result
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param evaluationResultsEntity The evaluation result entity
  */
  public void addEvaluationResult (String modelHistoryServerId, EvaluationResultsEntity evaluationResultsEntity, final Response.Listener<EvaluationResultsEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = evaluationResultsEntity;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addEvaluationResult",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addEvaluationResult"));
    }
    // verify the required parameter 'evaluationResultsEntity' is set
    if (evaluationResultsEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'evaluationResultsEntity' when calling addEvaluationResult",
        new ApiException(400, "Missing the required parameter 'evaluationResultsEntity' when calling addEvaluationResult"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/revisions/evaluations/".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((EvaluationResultsEntity) ApiInvoker.deserialize(localVarResponse,  "", EvaluationResultsEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds a number of examples to a minibatch ID given an AddExampleRequest.
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param addExampleRequest The add example request, encapsulating minibatch details and examples batch size
   * @return AddExampleRequest
  */
  public AddExampleRequest addExampleForBatch (String modelHistoryServerId, AddExampleRequest addExampleRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = addExampleRequest;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addExampleForBatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addExampleForBatch"));
    }
    // verify the required parameter 'addExampleRequest' is set
    if (addExampleRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'addExampleRequest' when calling addExampleForBatch",
        new ApiException(400, "Missing the required parameter 'addExampleRequest' when calling addExampleForBatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/exampleForBatch".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AddExampleRequest) ApiInvoker.deserialize(localVarResponse, "", AddExampleRequest.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds a number of examples to a minibatch ID given an AddExampleRequest.
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param addExampleRequest The add example request, encapsulating minibatch details and examples batch size
  */
  public void addExampleForBatch (String modelHistoryServerId, AddExampleRequest addExampleRequest, final Response.Listener<AddExampleRequest> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = addExampleRequest;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addExampleForBatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addExampleForBatch"));
    }
    // verify the required parameter 'addExampleRequest' is set
    if (addExampleRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'addExampleRequest' when calling addExampleForBatch",
        new ApiException(400, "Missing the required parameter 'addExampleRequest' when calling addExampleForBatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/exampleForBatch".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AddExampleRequest) ApiInvoker.deserialize(localVarResponse,  "", AddExampleRequest.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds an example to a minibatch
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param exampleEntity The example to add to the minibatch
   * @return ExampleEntity
  */
  public ExampleEntity addExampleToMinibatch (String modelHistoryServerId, ExampleEntity exampleEntity) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = exampleEntity;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addExampleToMinibatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addExampleToMinibatch"));
    }
    // verify the required parameter 'exampleEntity' is set
    if (exampleEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'exampleEntity' when calling addExampleToMinibatch",
        new ApiException(400, "Missing the required parameter 'exampleEntity' when calling addExampleToMinibatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/example".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ExampleEntity) ApiInvoker.deserialize(localVarResponse, "", ExampleEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds an example to a minibatch
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param exampleEntity The example to add to the minibatch
  */
  public void addExampleToMinibatch (String modelHistoryServerId, ExampleEntity exampleEntity, final Response.Listener<ExampleEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = exampleEntity;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addExampleToMinibatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addExampleToMinibatch"));
    }
    // verify the required parameter 'exampleEntity' is set
    if (exampleEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'exampleEntity' when calling addExampleToMinibatch",
        new ApiException(400, "Missing the required parameter 'exampleEntity' when calling addExampleToMinibatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/example".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ExampleEntity) ApiInvoker.deserialize(localVarResponse,  "", ExampleEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Add an experiment, given an experiment entity
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param experimentEntity The experiment entity to add
   * @return ExperimentEntity
  */
  public ExperimentEntity addExperiment (String modelHistoryServerId, ExperimentEntity experimentEntity) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = experimentEntity;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addExperiment"));
    }
    // verify the required parameter 'experimentEntity' is set
    if (experimentEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentEntity' when calling addExperiment",
        new ApiException(400, "Missing the required parameter 'experimentEntity' when calling addExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ExperimentEntity) ApiInvoker.deserialize(localVarResponse, "", ExperimentEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Add an experiment, given an experiment entity
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param experimentEntity The experiment entity to add
  */
  public void addExperiment (String modelHistoryServerId, ExperimentEntity experimentEntity, final Response.Listener<ExperimentEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = experimentEntity;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addExperiment"));
    }
    // verify the required parameter 'experimentEntity' is set
    if (experimentEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentEntity' when calling addExperiment",
        new ApiException(400, "Missing the required parameter 'experimentEntity' when calling addExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ExperimentEntity) ApiInvoker.deserialize(localVarResponse,  "", ExperimentEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * 
  * 
   * @param id Batch ID to retrain the model with and get feedback for.
   * @param type The type of the labels array.
   * @param file The labels file to upload.
   * @return FeedbackResponse
  */
  public FeedbackResponse addFeedbackBinary (String id, String type, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'id' is set
    if (id == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'id' when calling addFeedbackBinary",
        new ApiException(400, "Missing the required parameter 'id' when calling addFeedbackBinary"));
    }
    // verify the required parameter 'type' is set
    if (type == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'type' when calling addFeedbackBinary",
        new ApiException(400, "Missing the required parameter 'type' when calling addFeedbackBinary"));
    }

    // create path and map variables
    String path = "/feedback/{id}/{type}".replaceAll("\\{" + "id" + "\\}", apiInvoker.escapeString(id.toString())).replaceAll("\\{" + "type" + "\\}", apiInvoker.escapeString(type.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (FeedbackResponse) ApiInvoker.deserialize(localVarResponse, "", FeedbackResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * 
   * 
   * @param id Batch ID to retrain the model with and get feedback for.   * @param type The type of the labels array.   * @param file The labels file to upload.
  */
  public void addFeedbackBinary (String id, String type, File file, final Response.Listener<FeedbackResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'id' is set
    if (id == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'id' when calling addFeedbackBinary",
        new ApiException(400, "Missing the required parameter 'id' when calling addFeedbackBinary"));
    }
    // verify the required parameter 'type' is set
    if (type == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'type' when calling addFeedbackBinary",
        new ApiException(400, "Missing the required parameter 'type' when calling addFeedbackBinary"));
    }

    // create path and map variables
    String path = "/feedback/{id}/{type}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "id" + "\\}", apiInvoker.escapeString(id.toString())).replaceAll("\\{" + "type" + "\\}", apiInvoker.escapeString(type.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((FeedbackResponse) ApiInvoker.deserialize(localVarResponse,  "", FeedbackResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets the retraining feedback for the given batch ID.
  * 
   * @param id Batch ID to retrain the model with and get feedback for.
   * @param labels The associated labels (one-hot vectors) with the batch for retraining.
   * @return FeedbackResponse
  */
  public FeedbackResponse addFeedbackJson (String id, List<List<Double>> labels) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = labels;
    // verify the required parameter 'id' is set
    if (id == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'id' when calling addFeedbackJson",
        new ApiException(400, "Missing the required parameter 'id' when calling addFeedbackJson"));
    }

    // create path and map variables
    String path = "/feedback/{id}/json".replaceAll("\\{" + "id" + "\\}", apiInvoker.escapeString(id.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (FeedbackResponse) ApiInvoker.deserialize(localVarResponse, "", FeedbackResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets the retraining feedback for the given batch ID.
   * 
   * @param id Batch ID to retrain the model with and get feedback for.   * @param labels The associated labels (one-hot vectors) with the batch for retraining.
  */
  public void addFeedbackJson (String id, List<List<Double>> labels, final Response.Listener<FeedbackResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = labels;

    // verify the required parameter 'id' is set
    if (id == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'id' when calling addFeedbackJson",
        new ApiException(400, "Missing the required parameter 'id' when calling addFeedbackJson"));
    }

    // create path and map variables
    String path = "/feedback/{id}/json".replaceAll("\\{format\\}","json").replaceAll("\\{" + "id" + "\\}", apiInvoker.escapeString(id.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((FeedbackResponse) ApiInvoker.deserialize(localVarResponse,  "", FeedbackResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds a minibatch
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param minibatchEntity The minibatch entity to add
   * @return MinibatchEntity
  */
  public MinibatchEntity addMinibatch (String modelHistoryServerId, MinibatchEntity minibatchEntity) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = minibatchEntity;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addMinibatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addMinibatch"));
    }
    // verify the required parameter 'minibatchEntity' is set
    if (minibatchEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'minibatchEntity' when calling addMinibatch",
        new ApiException(400, "Missing the required parameter 'minibatchEntity' when calling addMinibatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/minibatch".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (MinibatchEntity) ApiInvoker.deserialize(localVarResponse, "", MinibatchEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds a minibatch
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param minibatchEntity The minibatch entity to add
  */
  public void addMinibatch (String modelHistoryServerId, MinibatchEntity minibatchEntity, final Response.Listener<MinibatchEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = minibatchEntity;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addMinibatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addMinibatch"));
    }
    // verify the required parameter 'minibatchEntity' is set
    if (minibatchEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'minibatchEntity' when calling addMinibatch",
        new ApiException(400, "Missing the required parameter 'minibatchEntity' when calling addMinibatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/minibatch".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((MinibatchEntity) ApiInvoker.deserialize(localVarResponse,  "", MinibatchEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds an evaluation feedback to the model against a given minibatch id.
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelFeedBackRequest The model feedback request object
   * @return ModelFeedBackRequest
  */
  public ModelFeedBackRequest addModelFeedback (String modelHistoryServerId, ModelFeedBackRequest modelFeedBackRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = modelFeedBackRequest;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addModelFeedback",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addModelFeedback"));
    }
    // verify the required parameter 'modelFeedBackRequest' is set
    if (modelFeedBackRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelFeedBackRequest' when calling addModelFeedback",
        new ApiException(400, "Missing the required parameter 'modelFeedBackRequest' when calling addModelFeedback"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/feedback".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelFeedBackRequest) ApiInvoker.deserialize(localVarResponse, "", ModelFeedBackRequest.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds an evaluation feedback to the model against a given minibatch id.
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelFeedBackRequest The model feedback request object
  */
  public void addModelFeedback (String modelHistoryServerId, ModelFeedBackRequest modelFeedBackRequest, final Response.Listener<ModelFeedBackRequest> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = modelFeedBackRequest;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addModelFeedback",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addModelFeedback"));
    }
    // verify the required parameter 'modelFeedBackRequest' is set
    if (modelFeedBackRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelFeedBackRequest' when calling addModelFeedback",
        new ApiException(400, "Missing the required parameter 'modelFeedBackRequest' when calling addModelFeedback"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/feedback".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelFeedBackRequest) ApiInvoker.deserialize(localVarResponse,  "", ModelFeedBackRequest.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Add a model history / workspace
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param addModelHistoryRequest The model history request object
   * @return ModelHistoryEntity
  */
  public ModelHistoryEntity addModelHistory (String modelHistoryServerId, AddModelHistoryRequest addModelHistoryRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = addModelHistoryRequest;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addModelHistory"));
    }
    // verify the required parameter 'addModelHistoryRequest' is set
    if (addModelHistoryRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'addModelHistoryRequest' when calling addModelHistory",
        new ApiException(400, "Missing the required parameter 'addModelHistoryRequest' when calling addModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/modelhistory".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelHistoryEntity) ApiInvoker.deserialize(localVarResponse, "", ModelHistoryEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Add a model history / workspace
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param addModelHistoryRequest The model history request object
  */
  public void addModelHistory (String modelHistoryServerId, AddModelHistoryRequest addModelHistoryRequest, final Response.Listener<ModelHistoryEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = addModelHistoryRequest;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addModelHistory"));
    }
    // verify the required parameter 'addModelHistoryRequest' is set
    if (addModelHistoryRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'addModelHistoryRequest' when calling addModelHistory",
        new ApiException(400, "Missing the required parameter 'addModelHistoryRequest' when calling addModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/modelhistory".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelHistoryEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelHistoryEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds a model
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelInstanceEntity The object encapsulating the model instance id and evaluation type to aggregate
   * @return ModelInstanceEntity
  */
  public ModelInstanceEntity addModelInstance (String modelHistoryServerId, ModelInstanceEntity modelInstanceEntity) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = modelInstanceEntity;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addModelInstance",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addModelInstance"));
    }
    // verify the required parameter 'modelInstanceEntity' is set
    if (modelInstanceEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelInstanceEntity' when calling addModelInstance",
        new ApiException(400, "Missing the required parameter 'modelInstanceEntity' when calling addModelInstance"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelInstanceEntity) ApiInvoker.deserialize(localVarResponse, "", ModelInstanceEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds a model
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelInstanceEntity The object encapsulating the model instance id and evaluation type to aggregate
  */
  public void addModelInstance (String modelHistoryServerId, ModelInstanceEntity modelInstanceEntity, final Response.Listener<ModelInstanceEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = modelInstanceEntity;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling addModelInstance",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling addModelInstance"));
    }
    // verify the required parameter 'modelInstanceEntity' is set
    if (modelInstanceEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelInstanceEntity' when calling addModelInstance",
        new ApiException(400, "Missing the required parameter 'modelInstanceEntity' when calling addModelInstance"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelInstanceEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelInstanceEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds a resource
  * 
   * @param addResourceRequest The Add resource request object
   * @return Object
  */
  public Object addResource (AddResourceRequest addResourceRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = addResourceRequest;
    // verify the required parameter 'addResourceRequest' is set
    if (addResourceRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'addResourceRequest' when calling addResource",
        new ApiException(400, "Missing the required parameter 'addResourceRequest' when calling addResource"));
    }

    // create path and map variables
    String path = "/resources/add/resource";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Object) ApiInvoker.deserialize(localVarResponse, "", Object.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds a resource
   * 
   * @param addResourceRequest The Add resource request object
  */
  public void addResource (AddResourceRequest addResourceRequest, final Response.Listener<Object> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = addResourceRequest;

    // verify the required parameter 'addResourceRequest' is set
    if (addResourceRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'addResourceRequest' when calling addResource",
        new ApiException(400, "Missing the required parameter 'addResourceRequest' when calling addResource"));
    }

    // create path and map variables
    String path = "/resources/add/resource".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Object) ApiInvoker.deserialize(localVarResponse,  "", Object.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds a resource group
  * 
   * @param groupName Name of the resource group
   * @return ResourceGroup
  */
  public ResourceGroup addResourceGroup (String groupName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = groupName;
    // verify the required parameter 'groupName' is set
    if (groupName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'groupName' when calling addResourceGroup",
        new ApiException(400, "Missing the required parameter 'groupName' when calling addResourceGroup"));
    }

    // create path and map variables
    String path = "/resources/add/group";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "text/plain; charset=utf-8"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ResourceGroup) ApiInvoker.deserialize(localVarResponse, "", ResourceGroup.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds a resource group
   * 
   * @param groupName Name of the resource group
  */
  public void addResourceGroup (String groupName, final Response.Listener<ResourceGroup> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = groupName;

    // verify the required parameter 'groupName' is set
    if (groupName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'groupName' when calling addResourceGroup",
        new ApiException(400, "Missing the required parameter 'groupName' when calling addResourceGroup"));
    }

    // create path and map variables
    String path = "/resources/add/group".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "text/plain; charset=utf-8"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ResourceGroup) ApiInvoker.deserialize(localVarResponse,  "", ResourceGroup.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Adds a resource to a resource group
  * 
   * @param resourceGroupId ID of the resource group
   * @param resourceId ID of the resource
   * @return void
  */
  public void addResourceToGroup (Long resourceGroupId, Long resourceId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling addResourceToGroup",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling addResourceToGroup"));
    }
    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling addResourceToGroup",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling addResourceToGroup"));
    }

    // create path and map variables
    String path = "/resources/add/resourcetogroup/{resourceGroupId}/{resourceId}".replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString())).replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Adds a resource to a resource group
   * 
   * @param resourceGroupId ID of the resource group   * @param resourceId ID of the resource
  */
  public void addResourceToGroup (Long resourceGroupId, Long resourceId, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling addResourceToGroup",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling addResourceToGroup"));
    }
    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling addResourceToGroup",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling addResourceToGroup"));
    }

    // create path and map variables
    String path = "/resources/add/resourcetogroup/{resourceGroupId}/{resourceId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString())).replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Aggregates the evaluaition results of a model instance, based on the evaluation type
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param aggregatePrediction The object encapsulating the model instance id and evaluation type to aggregate
   * @return EvaluationResultsEntity
  */
  public EvaluationResultsEntity aggregateModelResults (String modelHistoryServerId, AggregatePrediction aggregatePrediction) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = aggregatePrediction;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling aggregateModelResults",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling aggregateModelResults"));
    }
    // verify the required parameter 'aggregatePrediction' is set
    if (aggregatePrediction == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'aggregatePrediction' when calling aggregateModelResults",
        new ApiException(400, "Missing the required parameter 'aggregatePrediction' when calling aggregateModelResults"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/aggregateresults".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (EvaluationResultsEntity) ApiInvoker.deserialize(localVarResponse, "", EvaluationResultsEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Aggregates the evaluaition results of a model instance, based on the evaluation type
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param aggregatePrediction The object encapsulating the model instance id and evaluation type to aggregate
  */
  public void aggregateModelResults (String modelHistoryServerId, AggregatePrediction aggregatePrediction, final Response.Listener<EvaluationResultsEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = aggregatePrediction;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling aggregateModelResults",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling aggregateModelResults"));
    }
    // verify the required parameter 'aggregatePrediction' is set
    if (aggregatePrediction == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'aggregatePrediction' when calling aggregateModelResults",
        new ApiException(400, "Missing the required parameter 'aggregatePrediction' when calling aggregateModelResults"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/aggregateresults".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((EvaluationResultsEntity) ApiInvoker.deserialize(localVarResponse,  "", EvaluationResultsEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Change user&#39;s password
  * 
   * @param userId User&#39;s ID
   * @param changePasswordRequest Password details.
   * @return User
  */
  public User changeUserPassword (String userId, ChangePasswordRequest changePasswordRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = changePasswordRequest;
    // verify the required parameter 'userId' is set
    if (userId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'userId' when calling changeUserPassword",
        new ApiException(400, "Missing the required parameter 'userId' when calling changeUserPassword"));
    }
    // verify the required parameter 'changePasswordRequest' is set
    if (changePasswordRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'changePasswordRequest' when calling changeUserPassword",
        new ApiException(400, "Missing the required parameter 'changePasswordRequest' when calling changeUserPassword"));
    }

    // create path and map variables
    String path = "/user/{userId}/password".replaceAll("\\{" + "userId" + "\\}", apiInvoker.escapeString(userId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (User) ApiInvoker.deserialize(localVarResponse, "", User.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Change user&#39;s password
   * 
   * @param userId User&#39;s ID   * @param changePasswordRequest Password details.
  */
  public void changeUserPassword (String userId, ChangePasswordRequest changePasswordRequest, final Response.Listener<User> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = changePasswordRequest;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'userId' when calling changeUserPassword",
        new ApiException(400, "Missing the required parameter 'userId' when calling changeUserPassword"));
    }
    // verify the required parameter 'changePasswordRequest' is set
    if (changePasswordRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'changePasswordRequest' when calling changeUserPassword",
        new ApiException(400, "Missing the required parameter 'changePasswordRequest' when calling changeUserPassword"));
    }

    // create path and map variables
    String path = "/user/{userId}/password".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}", apiInvoker.escapeString(userId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((User) ApiInvoker.deserialize(localVarResponse,  "", User.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Use the deployed model to classify the input
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body The input NDArray
   * @return ClassificationResult
  */
  public ClassificationResult classify (String deploymentName, String versionName, String modelName, Prediction body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling classify",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling classify"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling classify",
        new ApiException(400, "Missing the required parameter 'versionName' when calling classify"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling classify",
        new ApiException(400, "Missing the required parameter 'modelName' when calling classify"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling classify",
        new ApiException(400, "Missing the required parameter 'body' when calling classify"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/classify".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ClassificationResult) ApiInvoker.deserialize(localVarResponse, "", ClassificationResult.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Use the deployed model to classify the input
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body The input NDArray
  */
  public void classify (String deploymentName, String versionName, String modelName, Prediction body, final Response.Listener<ClassificationResult> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling classify",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling classify"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling classify",
        new ApiException(400, "Missing the required parameter 'versionName' when calling classify"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling classify",
        new ApiException(400, "Missing the required parameter 'modelName' when calling classify"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling classify",
        new ApiException(400, "Missing the required parameter 'body' when calling classify"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/classify".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ClassificationResult) ApiInvoker.deserialize(localVarResponse,  "", ClassificationResult.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Same as /classify but returns the output as Base64NDArrayBody
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body The input NDArray
   * @return Base64NDArrayBody
  */
  public Base64NDArrayBody classifyarray (String deploymentName, String versionName, String modelName, Prediction body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling classifyarray",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling classifyarray"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling classifyarray",
        new ApiException(400, "Missing the required parameter 'versionName' when calling classifyarray"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling classifyarray",
        new ApiException(400, "Missing the required parameter 'modelName' when calling classifyarray"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling classifyarray",
        new ApiException(400, "Missing the required parameter 'body' when calling classifyarray"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyarray".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse, "", Base64NDArrayBody.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Same as /classify but returns the output as Base64NDArrayBody
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body The input NDArray
  */
  public void classifyarray (String deploymentName, String versionName, String modelName, Prediction body, final Response.Listener<Base64NDArrayBody> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling classifyarray",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling classifyarray"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling classifyarray",
        new ApiException(400, "Missing the required parameter 'versionName' when calling classifyarray"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling classifyarray",
        new ApiException(400, "Missing the required parameter 'modelName' when calling classifyarray"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling classifyarray",
        new ApiException(400, "Missing the required parameter 'body' when calling classifyarray"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyarray".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse,  "", Base64NDArrayBody.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Use the deployed model to classify the input, using input image file from multipart form data.
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param image The file to upload.
   * @return ClassificationResult
  */
  public ClassificationResult classifyimage (String deploymentName, String versionName, String modelName, File image) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling classifyimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling classifyimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling classifyimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling classifyimage"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling classifyimage",
        new ApiException(400, "Missing the required parameter 'modelName' when calling classifyimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyimage".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (image != null) {
        localVarBuilder.addBinaryBody("image", image);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ClassificationResult) ApiInvoker.deserialize(localVarResponse, "", ClassificationResult.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Use the deployed model to classify the input, using input image file from multipart form data.
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param image The file to upload.
  */
  public void classifyimage (String deploymentName, String versionName, String modelName, File image, final Response.Listener<ClassificationResult> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling classifyimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling classifyimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling classifyimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling classifyimage"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling classifyimage",
        new ApiException(400, "Missing the required parameter 'modelName' when calling classifyimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyimage".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (image != null) {
        localVarBuilder.addBinaryBody("image", image);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ClassificationResult) ApiInvoker.deserialize(localVarResponse,  "", ClassificationResult.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Clears the accumulated data for retraining.
  * 
   * @return FeedbackResponse
  */
  public FeedbackResponse clearState () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/clear";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (FeedbackResponse) ApiInvoker.deserialize(localVarResponse, "", FeedbackResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Clears the accumulated data for retraining.
   * 

  */
  public void clearState (final Response.Listener<FeedbackResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/clear".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((FeedbackResponse) ApiInvoker.deserialize(localVarResponse,  "", FeedbackResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create a job
  * 
   * @param jobIdOrType Job Type
   * @param createJobRequest Create job request object
   * @return JobEntity
  */
  public JobEntity createJob (String jobIdOrType, CreateJobRequest createJobRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = createJobRequest;
    // verify the required parameter 'jobIdOrType' is set
    if (jobIdOrType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobIdOrType' when calling createJob",
        new ApiException(400, "Missing the required parameter 'jobIdOrType' when calling createJob"));
    }
    // verify the required parameter 'createJobRequest' is set
    if (createJobRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'createJobRequest' when calling createJob",
        new ApiException(400, "Missing the required parameter 'createJobRequest' when calling createJob"));
    }

    // create path and map variables
    String path = "/jobs/{jobIdOrType}".replaceAll("\\{" + "jobIdOrType" + "\\}", apiInvoker.escapeString(jobIdOrType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (JobEntity) ApiInvoker.deserialize(localVarResponse, "", JobEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create a job
   * 
   * @param jobIdOrType Job Type   * @param createJobRequest Create job request object
  */
  public void createJob (String jobIdOrType, CreateJobRequest createJobRequest, final Response.Listener<JobEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = createJobRequest;

    // verify the required parameter 'jobIdOrType' is set
    if (jobIdOrType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobIdOrType' when calling createJob",
        new ApiException(400, "Missing the required parameter 'jobIdOrType' when calling createJob"));
    }
    // verify the required parameter 'createJobRequest' is set
    if (createJobRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'createJobRequest' when calling createJob",
        new ApiException(400, "Missing the required parameter 'createJobRequest' when calling createJob"));
    }

    // create path and map variables
    String path = "/jobs/{jobIdOrType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "jobIdOrType" + "\\}", apiInvoker.escapeString(jobIdOrType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((JobEntity) ApiInvoker.deserialize(localVarResponse,  "", JobEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Creates model History
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelHistoryEntity The model history entity
   * @return ModelHistoryEntity
  */
  public ModelHistoryEntity createModelHistory (String modelHistoryServerId, ModelHistoryEntity modelHistoryEntity) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = modelHistoryEntity;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling createModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling createModelHistory"));
    }
    // verify the required parameter 'modelHistoryEntity' is set
    if (modelHistoryEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryEntity' when calling createModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryEntity' when calling createModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/revisions".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelHistoryEntity) ApiInvoker.deserialize(localVarResponse, "", ModelHistoryEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Creates model History
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelHistoryEntity The model history entity
  */
  public void createModelHistory (String modelHistoryServerId, ModelHistoryEntity modelHistoryEntity, final Response.Listener<ModelHistoryEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = modelHistoryEntity;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling createModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling createModelHistory"));
    }
    // verify the required parameter 'modelHistoryEntity' is set
    if (modelHistoryEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryEntity' when calling createModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryEntity' when calling createModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/revisions".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelHistoryEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelHistoryEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete credentials given an ID
  * 
   * @param credentialId Credentials ID
   * @return void
  */
  public void deleteCredentialsById (Long credentialId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'credentialId' is set
    if (credentialId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'credentialId' when calling deleteCredentialsById",
        new ApiException(400, "Missing the required parameter 'credentialId' when calling deleteCredentialsById"));
    }

    // create path and map variables
    String path = "/resources/credentials/{credentialId}".replaceAll("\\{" + "credentialId" + "\\}", apiInvoker.escapeString(credentialId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete credentials given an ID
   * 
   * @param credentialId Credentials ID
  */
  public void deleteCredentialsById (Long credentialId, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'credentialId' is set
    if (credentialId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'credentialId' when calling deleteCredentialsById",
        new ApiException(400, "Missing the required parameter 'credentialId' when calling deleteCredentialsById"));
    }

    // create path and map variables
    String path = "/resources/credentials/{credentialId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "credentialId" + "\\}", apiInvoker.escapeString(credentialId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Deletes an experiment, given an experiment entity
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param experimentID the GUID of the experiment to delete
   * @return InlineResponse200
  */
  public InlineResponse200 deleteExperiment (String modelHistoryServerId, String experimentID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling deleteExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling deleteExperiment"));
    }
    // verify the required parameter 'experimentID' is set
    if (experimentID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentID' when calling deleteExperiment",
        new ApiException(400, "Missing the required parameter 'experimentID' when calling deleteExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/{experimentID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "experimentID" + "\\}", apiInvoker.escapeString(experimentID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (InlineResponse200) ApiInvoker.deserialize(localVarResponse, "", InlineResponse200.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Deletes an experiment, given an experiment entity
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param experimentID the GUID of the experiment to delete
  */
  public void deleteExperiment (String modelHistoryServerId, String experimentID, final Response.Listener<InlineResponse200> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling deleteExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling deleteExperiment"));
    }
    // verify the required parameter 'experimentID' is set
    if (experimentID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentID' when calling deleteExperiment",
        new ApiException(400, "Missing the required parameter 'experimentID' when calling deleteExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/{experimentID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "experimentID" + "\\}", apiInvoker.escapeString(experimentID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((InlineResponse200) ApiInvoker.deserialize(localVarResponse,  "", InlineResponse200.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Deletes a job given its ID
  * 
   * @param jobIdOrType Job ID
   * @return void
  */
  public void deleteJobById (Long jobIdOrType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'jobIdOrType' is set
    if (jobIdOrType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobIdOrType' when calling deleteJobById",
        new ApiException(400, "Missing the required parameter 'jobIdOrType' when calling deleteJobById"));
    }

    // create path and map variables
    String path = "/jobs/{jobIdOrType}".replaceAll("\\{" + "jobIdOrType" + "\\}", apiInvoker.escapeString(jobIdOrType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Deletes a job given its ID
   * 
   * @param jobIdOrType Job ID
  */
  public void deleteJobById (Long jobIdOrType, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'jobIdOrType' is set
    if (jobIdOrType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobIdOrType' when calling deleteJobById",
        new ApiException(400, "Missing the required parameter 'jobIdOrType' when calling deleteJobById"));
    }

    // create path and map variables
    String path = "/jobs/{jobIdOrType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "jobIdOrType" + "\\}", apiInvoker.escapeString(jobIdOrType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete a model by deployment and model id
  * 
   * @param deploymentId ID deployment group
   * @param modelId the id of the deployed model
   * @return InlineResponse200
  */
  public InlineResponse200 deleteModel (String deploymentId, String modelId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling deleteModel",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling deleteModel"));
    }
    // verify the required parameter 'modelId' is set
    if (modelId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelId' when calling deleteModel",
        new ApiException(400, "Missing the required parameter 'modelId' when calling deleteModel"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model/{modelId}".replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString())).replaceAll("\\{" + "modelId" + "\\}", apiInvoker.escapeString(modelId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (InlineResponse200) ApiInvoker.deserialize(localVarResponse, "", InlineResponse200.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete a model by deployment and model id
   * 
   * @param deploymentId ID deployment group   * @param modelId the id of the deployed model
  */
  public void deleteModel (String deploymentId, String modelId, final Response.Listener<InlineResponse200> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling deleteModel",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling deleteModel"));
    }
    // verify the required parameter 'modelId' is set
    if (modelId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelId' when calling deleteModel",
        new ApiException(400, "Missing the required parameter 'modelId' when calling deleteModel"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model/{modelId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString())).replaceAll("\\{" + "modelId" + "\\}", apiInvoker.escapeString(modelId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((InlineResponse200) ApiInvoker.deserialize(localVarResponse,  "", InlineResponse200.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Deletes a model history / workspace, given its ID
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelHistoryID the GUID of the model history / workspace to delete
   * @return InlineResponse200
  */
  public InlineResponse200 deleteModelHistory (String modelHistoryServerId, String modelHistoryID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling deleteModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling deleteModelHistory"));
    }
    // verify the required parameter 'modelHistoryID' is set
    if (modelHistoryID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryID' when calling deleteModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryID' when calling deleteModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelHistoryID" + "\\}", apiInvoker.escapeString(modelHistoryID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (InlineResponse200) ApiInvoker.deserialize(localVarResponse, "", InlineResponse200.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Deletes a model history / workspace, given its ID
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelHistoryID the GUID of the model history / workspace to delete
  */
  public void deleteModelHistory (String modelHistoryServerId, String modelHistoryID, final Response.Listener<InlineResponse200> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling deleteModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling deleteModelHistory"));
    }
    // verify the required parameter 'modelHistoryID' is set
    if (modelHistoryID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryID' when calling deleteModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryID' when calling deleteModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelHistoryID" + "\\}", apiInvoker.escapeString(modelHistoryID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((InlineResponse200) ApiInvoker.deserialize(localVarResponse,  "", InlineResponse200.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Deletes a model instance, given its ID
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelInstanceID GUID of the model instance to delete.
   * @return void
  */
  public void deleteModelInstance (String modelHistoryServerId, String modelInstanceID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling deleteModelInstance",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling deleteModelInstance"));
    }
    // verify the required parameter 'modelInstanceID' is set
    if (modelInstanceID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelInstanceID' when calling deleteModelInstance",
        new ApiException(400, "Missing the required parameter 'modelInstanceID' when calling deleteModelInstance"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/{modelInstanceID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelInstanceID" + "\\}", apiInvoker.escapeString(modelInstanceID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Deletes a model instance, given its ID
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelInstanceID GUID of the model instance to delete.
  */
  public void deleteModelInstance (String modelHistoryServerId, String modelInstanceID, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling deleteModelInstance",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling deleteModelInstance"));
    }
    // verify the required parameter 'modelInstanceID' is set
    if (modelInstanceID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelInstanceID' when calling deleteModelInstance",
        new ApiException(400, "Missing the required parameter 'modelInstanceID' when calling deleteModelInstance"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/{modelInstanceID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelInstanceID" + "\\}", apiInvoker.escapeString(modelInstanceID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete the resource with the specified resource ID
  * 
   * @param resourceId ID of the resource
   * @return Resource
  */
  public Resource deleteResourceById (Long resourceId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling deleteResourceById",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling deleteResourceById"));
    }

    // create path and map variables
    String path = "/resources/remove/resource/{resourceId}".replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Resource) ApiInvoker.deserialize(localVarResponse, "", Resource.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete the resource with the specified resource ID
   * 
   * @param resourceId ID of the resource
  */
  public void deleteResourceById (Long resourceId, final Response.Listener<Resource> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling deleteResourceById",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling deleteResourceById"));
    }

    // create path and map variables
    String path = "/resources/remove/resource/{resourceId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Resource) ApiInvoker.deserialize(localVarResponse,  "", Resource.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Removes a resource from a resource group
  * 
   * @param resourceGroupId ID of the resource group
   * @param resourceId ID of the resource
   * @return void
  */
  public void deleteResourceFromGroup (Long resourceGroupId, Long resourceId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling deleteResourceFromGroup",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling deleteResourceFromGroup"));
    }
    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling deleteResourceFromGroup",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling deleteResourceFromGroup"));
    }

    // create path and map variables
    String path = "/resources/remove/resourcefromgroup/{resourceGroupId}/{resourceId}".replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString())).replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Removes a resource from a resource group
   * 
   * @param resourceGroupId ID of the resource group   * @param resourceId ID of the resource
  */
  public void deleteResourceFromGroup (Long resourceGroupId, Long resourceId, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling deleteResourceFromGroup",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling deleteResourceFromGroup"));
    }
    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling deleteResourceFromGroup",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling deleteResourceFromGroup"));
    }

    // create path and map variables
    String path = "/resources/remove/resourcefromgroup/{resourceGroupId}/{resourceId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString())).replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete the resource group with the specified resource group ID
  * 
   * @param resourceGroupId ID of the resource group
   * @return ResourceGroup
  */
  public ResourceGroup deleteResourceGroupById (Long resourceGroupId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling deleteResourceGroupById",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling deleteResourceGroupById"));
    }

    // create path and map variables
    String path = "/resources/remove/group/{resourceGroupId}".replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ResourceGroup) ApiInvoker.deserialize(localVarResponse, "", ResourceGroup.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete the resource group with the specified resource group ID
   * 
   * @param resourceGroupId ID of the resource group
  */
  public void deleteResourceGroupById (Long resourceGroupId, final Response.Listener<ResourceGroup> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling deleteResourceGroupById",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling deleteResourceGroupById"));
    }

    // create path and map variables
    String path = "/resources/remove/group/{resourceGroupId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ResourceGroup) ApiInvoker.deserialize(localVarResponse,  "", ResourceGroup.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Deploy a model in a deployment group.
  * 
   * @param deploymentId ID deployment group
   * @param body the model import request
   * @return ModelEntity
  */
  public ModelEntity deployModel (String deploymentId, ImportModelRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling deployModel",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling deployModel"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling deployModel",
        new ApiException(400, "Missing the required parameter 'body' when calling deployModel"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model".replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelEntity) ApiInvoker.deserialize(localVarResponse, "", ModelEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Deploy a model in a deployment group.
   * 
   * @param deploymentId ID deployment group   * @param body the model import request
  */
  public void deployModel (String deploymentId, ImportModelRequest body, final Response.Listener<ModelEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling deployModel",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling deployModel"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling deployModel",
        new ApiException(400, "Missing the required parameter 'body' when calling deployModel"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create a new deployment group.
  * 
   * @param body the deployment request
   * @return DeploymentResponse
  */
  public DeploymentResponse deploymentCreate (CreateDeploymentRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling deploymentCreate",
        new ApiException(400, "Missing the required parameter 'body' when calling deploymentCreate"));
    }

    // create path and map variables
    String path = "/deployment";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (DeploymentResponse) ApiInvoker.deserialize(localVarResponse, "", DeploymentResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create a new deployment group.
   * 
   * @param body the deployment request
  */
  public void deploymentCreate (CreateDeploymentRequest body, final Response.Listener<DeploymentResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling deploymentCreate",
        new ApiException(400, "Missing the required parameter 'body' when calling deploymentCreate"));
    }

    // create path and map variables
    String path = "/deployment".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((DeploymentResponse) ApiInvoker.deserialize(localVarResponse,  "", DeploymentResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete a deployment by id
  * 
   * @param deploymentId Id of the deployment group
   * @return InlineResponse200
  */
  public InlineResponse200 deploymentDelete (String deploymentId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling deploymentDelete",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling deploymentDelete"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}".replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (InlineResponse200) ApiInvoker.deserialize(localVarResponse, "", InlineResponse200.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete a deployment by id
   * 
   * @param deploymentId Id of the deployment group
  */
  public void deploymentDelete (String deploymentId, final Response.Listener<InlineResponse200> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling deploymentDelete",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling deploymentDelete"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((InlineResponse200) ApiInvoker.deserialize(localVarResponse,  "", InlineResponse200.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get a deployment details by id
  * 
   * @param deploymentId Id of the deployment group
   * @return DeploymentResponse
  */
  public DeploymentResponse deploymentGet (String deploymentId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling deploymentGet",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling deploymentGet"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}".replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (DeploymentResponse) ApiInvoker.deserialize(localVarResponse, "", DeploymentResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get a deployment details by id
   * 
   * @param deploymentId Id of the deployment group
  */
  public void deploymentGet (String deploymentId, final Response.Listener<DeploymentResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling deploymentGet",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling deploymentGet"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((DeploymentResponse) ApiInvoker.deserialize(localVarResponse,  "", DeploymentResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get a list of deployments
  * 
   * @return List<DeploymentResponse>
  */
  public List<DeploymentResponse> deployments () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/deployments";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<DeploymentResponse>) ApiInvoker.deserialize(localVarResponse, "array", DeploymentResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get a list of deployments
   * 

  */
  public void deployments (final Response.Listener<List<DeploymentResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/deployments".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<DeploymentResponse>) ApiInvoker.deserialize(localVarResponse,  "array", DeploymentResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Detect the objects, given a (input) prediction request
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param id the GUID for mapping the results in the detections
   * @param needsPreprocessing (true) if the image needs preprocessing
   * @param threshold A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none.
   * @param file the image file to detect objects from
   * @return DetectionResult
  */
  public DetectionResult detectobjects (String deploymentName, String versionName, String modelName, String id, Boolean needsPreprocessing, Float threshold, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling detectobjects"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'versionName' when calling detectobjects"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'modelName' when calling detectobjects"));
    }
    // verify the required parameter 'id' is set
    if (id == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'id' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'id' when calling detectobjects"));
    }
    // verify the required parameter 'needsPreprocessing' is set
    if (needsPreprocessing == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'needsPreprocessing' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'needsPreprocessing' when calling detectobjects"));
    }
    // verify the required parameter 'threshold' is set
    if (threshold == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'threshold' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'threshold' when calling detectobjects"));
    }
    // verify the required parameter 'file' is set
    if (file == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'file' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'file' when calling detectobjects"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/detectobjects".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (id != null) {
        localVarBuilder.addTextBody("id", ApiInvoker.parameterToString(id), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      if (needsPreprocessing != null) {
        localVarBuilder.addTextBody("needsPreprocessing", ApiInvoker.parameterToString(needsPreprocessing), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      if (threshold != null) {
        localVarBuilder.addTextBody("threshold", ApiInvoker.parameterToString(threshold), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      formParams.put("id", ApiInvoker.parameterToString(id));
      formParams.put("needsPreprocessing", ApiInvoker.parameterToString(needsPreprocessing));
      formParams.put("threshold", ApiInvoker.parameterToString(threshold));
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (DetectionResult) ApiInvoker.deserialize(localVarResponse, "", DetectionResult.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Detect the objects, given a (input) prediction request
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param id the GUID for mapping the results in the detections   * @param needsPreprocessing (true) if the image needs preprocessing   * @param threshold A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none.   * @param file the image file to detect objects from
  */
  public void detectobjects (String deploymentName, String versionName, String modelName, String id, Boolean needsPreprocessing, Float threshold, File file, final Response.Listener<DetectionResult> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling detectobjects"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'versionName' when calling detectobjects"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'modelName' when calling detectobjects"));
    }
    // verify the required parameter 'id' is set
    if (id == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'id' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'id' when calling detectobjects"));
    }
    // verify the required parameter 'needsPreprocessing' is set
    if (needsPreprocessing == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'needsPreprocessing' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'needsPreprocessing' when calling detectobjects"));
    }
    // verify the required parameter 'threshold' is set
    if (threshold == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'threshold' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'threshold' when calling detectobjects"));
    }
    // verify the required parameter 'file' is set
    if (file == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'file' when calling detectobjects",
        new ApiException(400, "Missing the required parameter 'file' when calling detectobjects"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/detectobjects".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (id != null) {
        localVarBuilder.addTextBody("id", ApiInvoker.parameterToString(id), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      
      if (needsPreprocessing != null) {
        localVarBuilder.addTextBody("needsPreprocessing", ApiInvoker.parameterToString(needsPreprocessing), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      
      if (threshold != null) {
        localVarBuilder.addTextBody("threshold", ApiInvoker.parameterToString(threshold), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      formParams.put("id", ApiInvoker.parameterToString(id));
formParams.put("needsPreprocessing", ApiInvoker.parameterToString(needsPreprocessing));
formParams.put("threshold", ApiInvoker.parameterToString(threshold));

    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((DetectionResult) ApiInvoker.deserialize(localVarResponse,  "", DetectionResult.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Download the output file from the job&#39;s execution. This will ONLY work if the job&#39;s run status is &#39;COMPLETE&#39;.
  * 
   * @param jobId Job ID
   * @param downloadOutputFileRequest Download output file request object
   * @return void
  */
  public void downloadJobOutputFile (Long jobId, DownloadOutputFileRequest downloadOutputFileRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = downloadOutputFileRequest;
    // verify the required parameter 'jobId' is set
    if (jobId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobId' when calling downloadJobOutputFile",
        new ApiException(400, "Missing the required parameter 'jobId' when calling downloadJobOutputFile"));
    }
    // verify the required parameter 'downloadOutputFileRequest' is set
    if (downloadOutputFileRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'downloadOutputFileRequest' when calling downloadJobOutputFile",
        new ApiException(400, "Missing the required parameter 'downloadOutputFileRequest' when calling downloadJobOutputFile"));
    }

    // create path and map variables
    String path = "/jobs/{jobId}/outputfile".replaceAll("\\{" + "jobId" + "\\}", apiInvoker.escapeString(jobId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Download the output file from the job&#39;s execution. This will ONLY work if the job&#39;s run status is &#39;COMPLETE&#39;.
   * 
   * @param jobId Job ID   * @param downloadOutputFileRequest Download output file request object
  */
  public void downloadJobOutputFile (Long jobId, DownloadOutputFileRequest downloadOutputFileRequest, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = downloadOutputFileRequest;

    // verify the required parameter 'jobId' is set
    if (jobId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobId' when calling downloadJobOutputFile",
        new ApiException(400, "Missing the required parameter 'jobId' when calling downloadJobOutputFile"));
    }
    // verify the required parameter 'downloadOutputFileRequest' is set
    if (downloadOutputFileRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'downloadOutputFileRequest' when calling downloadJobOutputFile",
        new ApiException(400, "Missing the required parameter 'downloadOutputFileRequest' when calling downloadJobOutputFile"));
    }

    // create path and map variables
    String path = "/jobs/{jobId}/outputfile".replaceAll("\\{format\\}","json").replaceAll("\\{" + "jobId" + "\\}", apiInvoker.escapeString(jobId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Generate new auth token
  * 
   * @param tokenGenerateRequest Auth token details.
   * @return Token
  */
  public Token generateAuthToken (TokenGenerateRequest tokenGenerateRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = tokenGenerateRequest;
    // verify the required parameter 'tokenGenerateRequest' is set
    if (tokenGenerateRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'tokenGenerateRequest' when calling generateAuthToken",
        new ApiException(400, "Missing the required parameter 'tokenGenerateRequest' when calling generateAuthToken"));
    }

    // create path and map variables
    String path = "/auth/token";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Token) ApiInvoker.deserialize(localVarResponse, "", Token.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Generate new auth token
   * 
   * @param tokenGenerateRequest Auth token details.
  */
  public void generateAuthToken (TokenGenerateRequest tokenGenerateRequest, final Response.Listener<Token> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = tokenGenerateRequest;

    // verify the required parameter 'tokenGenerateRequest' is set
    if (tokenGenerateRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'tokenGenerateRequest' when calling generateAuthToken",
        new ApiException(400, "Missing the required parameter 'tokenGenerateRequest' when calling generateAuthToken"));
    }

    // create path and map variables
    String path = "/auth/token".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Token) ApiInvoker.deserialize(localVarResponse,  "", Token.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get a list of all available jobs
  * 
   * @return List<JobEntity>
  */
  public List<JobEntity> getAllJobs () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/jobs";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<JobEntity>) ApiInvoker.deserialize(localVarResponse, "array", JobEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get a list of all available jobs
   * 

  */
  public void getAllJobs (final Response.Listener<List<JobEntity>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/jobs".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<JobEntity>) ApiInvoker.deserialize(localVarResponse,  "array", JobEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the memory mapped array based on the array type.
  * The array is specified through a file path, in the configuration object, during model server deployment.
   * @param accept 
   * @param arrayType The format in which the memory mapped array is returned.
   * @return void
  */
  public void getArray (String accept, String arrayType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accept' is set
    if (accept == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accept' when calling getArray",
        new ApiException(400, "Missing the required parameter 'accept' when calling getArray"));
    }
    // verify the required parameter 'arrayType' is set
    if (arrayType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'arrayType' when calling getArray",
        new ApiException(400, "Missing the required parameter 'arrayType' when calling getArray"));
    }

    // create path and map variables
    String path = "/array/{arrayType}".replaceAll("\\{" + "arrayType" + "\\}", apiInvoker.escapeString(arrayType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    headerParams.put("accept", ApiInvoker.parameterToString(accept));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the memory mapped array based on the array type.
   * The array is specified through a file path, in the configuration object, during model server deployment.
   * @param accept    * @param arrayType The format in which the memory mapped array is returned.
  */
  public void getArray (String accept, String arrayType, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accept' is set
    if (accept == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accept' when calling getArray",
        new ApiException(400, "Missing the required parameter 'accept' when calling getArray"));
    }
    // verify the required parameter 'arrayType' is set
    if (arrayType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'arrayType' when calling getArray",
        new ApiException(400, "Missing the required parameter 'arrayType' when calling getArray"));
    }

    // create path and map variables
    String path = "/array/{arrayType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "arrayType" + "\\}", apiInvoker.escapeString(arrayType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();


    headerParams.put("accept", ApiInvoker.parameterToString(accept));

    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the memory mapped array indices based on the array type.
  * 
   * @param contentType The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;.
   * @param accept 
   * @param arrayType Format in which the memory mapped array is returned in.
   * @param input Input indices array
   * @return void
  */
  public void getArrayIndices (String contentType, String accept, String arrayType, String input) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = input;
    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling getArrayIndices",
        new ApiException(400, "Missing the required parameter 'contentType' when calling getArrayIndices"));
    }
    // verify the required parameter 'accept' is set
    if (accept == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accept' when calling getArrayIndices",
        new ApiException(400, "Missing the required parameter 'accept' when calling getArrayIndices"));
    }
    // verify the required parameter 'arrayType' is set
    if (arrayType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'arrayType' when calling getArrayIndices",
        new ApiException(400, "Missing the required parameter 'arrayType' when calling getArrayIndices"));
    }

    // create path and map variables
    String path = "/array/indices/{arrayType}".replaceAll("\\{" + "arrayType" + "\\}", apiInvoker.escapeString(arrayType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));
    headerParams.put("accept", ApiInvoker.parameterToString(accept));
    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the memory mapped array indices based on the array type.
   * 
   * @param contentType The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;.   * @param accept    * @param arrayType Format in which the memory mapped array is returned in.   * @param input Input indices array
  */
  public void getArrayIndices (String contentType, String accept, String arrayType, String input, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = input;

    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling getArrayIndices",
        new ApiException(400, "Missing the required parameter 'contentType' when calling getArrayIndices"));
    }
    // verify the required parameter 'accept' is set
    if (accept == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accept' when calling getArrayIndices",
        new ApiException(400, "Missing the required parameter 'accept' when calling getArrayIndices"));
    }
    // verify the required parameter 'arrayType' is set
    if (arrayType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'arrayType' when calling getArrayIndices",
        new ApiException(400, "Missing the required parameter 'arrayType' when calling getArrayIndices"));
    }

    // create path and map variables
    String path = "/array/indices/{arrayType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "arrayType" + "\\}", apiInvoker.escapeString(arrayType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();


    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));
    headerParams.put("accept", ApiInvoker.parameterToString(accept));

    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the memory mapped array within a range based on the array type.
  * 
   * @param accept 
   * @param arrayType Format in which the memory mapped array is returned in.
   * @param from 
   * @param to 
   * @return void
  */
  public void getArrayRange (String accept, String arrayType, Integer from, Integer to) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accept' is set
    if (accept == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accept' when calling getArrayRange",
        new ApiException(400, "Missing the required parameter 'accept' when calling getArrayRange"));
    }
    // verify the required parameter 'arrayType' is set
    if (arrayType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'arrayType' when calling getArrayRange",
        new ApiException(400, "Missing the required parameter 'arrayType' when calling getArrayRange"));
    }
    // verify the required parameter 'from' is set
    if (from == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'from' when calling getArrayRange",
        new ApiException(400, "Missing the required parameter 'from' when calling getArrayRange"));
    }
    // verify the required parameter 'to' is set
    if (to == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'to' when calling getArrayRange",
        new ApiException(400, "Missing the required parameter 'to' when calling getArrayRange"));
    }

    // create path and map variables
    String path = "/array/range/{from}/{to}/{arrayType}".replaceAll("\\{" + "arrayType" + "\\}", apiInvoker.escapeString(arrayType.toString())).replaceAll("\\{" + "from" + "\\}", apiInvoker.escapeString(from.toString())).replaceAll("\\{" + "to" + "\\}", apiInvoker.escapeString(to.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    headerParams.put("accept", ApiInvoker.parameterToString(accept));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the memory mapped array within a range based on the array type.
   * 
   * @param accept    * @param arrayType Format in which the memory mapped array is returned in.   * @param from    * @param to 
  */
  public void getArrayRange (String accept, String arrayType, Integer from, Integer to, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accept' is set
    if (accept == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accept' when calling getArrayRange",
        new ApiException(400, "Missing the required parameter 'accept' when calling getArrayRange"));
    }
    // verify the required parameter 'arrayType' is set
    if (arrayType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'arrayType' when calling getArrayRange",
        new ApiException(400, "Missing the required parameter 'arrayType' when calling getArrayRange"));
    }
    // verify the required parameter 'from' is set
    if (from == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'from' when calling getArrayRange",
        new ApiException(400, "Missing the required parameter 'from' when calling getArrayRange"));
    }
    // verify the required parameter 'to' is set
    if (to == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'to' when calling getArrayRange",
        new ApiException(400, "Missing the required parameter 'to' when calling getArrayRange"));
    }

    // create path and map variables
    String path = "/array/range/{from}/{to}/{arrayType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "arrayType" + "\\}", apiInvoker.escapeString(arrayType.toString())).replaceAll("\\{" + "from" + "\\}", apiInvoker.escapeString(from.toString())).replaceAll("\\{" + "to" + "\\}", apiInvoker.escapeString(to.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();


    headerParams.put("accept", ApiInvoker.parameterToString(accept));

    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get auth policy
  * 
   * @return AuthPolicy
  */
  public AuthPolicy getAuthPolicy () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/auth/policy";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AuthPolicy) ApiInvoker.deserialize(localVarResponse, "", AuthPolicy.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get auth policy
   * 

  */
  public void getAuthPolicy (final Response.Listener<AuthPolicy> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/auth/policy".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AuthPolicy) ApiInvoker.deserialize(localVarResponse,  "", AuthPolicy.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets the best model among the given model instance IDs, based on the evaluation type and column metric
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param bestModel Object encapsulating the model ids, eval type and column metric name
   * @return ModelInstanceEntity
  */
  public ModelInstanceEntity getBestModelAmongModelIds (String modelHistoryServerId, BestModel bestModel) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = bestModel;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getBestModelAmongModelIds",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getBestModelAmongModelIds"));
    }
    // verify the required parameter 'bestModel' is set
    if (bestModel == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'bestModel' when calling getBestModelAmongModelIds",
        new ApiException(400, "Missing the required parameter 'bestModel' when calling getBestModelAmongModelIds"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/best".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelInstanceEntity) ApiInvoker.deserialize(localVarResponse, "", ModelInstanceEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets the best model among the given model instance IDs, based on the evaluation type and column metric
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param bestModel Object encapsulating the model ids, eval type and column metric name
  */
  public void getBestModelAmongModelIds (String modelHistoryServerId, BestModel bestModel, final Response.Listener<ModelInstanceEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = bestModel;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getBestModelAmongModelIds",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getBestModelAmongModelIds"));
    }
    // verify the required parameter 'bestModel' is set
    if (bestModel == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'bestModel' when calling getBestModelAmongModelIds",
        new ApiException(400, "Missing the required parameter 'bestModel' when calling getBestModelAmongModelIds"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/best".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelInstanceEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelInstanceEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get credentials given an ID
  * 
   * @param credentialId Credentials ID
   * @return ResourceCredentials
  */
  public ResourceCredentials getCredentialsById (Long credentialId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'credentialId' is set
    if (credentialId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'credentialId' when calling getCredentialsById",
        new ApiException(400, "Missing the required parameter 'credentialId' when calling getCredentialsById"));
    }

    // create path and map variables
    String path = "/resources/credentials/{credentialId}".replaceAll("\\{" + "credentialId" + "\\}", apiInvoker.escapeString(credentialId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ResourceCredentials) ApiInvoker.deserialize(localVarResponse, "", ResourceCredentials.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get credentials given an ID
   * 
   * @param credentialId Credentials ID
  */
  public void getCredentialsById (Long credentialId, final Response.Listener<ResourceCredentials> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'credentialId' is set
    if (credentialId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'credentialId' when calling getCredentialsById",
        new ApiException(400, "Missing the required parameter 'credentialId' when calling getCredentialsById"));
    }

    // create path and map variables
    String path = "/resources/credentials/{credentialId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "credentialId" + "\\}", apiInvoker.escapeString(credentialId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ResourceCredentials) ApiInvoker.deserialize(localVarResponse,  "", ResourceCredentials.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Returns the current model being used for retraining.
  * 
   * @return void
  */
  public void getCurrentModel () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/model";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Returns the current model being used for retraining.
   * 

  */
  public void getCurrentModel (final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/model".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets the list of evaluation results entity, given a model instance ID
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelInstanceID GUID of the model instance to get evaluation results for.
   * @return List<EvaluationResultsEntity>
  */
  public List<EvaluationResultsEntity> getEvaluationForModelID (String modelHistoryServerId, String modelInstanceID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getEvaluationForModelID",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getEvaluationForModelID"));
    }
    // verify the required parameter 'modelInstanceID' is set
    if (modelInstanceID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelInstanceID' when calling getEvaluationForModelID",
        new ApiException(400, "Missing the required parameter 'modelInstanceID' when calling getEvaluationForModelID"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/revisions/evaluations/{modelInstanceID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelInstanceID" + "\\}", apiInvoker.escapeString(modelInstanceID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<EvaluationResultsEntity>) ApiInvoker.deserialize(localVarResponse, "array", EvaluationResultsEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets the list of evaluation results entity, given a model instance ID
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelInstanceID GUID of the model instance to get evaluation results for.
  */
  public void getEvaluationForModelID (String modelHistoryServerId, String modelInstanceID, final Response.Listener<List<EvaluationResultsEntity>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getEvaluationForModelID",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getEvaluationForModelID"));
    }
    // verify the required parameter 'modelInstanceID' is set
    if (modelInstanceID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelInstanceID' when calling getEvaluationForModelID",
        new ApiException(400, "Missing the required parameter 'modelInstanceID' when calling getEvaluationForModelID"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/revisions/evaluations/{modelInstanceID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelInstanceID" + "\\}", apiInvoker.escapeString(modelInstanceID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<EvaluationResultsEntity>) ApiInvoker.deserialize(localVarResponse,  "array", EvaluationResultsEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets all the examples for a minibatch ID
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param minibatchId The GUID of the minibatch
   * @return List<ExampleEntity>
  */
  public List<ExampleEntity> getExamplesForMinibatch (String modelHistoryServerId, String minibatchId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getExamplesForMinibatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getExamplesForMinibatch"));
    }
    // verify the required parameter 'minibatchId' is set
    if (minibatchId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'minibatchId' when calling getExamplesForMinibatch",
        new ApiException(400, "Missing the required parameter 'minibatchId' when calling getExamplesForMinibatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/example/{minibatchId}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "minibatchId" + "\\}", apiInvoker.escapeString(minibatchId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<ExampleEntity>) ApiInvoker.deserialize(localVarResponse, "array", ExampleEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets all the examples for a minibatch ID
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param minibatchId The GUID of the minibatch
  */
  public void getExamplesForMinibatch (String modelHistoryServerId, String minibatchId, final Response.Listener<List<ExampleEntity>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getExamplesForMinibatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getExamplesForMinibatch"));
    }
    // verify the required parameter 'minibatchId' is set
    if (minibatchId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'minibatchId' when calling getExamplesForMinibatch",
        new ApiException(400, "Missing the required parameter 'minibatchId' when calling getExamplesForMinibatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/example/{minibatchId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "minibatchId" + "\\}", apiInvoker.escapeString(minibatchId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<ExampleEntity>) ApiInvoker.deserialize(localVarResponse,  "array", ExampleEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Obtain an experiment&#39;s details, given its ID
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param experimentID the GUID of the experiment to obtain
   * @return ExperimentEntity
  */
  public ExperimentEntity getExperiment (String modelHistoryServerId, String experimentID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getExperiment"));
    }
    // verify the required parameter 'experimentID' is set
    if (experimentID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentID' when calling getExperiment",
        new ApiException(400, "Missing the required parameter 'experimentID' when calling getExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/{experimentID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "experimentID" + "\\}", apiInvoker.escapeString(experimentID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ExperimentEntity) ApiInvoker.deserialize(localVarResponse, "", ExperimentEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Obtain an experiment&#39;s details, given its ID
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param experimentID the GUID of the experiment to obtain
  */
  public void getExperiment (String modelHistoryServerId, String experimentID, final Response.Listener<ExperimentEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getExperiment"));
    }
    // verify the required parameter 'experimentID' is set
    if (experimentID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentID' when calling getExperiment",
        new ApiException(400, "Missing the required parameter 'experimentID' when calling getExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/{experimentID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "experimentID" + "\\}", apiInvoker.escapeString(experimentID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ExperimentEntity) ApiInvoker.deserialize(localVarResponse,  "", ExperimentEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Obtain all experiments for a model history / workspace
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelHistoryID the GUID of the model history / workspace
   * @return List<ExperimentEntity>
  */
  public List<ExperimentEntity> getExperimentsForModelHistory (String modelHistoryServerId, String modelHistoryID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getExperimentsForModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getExperimentsForModelHistory"));
    }
    // verify the required parameter 'modelHistoryID' is set
    if (modelHistoryID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryID' when calling getExperimentsForModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryID' when calling getExperimentsForModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiments/{modelHistoryID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelHistoryID" + "\\}", apiInvoker.escapeString(modelHistoryID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<ExperimentEntity>) ApiInvoker.deserialize(localVarResponse, "array", ExperimentEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Obtain all experiments for a model history / workspace
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelHistoryID the GUID of the model history / workspace
  */
  public void getExperimentsForModelHistory (String modelHistoryServerId, String modelHistoryID, final Response.Listener<List<ExperimentEntity>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getExperimentsForModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getExperimentsForModelHistory"));
    }
    // verify the required parameter 'modelHistoryID' is set
    if (modelHistoryID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryID' when calling getExperimentsForModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryID' when calling getExperimentsForModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiments/{modelHistoryID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelHistoryID" + "\\}", apiInvoker.escapeString(modelHistoryID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<ExperimentEntity>) ApiInvoker.deserialize(localVarResponse,  "array", ExperimentEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get a job by its ID
  * 
   * @param jobIdOrType Job ID
   * @return JobEntity
  */
  public JobEntity getJobById (Long jobIdOrType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'jobIdOrType' is set
    if (jobIdOrType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobIdOrType' when calling getJobById",
        new ApiException(400, "Missing the required parameter 'jobIdOrType' when calling getJobById"));
    }

    // create path and map variables
    String path = "/jobs/{jobIdOrType}".replaceAll("\\{" + "jobIdOrType" + "\\}", apiInvoker.escapeString(jobIdOrType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (JobEntity) ApiInvoker.deserialize(localVarResponse, "", JobEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get a job by its ID
   * 
   * @param jobIdOrType Job ID
  */
  public void getJobById (Long jobIdOrType, final Response.Listener<JobEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'jobIdOrType' is set
    if (jobIdOrType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobIdOrType' when calling getJobById",
        new ApiException(400, "Missing the required parameter 'jobIdOrType' when calling getJobById"));
    }

    // create path and map variables
    String path = "/jobs/{jobIdOrType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "jobIdOrType" + "\\}", apiInvoker.escapeString(jobIdOrType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((JobEntity) ApiInvoker.deserialize(localVarResponse,  "", JobEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the last evaluation specifications from the current model.
  * 
   * @return EvaluationResultsEntity
  */
  public EvaluationResultsEntity getLastEvaluation () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/lastevaluation";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (EvaluationResultsEntity) ApiInvoker.deserialize(localVarResponse, "", EvaluationResultsEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the last evaluation specifications from the current model.
   * 

  */
  public void getLastEvaluation (final Response.Listener<EvaluationResultsEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/lastevaluation".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((EvaluationResultsEntity) ApiInvoker.deserialize(localVarResponse,  "", EvaluationResultsEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets a minibatch for the model
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param minibatchId The GUID of the minibatch
   * @return MinibatchEntity
  */
  public MinibatchEntity getMinibatch (String modelHistoryServerId, String minibatchId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getMinibatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getMinibatch"));
    }
    // verify the required parameter 'minibatchId' is set
    if (minibatchId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'minibatchId' when calling getMinibatch",
        new ApiException(400, "Missing the required parameter 'minibatchId' when calling getMinibatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/minibatch/{minibatchId}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "minibatchId" + "\\}", apiInvoker.escapeString(minibatchId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (MinibatchEntity) ApiInvoker.deserialize(localVarResponse, "", MinibatchEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets a minibatch for the model
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param minibatchId The GUID of the minibatch
  */
  public void getMinibatch (String modelHistoryServerId, String minibatchId, final Response.Listener<MinibatchEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getMinibatch",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getMinibatch"));
    }
    // verify the required parameter 'minibatchId' is set
    if (minibatchId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'minibatchId' when calling getMinibatch",
        new ApiException(400, "Missing the required parameter 'minibatchId' when calling getMinibatch"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/minibatch/{minibatchId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "minibatchId" + "\\}", apiInvoker.escapeString(minibatchId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((MinibatchEntity) ApiInvoker.deserialize(localVarResponse,  "", MinibatchEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get model details
  * 
   * @param deploymentId ID deployment group
   * @param modelId the id of the deployed model
   * @return ModelEntity
  */
  public ModelEntity getModelDetails (String deploymentId, String modelId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling getModelDetails",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling getModelDetails"));
    }
    // verify the required parameter 'modelId' is set
    if (modelId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelId' when calling getModelDetails",
        new ApiException(400, "Missing the required parameter 'modelId' when calling getModelDetails"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model/{modelId}".replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString())).replaceAll("\\{" + "modelId" + "\\}", apiInvoker.escapeString(modelId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelEntity) ApiInvoker.deserialize(localVarResponse, "", ModelEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get model details
   * 
   * @param deploymentId ID deployment group   * @param modelId the id of the deployed model
  */
  public void getModelDetails (String deploymentId, String modelId, final Response.Listener<ModelEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling getModelDetails",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling getModelDetails"));
    }
    // verify the required parameter 'modelId' is set
    if (modelId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelId' when calling getModelDetails",
        new ApiException(400, "Missing the required parameter 'modelId' when calling getModelDetails"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model/{modelId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString())).replaceAll("\\{" + "modelId" + "\\}", apiInvoker.escapeString(modelId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets a model history, given its ID
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelHistoryID GUID of the model history to get information of.
   * @return ModelHistoryEntity
  */
  public ModelHistoryEntity getModelHistory (String modelHistoryServerId, String modelHistoryID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getModelHistory"));
    }
    // verify the required parameter 'modelHistoryID' is set
    if (modelHistoryID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryID' when calling getModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryID' when calling getModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/revision/{modelHistoryID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelHistoryID" + "\\}", apiInvoker.escapeString(modelHistoryID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelHistoryEntity) ApiInvoker.deserialize(localVarResponse, "", ModelHistoryEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets a model history, given its ID
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelHistoryID GUID of the model history to get information of.
  */
  public void getModelHistory (String modelHistoryServerId, String modelHistoryID, final Response.Listener<ModelHistoryEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getModelHistory"));
    }
    // verify the required parameter 'modelHistoryID' is set
    if (modelHistoryID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryID' when calling getModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryID' when calling getModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/revision/{modelHistoryID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelHistoryID" + "\\}", apiInvoker.escapeString(modelHistoryID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelHistoryEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelHistoryEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets a model instance, given its ID
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelInstanceID GUID of the model instance to get information of.
   * @return ModelInstanceEntity
  */
  public ModelInstanceEntity getModelInstance (String modelHistoryServerId, String modelInstanceID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getModelInstance",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getModelInstance"));
    }
    // verify the required parameter 'modelInstanceID' is set
    if (modelInstanceID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelInstanceID' when calling getModelInstance",
        new ApiException(400, "Missing the required parameter 'modelInstanceID' when calling getModelInstance"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/{modelInstanceID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelInstanceID" + "\\}", apiInvoker.escapeString(modelInstanceID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelInstanceEntity) ApiInvoker.deserialize(localVarResponse, "", ModelInstanceEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets a model instance, given its ID
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelInstanceID GUID of the model instance to get information of.
  */
  public void getModelInstance (String modelHistoryServerId, String modelInstanceID, final Response.Listener<ModelInstanceEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getModelInstance",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getModelInstance"));
    }
    // verify the required parameter 'modelInstanceID' is set
    if (modelInstanceID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelInstanceID' when calling getModelInstance",
        new ApiException(400, "Missing the required parameter 'modelInstanceID' when calling getModelInstance"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/model/{modelInstanceID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelInstanceID" + "\\}", apiInvoker.escapeString(modelInstanceID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelInstanceEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelInstanceEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Obtain a list of all the models for an experiment
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param experimentID the GUID of the experiment
   * @return List<ModelInstanceEntity>
  */
  public List<ModelInstanceEntity> getModelsForExperiment (String modelHistoryServerId, String experimentID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getModelsForExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getModelsForExperiment"));
    }
    // verify the required parameter 'experimentID' is set
    if (experimentID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentID' when calling getModelsForExperiment",
        new ApiException(400, "Missing the required parameter 'experimentID' when calling getModelsForExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/{experimentID}/models".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "experimentID" + "\\}", apiInvoker.escapeString(experimentID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<ModelInstanceEntity>) ApiInvoker.deserialize(localVarResponse, "array", ModelInstanceEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Obtain a list of all the models for an experiment
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param experimentID the GUID of the experiment
  */
  public void getModelsForExperiment (String modelHistoryServerId, String experimentID, final Response.Listener<List<ModelInstanceEntity>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling getModelsForExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling getModelsForExperiment"));
    }
    // verify the required parameter 'experimentID' is set
    if (experimentID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentID' when calling getModelsForExperiment",
        new ApiException(400, "Missing the required parameter 'experimentID' when calling getModelsForExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/{experimentID}/models".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "experimentID" + "\\}", apiInvoker.escapeString(experimentID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<ModelInstanceEntity>) ApiInvoker.deserialize(localVarResponse,  "array", ModelInstanceEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the resource with the specified resource ID
  * 
   * @param resourceId ID of the resource
   * @return Resource
  */
  public Resource getResourceById (Long resourceId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling getResourceById",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling getResourceById"));
    }

    // create path and map variables
    String path = "/resources/resource/{resourceId}".replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Resource) ApiInvoker.deserialize(localVarResponse, "", Resource.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the resource with the specified resource ID
   * 
   * @param resourceId ID of the resource
  */
  public void getResourceById (Long resourceId, final Response.Listener<Resource> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling getResourceById",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling getResourceById"));
    }

    // create path and map variables
    String path = "/resources/resource/{resourceId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Resource) ApiInvoker.deserialize(localVarResponse,  "", Resource.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get all the resources with the specified resource subtype
  * 
   * @param resourceSubType Subtype of the resource
   * @return List<Resource>
  */
  public List<Resource> getResourceBySubType (String resourceSubType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceSubType' is set
    if (resourceSubType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceSubType' when calling getResourceBySubType",
        new ApiException(400, "Missing the required parameter 'resourceSubType' when calling getResourceBySubType"));
    }

    // create path and map variables
    String path = "/resources/resources/subtype/{resourceSubType}".replaceAll("\\{" + "resourceSubType" + "\\}", apiInvoker.escapeString(resourceSubType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<Resource>) ApiInvoker.deserialize(localVarResponse, "array", Resource.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get all the resources with the specified resource subtype
   * 
   * @param resourceSubType Subtype of the resource
  */
  public void getResourceBySubType (String resourceSubType, final Response.Listener<List<Resource>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceSubType' is set
    if (resourceSubType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceSubType' when calling getResourceBySubType",
        new ApiException(400, "Missing the required parameter 'resourceSubType' when calling getResourceBySubType"));
    }

    // create path and map variables
    String path = "/resources/resources/subtype/{resourceSubType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceSubType" + "\\}", apiInvoker.escapeString(resourceSubType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<Resource>) ApiInvoker.deserialize(localVarResponse,  "array", Resource.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get all the resources with the specified resource type
  * 
   * @param resourceType Type of the resource
   * @return List<Resource>
  */
  public List<Resource> getResourceByType (String resourceType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceType' is set
    if (resourceType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceType' when calling getResourceByType",
        new ApiException(400, "Missing the required parameter 'resourceType' when calling getResourceByType"));
    }

    // create path and map variables
    String path = "/resources/resources/type/{resourceType}".replaceAll("\\{" + "resourceType" + "\\}", apiInvoker.escapeString(resourceType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<Resource>) ApiInvoker.deserialize(localVarResponse, "array", Resource.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get all the resources with the specified resource type
   * 
   * @param resourceType Type of the resource
  */
  public void getResourceByType (String resourceType, final Response.Listener<List<Resource>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceType' is set
    if (resourceType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceType' when calling getResourceByType",
        new ApiException(400, "Missing the required parameter 'resourceType' when calling getResourceByType"));
    }

    // create path and map variables
    String path = "/resources/resources/type/{resourceType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceType" + "\\}", apiInvoker.escapeString(resourceType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<Resource>) ApiInvoker.deserialize(localVarResponse,  "array", Resource.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the resource details with the specified resource ID
  * Get the details for the resource, for the given ID. Note that a &#39;ResourceDetails&#39; object contains specific information about the resource (such as region for an AWS resource, or URI for a HDFS resource), where as the &#39;Resource&#39; object contains only general information (name, id, type, subtype). 
   * @param resourceId ID of the resource
   * @return Object
  */
  public Object getResourceDetailsById (Long resourceId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling getResourceDetailsById",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling getResourceDetailsById"));
    }

    // create path and map variables
    String path = "/resources/details/{resourceId}".replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Object) ApiInvoker.deserialize(localVarResponse, "", Object.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the resource details with the specified resource ID
   * Get the details for the resource, for the given ID. Note that a &#39;ResourceDetails&#39; object contains specific information about the resource (such as region for an AWS resource, or URI for a HDFS resource), where as the &#39;Resource&#39; object contains only general information (name, id, type, subtype). 
   * @param resourceId ID of the resource
  */
  public void getResourceDetailsById (Long resourceId, final Response.Listener<Object> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceId' is set
    if (resourceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceId' when calling getResourceDetailsById",
        new ApiException(400, "Missing the required parameter 'resourceId' when calling getResourceDetailsById"));
    }

    // create path and map variables
    String path = "/resources/details/{resourceId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceId" + "\\}", apiInvoker.escapeString(resourceId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Object) ApiInvoker.deserialize(localVarResponse,  "", Object.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the resource group with the specified resource group ID
  * 
   * @param resourceGroupId ID of the resource group
   * @return ResourceGroup
  */
  public ResourceGroup getResourceGroupById (Long resourceGroupId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling getResourceGroupById",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling getResourceGroupById"));
    }

    // create path and map variables
    String path = "/resources/group/{resourceGroupId}".replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ResourceGroup) ApiInvoker.deserialize(localVarResponse, "", ResourceGroup.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the resource group with the specified resource group ID
   * 
   * @param resourceGroupId ID of the resource group
  */
  public void getResourceGroupById (Long resourceGroupId, final Response.Listener<ResourceGroup> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling getResourceGroupById",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling getResourceGroupById"));
    }

    // create path and map variables
    String path = "/resources/group/{resourceGroupId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ResourceGroup) ApiInvoker.deserialize(localVarResponse,  "", ResourceGroup.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get a list of all the resource groups
  * 
   * @return List<ResourceGroup>
  */
  public List<ResourceGroup> getResourceGroups () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/resources/groups";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<ResourceGroup>) ApiInvoker.deserialize(localVarResponse, "array", ResourceGroup.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get a list of all the resource groups
   * 

  */
  public void getResourceGroups (final Response.Listener<List<ResourceGroup>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/resources/groups".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<ResourceGroup>) ApiInvoker.deserialize(localVarResponse,  "array", ResourceGroup.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * A list of all known/registered resources, of all types
  * 
   * @return List<Resource>
  */
  public List<Resource> getResources () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/resources/resources";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<Resource>) ApiInvoker.deserialize(localVarResponse, "array", Resource.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * A list of all known/registered resources, of all types
   * 

  */
  public void getResources (final Response.Listener<List<Resource>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/resources/resources".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<Resource>) ApiInvoker.deserialize(localVarResponse,  "array", Resource.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get all resources from a resource group
  * 
   * @param resourceGroupId ID of the resource group
   * @return List<Resource>
  */
  public List<Resource> getResourcesFromGroup (Long resourceGroupId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling getResourcesFromGroup",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling getResourcesFromGroup"));
    }

    // create path and map variables
    String path = "/resources/group/{resourceGroupId}/resources".replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<Resource>) ApiInvoker.deserialize(localVarResponse, "array", Resource.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get all resources from a resource group
   * 
   * @param resourceGroupId ID of the resource group
  */
  public void getResourcesFromGroup (Long resourceGroupId, final Response.Listener<List<Resource>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'resourceGroupId' is set
    if (resourceGroupId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'resourceGroupId' when calling getResourcesFromGroup",
        new ApiException(400, "Missing the required parameter 'resourceGroupId' when calling getResourcesFromGroup"));
    }

    // create path and map variables
    String path = "/resources/group/{resourceGroupId}/resources".replaceAll("\\{format\\}","json").replaceAll("\\{" + "resourceGroupId" + "\\}", apiInvoker.escapeString(resourceGroupId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<Resource>) ApiInvoker.deserialize(localVarResponse,  "array", Resource.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get all roles.
  * 
   * @return List<Role>
  */
  public List<Role> getRoles () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/security/roles";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<Role>) ApiInvoker.deserialize(localVarResponse, "array", Role.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get all roles.
   * 

  */
  public void getRoles (final Response.Listener<List<Role>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/security/roles".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<Role>) ApiInvoker.deserialize(localVarResponse,  "array", Role.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get a user by user ID
  * 
   * @param userId User&#39;s ID
   * @return User
  */
  public User getUser (String userId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'userId' is set
    if (userId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'userId' when calling getUser",
        new ApiException(400, "Missing the required parameter 'userId' when calling getUser"));
    }

    // create path and map variables
    String path = "/user/{userId}".replaceAll("\\{" + "userId" + "\\}", apiInvoker.escapeString(userId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (User) ApiInvoker.deserialize(localVarResponse, "", User.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get a user by user ID
   * 
   * @param userId User&#39;s ID
  */
  public void getUser (String userId, final Response.Listener<User> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'userId' when calling getUser",
        new ApiException(400, "Missing the required parameter 'userId' when calling getUser"));
    }

    // create path and map variables
    String path = "/user/{userId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}", apiInvoker.escapeString(userId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((User) ApiInvoker.deserialize(localVarResponse,  "", User.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get auth tokens for a user.
  * 
   * @param userId User&#39;s ID
   * @param onlyValid True if you only want the valid tokens.
   * @return List<Token>
  */
  public List<Token> getUserAuthTokens (String userId, Boolean onlyValid) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'userId' is set
    if (userId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'userId' when calling getUserAuthTokens",
        new ApiException(400, "Missing the required parameter 'userId' when calling getUserAuthTokens"));
    }

    // create path and map variables
    String path = "/auth/{userId}/tokens".replaceAll("\\{" + "userId" + "\\}", apiInvoker.escapeString(userId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "onlyValid", onlyValid));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<Token>) ApiInvoker.deserialize(localVarResponse, "array", Token.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get auth tokens for a user.
   * 
   * @param userId User&#39;s ID   * @param onlyValid True if you only want the valid tokens.
  */
  public void getUserAuthTokens (String userId, Boolean onlyValid, final Response.Listener<List<Token>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'userId' is set
    if (userId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'userId' when calling getUserAuthTokens",
        new ApiException(400, "Missing the required parameter 'userId' when calling getUserAuthTokens"));
    }

    // create path and map variables
    String path = "/auth/{userId}/tokens".replaceAll("\\{format\\}","json").replaceAll("\\{" + "userId" + "\\}", apiInvoker.escapeString(userId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "onlyValid", onlyValid));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<Token>) ApiInvoker.deserialize(localVarResponse,  "array", Token.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get all users.
  * 
   * @return List<User>
  */
  public List<User> getUsers () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/security/users";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<User>) ApiInvoker.deserialize(localVarResponse, "array", User.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get all users.
   * 

  */
  public void getUsers (final Response.Listener<List<User>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/security/users".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<User>) ApiInvoker.deserialize(localVarResponse,  "array", User.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the retraining status
  * 
   * @return RetrainingStatus
  */
  public RetrainingStatus isTraining () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/istraining";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (RetrainingStatus) ApiInvoker.deserialize(localVarResponse, "", RetrainingStatus.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the retraining status
   * 

  */
  public void isTraining (final Response.Listener<RetrainingStatus> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/istraining".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((RetrainingStatus) ApiInvoker.deserialize(localVarResponse,  "", RetrainingStatus.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Run inference on the input and returns it as a JsonArrayResponse
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body The input NDArray
   * @return JsonArrayResponse
  */
  public JsonArrayResponse jsonarray (String deploymentName, String versionName, String modelName, Prediction body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling jsonarray",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling jsonarray"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling jsonarray",
        new ApiException(400, "Missing the required parameter 'versionName' when calling jsonarray"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling jsonarray",
        new ApiException(400, "Missing the required parameter 'modelName' when calling jsonarray"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling jsonarray",
        new ApiException(400, "Missing the required parameter 'body' when calling jsonarray"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/jsonarray".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (JsonArrayResponse) ApiInvoker.deserialize(localVarResponse, "", JsonArrayResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Run inference on the input and returns it as a JsonArrayResponse
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body The input NDArray
  */
  public void jsonarray (String deploymentName, String versionName, String modelName, Prediction body, final Response.Listener<JsonArrayResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling jsonarray",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling jsonarray"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling jsonarray",
        new ApiException(400, "Missing the required parameter 'versionName' when calling jsonarray"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling jsonarray",
        new ApiException(400, "Missing the required parameter 'modelName' when calling jsonarray"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling jsonarray",
        new ApiException(400, "Missing the required parameter 'body' when calling jsonarray"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/jsonarray".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((JsonArrayResponse) ApiInvoker.deserialize(localVarResponse,  "", JsonArrayResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Runs knn on the given index with the given k
  * Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param knnName ID or name of the deployed knn
   * @param body 
   * @return NearestNeighborsResults
  */
  public NearestNeighborsResults knn (String deploymentName, String versionName, String knnName, NearestNeighborRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling knn",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling knn"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling knn",
        new ApiException(400, "Missing the required parameter 'versionName' when calling knn"));
    }
    // verify the required parameter 'knnName' is set
    if (knnName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'knnName' when calling knn",
        new ApiException(400, "Missing the required parameter 'knnName' when calling knn"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling knn",
        new ApiException(400, "Missing the required parameter 'body' when calling knn"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knn".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "knnName" + "\\}", apiInvoker.escapeString(knnName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NearestNeighborsResults) ApiInvoker.deserialize(localVarResponse, "", NearestNeighborsResults.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Runs knn on the given index with the given k
   * Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param knnName ID or name of the deployed knn   * @param body 
  */
  public void knn (String deploymentName, String versionName, String knnName, NearestNeighborRequest body, final Response.Listener<NearestNeighborsResults> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling knn",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling knn"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling knn",
        new ApiException(400, "Missing the required parameter 'versionName' when calling knn"));
    }
    // verify the required parameter 'knnName' is set
    if (knnName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'knnName' when calling knn",
        new ApiException(400, "Missing the required parameter 'knnName' when calling knn"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling knn",
        new ApiException(400, "Missing the required parameter 'body' when calling knn"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knn".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "knnName" + "\\}", apiInvoker.escapeString(knnName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NearestNeighborsResults) ApiInvoker.deserialize(localVarResponse,  "", NearestNeighborsResults.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Run a k nearest neighbors search on a NEW data point
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param knnName ID or name of the deployed knn
   * @param body The input NDArray
   * @return NearestNeighborsResults
  */
  public NearestNeighborsResults knnnew (String deploymentName, String versionName, String knnName, Base64NDArrayBodyKNN body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling knnnew",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling knnnew"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling knnnew",
        new ApiException(400, "Missing the required parameter 'versionName' when calling knnnew"));
    }
    // verify the required parameter 'knnName' is set
    if (knnName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'knnName' when calling knnnew",
        new ApiException(400, "Missing the required parameter 'knnName' when calling knnnew"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling knnnew",
        new ApiException(400, "Missing the required parameter 'body' when calling knnnew"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knnnew".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "knnName" + "\\}", apiInvoker.escapeString(knnName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NearestNeighborsResults) ApiInvoker.deserialize(localVarResponse, "", NearestNeighborsResults.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Run a k nearest neighbors search on a NEW data point
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param knnName ID or name of the deployed knn   * @param body The input NDArray
  */
  public void knnnew (String deploymentName, String versionName, String knnName, Base64NDArrayBodyKNN body, final Response.Listener<NearestNeighborsResults> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling knnnew",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling knnnew"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling knnnew",
        new ApiException(400, "Missing the required parameter 'versionName' when calling knnnew"));
    }
    // verify the required parameter 'knnName' is set
    if (knnName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'knnName' when calling knnnew",
        new ApiException(400, "Missing the required parameter 'knnName' when calling knnnew"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling knnnew",
        new ApiException(400, "Missing the required parameter 'body' when calling knnnew"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knnnew".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "knnName" + "\\}", apiInvoker.escapeString(knnName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NearestNeighborsResults) ApiInvoker.deserialize(localVarResponse,  "", NearestNeighborsResults.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * List all of the experiments in every model history / workspace
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @return List<ExperimentEntity>
  */
  public List<ExperimentEntity> listAllExperiments (String modelHistoryServerId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling listAllExperiments",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling listAllExperiments"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiments".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<ExperimentEntity>) ApiInvoker.deserialize(localVarResponse, "array", ExperimentEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * List all of the experiments in every model history / workspace
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
  */
  public void listAllExperiments (String modelHistoryServerId, final Response.Listener<List<ExperimentEntity>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling listAllExperiments",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling listAllExperiments"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiments".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<ExperimentEntity>) ApiInvoker.deserialize(localVarResponse,  "array", ExperimentEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get logs file path
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @return String
  */
  public String logfilepath (String deploymentName, String versionName, String modelName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling logfilepath",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling logfilepath"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling logfilepath",
        new ApiException(400, "Missing the required parameter 'versionName' when calling logfilepath"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling logfilepath",
        new ApiException(400, "Missing the required parameter 'modelName' when calling logfilepath"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/logfilepath".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (String) ApiInvoker.deserialize(localVarResponse, "", String.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get logs file path
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model
  */
  public void logfilepath (String deploymentName, String versionName, String modelName, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling logfilepath",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling logfilepath"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling logfilepath",
        new ApiException(400, "Missing the required parameter 'versionName' when calling logfilepath"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling logfilepath",
        new ApiException(400, "Missing the required parameter 'modelName' when calling logfilepath"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/logfilepath".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((String) ApiInvoker.deserialize(localVarResponse,  "", String.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Post JSON credentials and obtain a JWT authorization token.
  * 
   * @param loginRequest Login credentials.
   * @return LoginResponse
  */
  public LoginResponse login (LoginRequest loginRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = loginRequest;
    // verify the required parameter 'loginRequest' is set
    if (loginRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'loginRequest' when calling login",
        new ApiException(400, "Missing the required parameter 'loginRequest' when calling login"));
    }

    // create path and map variables
    String path = "/login";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (LoginResponse) ApiInvoker.deserialize(localVarResponse, "", LoginResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Post JSON credentials and obtain a JWT authorization token.
   * 
   * @param loginRequest Login credentials.
  */
  public void login (LoginRequest loginRequest, final Response.Listener<LoginResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = loginRequest;

    // verify the required parameter 'loginRequest' is set
    if (loginRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'loginRequest' when calling login",
        new ApiException(400, "Missing the required parameter 'loginRequest' when calling login"));
    }

    // create path and map variables
    String path = "/login".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((LoginResponse) ApiInvoker.deserialize(localVarResponse,  "", LoginResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get logs
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param logRequest The log object
   * @return LogBatch
  */
  public LogBatch logs (String deploymentName, String versionName, String modelName, LogRequest logRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = logRequest;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling logs",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling logs"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling logs",
        new ApiException(400, "Missing the required parameter 'versionName' when calling logs"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling logs",
        new ApiException(400, "Missing the required parameter 'modelName' when calling logs"));
    }
    // verify the required parameter 'logRequest' is set
    if (logRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'logRequest' when calling logs",
        new ApiException(400, "Missing the required parameter 'logRequest' when calling logs"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/logs".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (LogBatch) ApiInvoker.deserialize(localVarResponse, "", LogBatch.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get logs
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param logRequest The log object
  */
  public void logs (String deploymentName, String versionName, String modelName, LogRequest logRequest, final Response.Listener<LogBatch> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = logRequest;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling logs",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling logs"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling logs",
        new ApiException(400, "Missing the required parameter 'versionName' when calling logs"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling logs",
        new ApiException(400, "Missing the required parameter 'modelName' when calling logs"));
    }
    // verify the required parameter 'logRequest' is set
    if (logRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'logRequest' when calling logs",
        new ApiException(400, "Missing the required parameter 'logRequest' when calling logs"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/logs".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((LogBatch) ApiInvoker.deserialize(localVarResponse,  "", LogBatch.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * this method can be used to get the meta data for the current model which set to the server
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @return Object
  */
  public Object metaGet (String deploymentName, String versionName, String modelName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling metaGet",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling metaGet"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling metaGet",
        new ApiException(400, "Missing the required parameter 'versionName' when calling metaGet"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling metaGet",
        new ApiException(400, "Missing the required parameter 'modelName' when calling metaGet"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Object) ApiInvoker.deserialize(localVarResponse, "", Object.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * this method can be used to get the meta data for the current model which set to the server
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model
  */
  public void metaGet (String deploymentName, String versionName, String modelName, final Response.Listener<Object> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling metaGet",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling metaGet"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling metaGet",
        new ApiException(400, "Missing the required parameter 'versionName' when calling metaGet"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling metaGet",
        new ApiException(400, "Missing the required parameter 'modelName' when calling metaGet"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Object) ApiInvoker.deserialize(localVarResponse,  "", Object.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * This method can be used to set meta data for the current model which is set to the server
  * 
   * @param contentType The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body the meta data object
   * @return Object
  */
  public Object metaPost (String contentType, String deploymentName, String versionName, String modelName, String body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'contentType' when calling metaPost"));
    }
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling metaPost"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'versionName' when calling metaPost"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'modelName' when calling metaPost"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'body' when calling metaPost"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));
    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Object) ApiInvoker.deserialize(localVarResponse, "", Object.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * This method can be used to set meta data for the current model which is set to the server
   * 
   * @param contentType The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body the meta data object
  */
  public void metaPost (String contentType, String deploymentName, String versionName, String modelName, String body, final Response.Listener<Object> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'contentType' when calling metaPost"));
    }
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling metaPost"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'versionName' when calling metaPost"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'modelName' when calling metaPost"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling metaPost",
        new ApiException(400, "Missing the required parameter 'body' when calling metaPost"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();


    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));

    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Object) ApiInvoker.deserialize(localVarResponse,  "", Object.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Modify the state (start/stop) of a deployed model
  * 
   * @param deploymentId ID deployment group
   * @param modelId the id of the deployed model
   * @param body the model state object
   * @return ModelEntity
  */
  public ModelEntity modelStateChange (String deploymentId, String modelId, SetState body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling modelStateChange",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling modelStateChange"));
    }
    // verify the required parameter 'modelId' is set
    if (modelId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelId' when calling modelStateChange",
        new ApiException(400, "Missing the required parameter 'modelId' when calling modelStateChange"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling modelStateChange",
        new ApiException(400, "Missing the required parameter 'body' when calling modelStateChange"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model/{modelId}/state".replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString())).replaceAll("\\{" + "modelId" + "\\}", apiInvoker.escapeString(modelId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelEntity) ApiInvoker.deserialize(localVarResponse, "", ModelEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Modify the state (start/stop) of a deployed model
   * 
   * @param deploymentId ID deployment group   * @param modelId the id of the deployed model   * @param body the model state object
  */
  public void modelStateChange (String deploymentId, String modelId, SetState body, final Response.Listener<ModelEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling modelStateChange",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling modelStateChange"));
    }
    // verify the required parameter 'modelId' is set
    if (modelId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelId' when calling modelStateChange",
        new ApiException(400, "Missing the required parameter 'modelId' when calling modelStateChange"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling modelStateChange",
        new ApiException(400, "Missing the required parameter 'body' when calling modelStateChange"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model/{modelId}/state".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString())).replaceAll("\\{" + "modelId" + "\\}", apiInvoker.escapeString(modelId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Retrieve a list of all the deployed models given a deployment id
  * 
   * @param deploymentId ID deployment group
   * @return List<ModelEntity>
  */
  public List<ModelEntity> models (String deploymentId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling models",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling models"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/models".replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<ModelEntity>) ApiInvoker.deserialize(localVarResponse, "array", ModelEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Retrieve a list of all the deployed models given a deployment id
   * 
   * @param deploymentId ID deployment group
  */
  public void models (String deploymentId, final Response.Listener<List<ModelEntity>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling models",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling models"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/models".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<ModelEntity>) ApiInvoker.deserialize(localVarResponse,  "array", ModelEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Set the model to be served
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param file The model file to upload (.pb file)
   * @return ModelStatus
  */
  public ModelStatus modelset (String deploymentName, String versionName, String modelName, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling modelset",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling modelset"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling modelset",
        new ApiException(400, "Missing the required parameter 'versionName' when calling modelset"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling modelset",
        new ApiException(400, "Missing the required parameter 'modelName' when calling modelset"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelset".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelStatus) ApiInvoker.deserialize(localVarResponse, "", ModelStatus.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Set the model to be served
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param file The model file to upload (.pb file)
  */
  public void modelset (String deploymentName, String versionName, String modelName, File file, final Response.Listener<ModelStatus> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling modelset",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling modelset"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling modelset",
        new ApiException(400, "Missing the required parameter 'versionName' when calling modelset"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling modelset",
        new ApiException(400, "Missing the required parameter 'modelName' when calling modelset"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelset".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelStatus) ApiInvoker.deserialize(localVarResponse,  "", ModelStatus.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update the model to be served
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param file The model file to update with (.pb file)
   * @return ModelStatus
  */
  public ModelStatus modelupdate (String deploymentName, String versionName, String modelName, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling modelupdate",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling modelupdate"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling modelupdate",
        new ApiException(400, "Missing the required parameter 'versionName' when calling modelupdate"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling modelupdate",
        new ApiException(400, "Missing the required parameter 'modelName' when calling modelupdate"));
    }
    // verify the required parameter 'file' is set
    if (file == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'file' when calling modelupdate",
        new ApiException(400, "Missing the required parameter 'file' when calling modelupdate"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelupdate".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelStatus) ApiInvoker.deserialize(localVarResponse, "", ModelStatus.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update the model to be served
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param file The model file to update with (.pb file)
  */
  public void modelupdate (String deploymentName, String versionName, String modelName, File file, final Response.Listener<ModelStatus> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling modelupdate",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling modelupdate"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling modelupdate",
        new ApiException(400, "Missing the required parameter 'versionName' when calling modelupdate"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling modelupdate",
        new ApiException(400, "Missing the required parameter 'modelName' when calling modelupdate"));
    }
    // verify the required parameter 'file' is set
    if (file == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'file' when calling modelupdate",
        new ApiException(400, "Missing the required parameter 'file' when calling modelupdate"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelupdate".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelStatus) ApiInvoker.deserialize(localVarResponse,  "", ModelStatus.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Represents all of the labels for a given classification
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body The input NDArray
   * @return MultiClassClassificationResult
  */
  public MultiClassClassificationResult multiclassify (String deploymentName, String versionName, String modelName, Prediction body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling multiclassify",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling multiclassify"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling multiclassify",
        new ApiException(400, "Missing the required parameter 'versionName' when calling multiclassify"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling multiclassify",
        new ApiException(400, "Missing the required parameter 'modelName' when calling multiclassify"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling multiclassify",
        new ApiException(400, "Missing the required parameter 'body' when calling multiclassify"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/multiclassify".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (MultiClassClassificationResult) ApiInvoker.deserialize(localVarResponse, "", MultiClassClassificationResult.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Represents all of the labels for a given classification
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body The input NDArray
  */
  public void multiclassify (String deploymentName, String versionName, String modelName, Prediction body, final Response.Listener<MultiClassClassificationResult> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling multiclassify",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling multiclassify"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling multiclassify",
        new ApiException(400, "Missing the required parameter 'versionName' when calling multiclassify"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling multiclassify",
        new ApiException(400, "Missing the required parameter 'modelName' when calling multiclassify"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling multiclassify",
        new ApiException(400, "Missing the required parameter 'body' when calling multiclassify"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/multiclassify".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((MultiClassClassificationResult) ApiInvoker.deserialize(localVarResponse,  "", MultiClassClassificationResult.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the output from the network, based on the given INDArray[] input
  * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body The multiple input arrays with mask inputs to run inferences on
   * @return MultiPredictResponse
  */
  public MultiPredictResponse multipredict (String deploymentName, String versionName, String modelName, MultiPredictRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling multipredict",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling multipredict"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling multipredict",
        new ApiException(400, "Missing the required parameter 'versionName' when calling multipredict"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling multipredict",
        new ApiException(400, "Missing the required parameter 'modelName' when calling multipredict"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling multipredict",
        new ApiException(400, "Missing the required parameter 'body' when calling multipredict"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredict".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (MultiPredictResponse) ApiInvoker.deserialize(localVarResponse, "", MultiPredictResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the output from the network, based on the given INDArray[] input
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body The multiple input arrays with mask inputs to run inferences on
  */
  public void multipredict (String deploymentName, String versionName, String modelName, MultiPredictRequest body, final Response.Listener<MultiPredictResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling multipredict",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling multipredict"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling multipredict",
        new ApiException(400, "Missing the required parameter 'versionName' when calling multipredict"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling multipredict",
        new ApiException(400, "Missing the required parameter 'modelName' when calling multipredict"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling multipredict",
        new ApiException(400, "Missing the required parameter 'body' when calling multipredict"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredict".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((MultiPredictResponse) ApiInvoker.deserialize(localVarResponse,  "", MultiPredictResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get the output from the network using the given image file using the /multipredict endpoint&#39;s method
  * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param file The image file to run the prediction on
   * @param id The id of the request (could be self generated)
   * @param needsPreprocessing Whether or not the preprocessing is required (either &#39;true&#39; or &#39;false&#39;)
   * @return MultiPredictResponse
  */
  public MultiPredictResponse multipredictimage (String deploymentName, String versionName, String modelName, File file, String id, Boolean needsPreprocessing) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling multipredictimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling multipredictimage"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'modelName' when calling multipredictimage"));
    }
    // verify the required parameter 'file' is set
    if (file == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'file' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'file' when calling multipredictimage"));
    }
    // verify the required parameter 'id' is set
    if (id == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'id' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'id' when calling multipredictimage"));
    }
    // verify the required parameter 'needsPreprocessing' is set
    if (needsPreprocessing == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'needsPreprocessing' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'needsPreprocessing' when calling multipredictimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredictimage".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      if (id != null) {
        localVarBuilder.addTextBody("id", ApiInvoker.parameterToString(id), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      if (needsPreprocessing != null) {
        localVarBuilder.addTextBody("needs_preprocessing", ApiInvoker.parameterToString(needsPreprocessing), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      formParams.put("id", ApiInvoker.parameterToString(id));
      formParams.put("needs_preprocessing", ApiInvoker.parameterToString(needsPreprocessing));
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (MultiPredictResponse) ApiInvoker.deserialize(localVarResponse, "", MultiPredictResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get the output from the network using the given image file using the /multipredict endpoint&#39;s method
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param file The image file to run the prediction on   * @param id The id of the request (could be self generated)   * @param needsPreprocessing Whether or not the preprocessing is required (either &#39;true&#39; or &#39;false&#39;)
  */
  public void multipredictimage (String deploymentName, String versionName, String modelName, File file, String id, Boolean needsPreprocessing, final Response.Listener<MultiPredictResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling multipredictimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling multipredictimage"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'modelName' when calling multipredictimage"));
    }
    // verify the required parameter 'file' is set
    if (file == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'file' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'file' when calling multipredictimage"));
    }
    // verify the required parameter 'id' is set
    if (id == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'id' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'id' when calling multipredictimage"));
    }
    // verify the required parameter 'needsPreprocessing' is set
    if (needsPreprocessing == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'needsPreprocessing' when calling multipredictimage",
        new ApiException(400, "Missing the required parameter 'needsPreprocessing' when calling multipredictimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredictimage".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      
      if (id != null) {
        localVarBuilder.addTextBody("id", ApiInvoker.parameterToString(id), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      
      if (needsPreprocessing != null) {
        localVarBuilder.addTextBody("needs_preprocessing", ApiInvoker.parameterToString(needsPreprocessing), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
formParams.put("id", ApiInvoker.parameterToString(id));
formParams.put("needs_preprocessing", ApiInvoker.parameterToString(needsPreprocessing));
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((MultiPredictResponse) ApiInvoker.deserialize(localVarResponse,  "", MultiPredictResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets the number of retrained models written with retraining.
  * 
   * @return RevisionsWritten
  */
  public RevisionsWritten numRevisions () throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/numrevisions";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (RevisionsWritten) ApiInvoker.deserialize(localVarResponse, "", RevisionsWritten.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets the number of retrained models written with retraining.
   * 

  */
  public void numRevisions (final Response.Listener<RevisionsWritten> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/numrevisions".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((RevisionsWritten) ApiInvoker.deserialize(localVarResponse,  "", RevisionsWritten.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Run inference on the input array.
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body The input NDArray
   * @return Prediction
  */
  public Prediction predict (String deploymentName, String versionName, String modelName, Prediction body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling predict",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling predict"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling predict",
        new ApiException(400, "Missing the required parameter 'versionName' when calling predict"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling predict",
        new ApiException(400, "Missing the required parameter 'modelName' when calling predict"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling predict",
        new ApiException(400, "Missing the required parameter 'body' when calling predict"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/predict".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Prediction) ApiInvoker.deserialize(localVarResponse, "", Prediction.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Run inference on the input array.
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body The input NDArray
  */
  public void predict (String deploymentName, String versionName, String modelName, Prediction body, final Response.Listener<Prediction> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling predict",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling predict"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling predict",
        new ApiException(400, "Missing the required parameter 'versionName' when calling predict"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling predict",
        new ApiException(400, "Missing the required parameter 'modelName' when calling predict"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling predict",
        new ApiException(400, "Missing the required parameter 'body' when calling predict"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/predict".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Prediction) ApiInvoker.deserialize(localVarResponse,  "", Prediction.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Runs inference and find invalid rows based on the input data. Output is defined relative to the output adapter specified.
  * These \&quot;error\&quot; endpoints are slower for inference, but will also ignore invalid rows that are found. They will output skipped rows where errors were encountered so users can fix problems with input data pipelines. 
   * @param contentType The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;.
   * @param operation Operation to perform on the input data.
   * @param inputType Type of the input data.
   * @param inputData 
   * @return void
  */
  public void predictError (String contentType, String operation, String inputType, String inputData) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = inputData;
    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling predictError",
        new ApiException(400, "Missing the required parameter 'contentType' when calling predictError"));
    }
    // verify the required parameter 'operation' is set
    if (operation == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'operation' when calling predictError",
        new ApiException(400, "Missing the required parameter 'operation' when calling predictError"));
    }
    // verify the required parameter 'inputType' is set
    if (inputType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputType' when calling predictError",
        new ApiException(400, "Missing the required parameter 'inputType' when calling predictError"));
    }

    // create path and map variables
    String path = "/{operation}/{inputType}/error".replaceAll("\\{" + "operation" + "\\}", apiInvoker.escapeString(operation.toString())).replaceAll("\\{" + "inputType" + "\\}", apiInvoker.escapeString(inputType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));
    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Runs inference and find invalid rows based on the input data. Output is defined relative to the output adapter specified.
   * These \&quot;error\&quot; endpoints are slower for inference, but will also ignore invalid rows that are found. They will output skipped rows where errors were encountered so users can fix problems with input data pipelines. 
   * @param contentType The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;.   * @param operation Operation to perform on the input data.   * @param inputType Type of the input data.   * @param inputData 
  */
  public void predictError (String contentType, String operation, String inputType, String inputData, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = inputData;

    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling predictError",
        new ApiException(400, "Missing the required parameter 'contentType' when calling predictError"));
    }
    // verify the required parameter 'operation' is set
    if (operation == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'operation' when calling predictError",
        new ApiException(400, "Missing the required parameter 'operation' when calling predictError"));
    }
    // verify the required parameter 'inputType' is set
    if (inputType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputType' when calling predictError",
        new ApiException(400, "Missing the required parameter 'inputType' when calling predictError"));
    }

    // create path and map variables
    String path = "/{operation}/{inputType}/error".replaceAll("\\{format\\}","json").replaceAll("\\{" + "operation" + "\\}", apiInvoker.escapeString(operation.toString())).replaceAll("\\{" + "inputType" + "\\}", apiInvoker.escapeString(inputType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();


    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));

    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Runs inference based on the input data. Output is defined relative to the output adapter specified.
  * 
   * @param operation The operation to perform on the input data. 
   * @param inputTypeFile Type of the input data. 
   * @param inputData The input data to run inference on.
   * @return void
  */
  public void predictV2File (String operation, String inputTypeFile, File inputData) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'operation' is set
    if (operation == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'operation' when calling predictV2File",
        new ApiException(400, "Missing the required parameter 'operation' when calling predictV2File"));
    }
    // verify the required parameter 'inputTypeFile' is set
    if (inputTypeFile == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputTypeFile' when calling predictV2File",
        new ApiException(400, "Missing the required parameter 'inputTypeFile' when calling predictV2File"));
    }
    // verify the required parameter 'inputData' is set
    if (inputData == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputData' when calling predictV2File",
        new ApiException(400, "Missing the required parameter 'inputData' when calling predictV2File"));
    }

    // create path and map variables
    String path = "/{operation}/{inputTypeFile}".replaceAll("\\{" + "operation" + "\\}", apiInvoker.escapeString(operation.toString())).replaceAll("\\{" + "inputTypeFile" + "\\}", apiInvoker.escapeString(inputTypeFile.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (inputData != null) {
        localVarBuilder.addBinaryBody("inputData", inputData);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified.
   * 
   * @param operation The operation to perform on the input data.    * @param inputTypeFile Type of the input data.    * @param inputData The input data to run inference on.
  */
  public void predictV2File (String operation, String inputTypeFile, File inputData, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'operation' is set
    if (operation == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'operation' when calling predictV2File",
        new ApiException(400, "Missing the required parameter 'operation' when calling predictV2File"));
    }
    // verify the required parameter 'inputTypeFile' is set
    if (inputTypeFile == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputTypeFile' when calling predictV2File",
        new ApiException(400, "Missing the required parameter 'inputTypeFile' when calling predictV2File"));
    }
    // verify the required parameter 'inputData' is set
    if (inputData == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputData' when calling predictV2File",
        new ApiException(400, "Missing the required parameter 'inputData' when calling predictV2File"));
    }

    // create path and map variables
    String path = "/{operation}/{inputTypeFile}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "operation" + "\\}", apiInvoker.escapeString(operation.toString())).replaceAll("\\{" + "inputTypeFile" + "\\}", apiInvoker.escapeString(inputTypeFile.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (inputData != null) {
        localVarBuilder.addBinaryBody("inputData", inputData);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Runs inference based on the input data. Output is defined relative to the output adapter specified.
  * 
   * @param contentType The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;.
   * @param operation The operation to perform on the input data. 
   * @param inputTypeJson Type of the input data. 
   * @param inputData The input data to run inference on. (Specify a JSON string here)
   * @return void
  */
  public void predictV2Json (String contentType, String operation, String inputTypeJson, String inputData) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = inputData;
    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling predictV2Json",
        new ApiException(400, "Missing the required parameter 'contentType' when calling predictV2Json"));
    }
    // verify the required parameter 'operation' is set
    if (operation == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'operation' when calling predictV2Json",
        new ApiException(400, "Missing the required parameter 'operation' when calling predictV2Json"));
    }
    // verify the required parameter 'inputTypeJson' is set
    if (inputTypeJson == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputTypeJson' when calling predictV2Json",
        new ApiException(400, "Missing the required parameter 'inputTypeJson' when calling predictV2Json"));
    }
    // verify the required parameter 'inputData' is set
    if (inputData == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputData' when calling predictV2Json",
        new ApiException(400, "Missing the required parameter 'inputData' when calling predictV2Json"));
    }

    // create path and map variables
    String path = "/{operation}/{inputTypeJson}".replaceAll("\\{" + "operation" + "\\}", apiInvoker.escapeString(operation.toString())).replaceAll("\\{" + "inputTypeJson" + "\\}", apiInvoker.escapeString(inputTypeJson.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));
    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified.
   * 
   * @param contentType The &#x60;Content-Type&#x60; should always be &#x60;application/json&#x60;.   * @param operation The operation to perform on the input data.    * @param inputTypeJson Type of the input data.    * @param inputData The input data to run inference on. (Specify a JSON string here)
  */
  public void predictV2Json (String contentType, String operation, String inputTypeJson, String inputData, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = inputData;

    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling predictV2Json",
        new ApiException(400, "Missing the required parameter 'contentType' when calling predictV2Json"));
    }
    // verify the required parameter 'operation' is set
    if (operation == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'operation' when calling predictV2Json",
        new ApiException(400, "Missing the required parameter 'operation' when calling predictV2Json"));
    }
    // verify the required parameter 'inputTypeJson' is set
    if (inputTypeJson == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputTypeJson' when calling predictV2Json",
        new ApiException(400, "Missing the required parameter 'inputTypeJson' when calling predictV2Json"));
    }
    // verify the required parameter 'inputData' is set
    if (inputData == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputData' when calling predictV2Json",
        new ApiException(400, "Missing the required parameter 'inputData' when calling predictV2Json"));
    }

    // create path and map variables
    String path = "/{operation}/{inputTypeJson}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "operation" + "\\}", apiInvoker.escapeString(operation.toString())).replaceAll("\\{" + "inputTypeJson" + "\\}", apiInvoker.escapeString(inputTypeJson.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();


    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));

    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Run inference on the input array, using input image file from multipart form data.
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param image The file to upload.
   * @return Prediction
  */
  public Prediction predictimage (String deploymentName, String versionName, String modelName, File image) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling predictimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling predictimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling predictimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling predictimage"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling predictimage",
        new ApiException(400, "Missing the required parameter 'modelName' when calling predictimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictimage".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (image != null) {
        localVarBuilder.addBinaryBody("image", image);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Prediction) ApiInvoker.deserialize(localVarResponse, "", Prediction.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Run inference on the input array, using input image file from multipart form data.
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param image The file to upload.
  */
  public void predictimage (String deploymentName, String versionName, String modelName, File image, final Response.Listener<Prediction> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling predictimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling predictimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling predictimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling predictimage"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling predictimage",
        new ApiException(400, "Missing the required parameter 'modelName' when calling predictimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictimage".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (image != null) {
        localVarBuilder.addBinaryBody("image", image);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Prediction) ApiInvoker.deserialize(localVarResponse,  "", Prediction.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Preprocesses the input and run inference on it
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body The input array
   * @return Prediction
  */
  public Prediction predictwithpreprocess (String deploymentName, String versionName, String modelName, List<String> body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling predictwithpreprocess",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling predictwithpreprocess"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling predictwithpreprocess",
        new ApiException(400, "Missing the required parameter 'versionName' when calling predictwithpreprocess"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling predictwithpreprocess",
        new ApiException(400, "Missing the required parameter 'modelName' when calling predictwithpreprocess"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling predictwithpreprocess",
        new ApiException(400, "Missing the required parameter 'body' when calling predictwithpreprocess"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocess".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Prediction) ApiInvoker.deserialize(localVarResponse, "", Prediction.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Preprocesses the input and run inference on it
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body The input array
  */
  public void predictwithpreprocess (String deploymentName, String versionName, String modelName, List<String> body, final Response.Listener<Prediction> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling predictwithpreprocess",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling predictwithpreprocess"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling predictwithpreprocess",
        new ApiException(400, "Missing the required parameter 'versionName' when calling predictwithpreprocess"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling predictwithpreprocess",
        new ApiException(400, "Missing the required parameter 'modelName' when calling predictwithpreprocess"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling predictwithpreprocess",
        new ApiException(400, "Missing the required parameter 'body' when calling predictwithpreprocess"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocess".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Prediction) ApiInvoker.deserialize(localVarResponse,  "", Prediction.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Preprocesses the input and run inference on it and returns it as a JsonArrayResponse
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param modelName ID or name of the deployed model
   * @param body The input array
   * @return JsonArrayResponse
  */
  public JsonArrayResponse predictwithpreprocessjson (String deploymentName, String versionName, String modelName, List<String> body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling predictwithpreprocessjson",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling predictwithpreprocessjson"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling predictwithpreprocessjson",
        new ApiException(400, "Missing the required parameter 'versionName' when calling predictwithpreprocessjson"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling predictwithpreprocessjson",
        new ApiException(400, "Missing the required parameter 'modelName' when calling predictwithpreprocessjson"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling predictwithpreprocessjson",
        new ApiException(400, "Missing the required parameter 'body' when calling predictwithpreprocessjson"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocessjson".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (JsonArrayResponse) ApiInvoker.deserialize(localVarResponse, "", JsonArrayResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Preprocesses the input and run inference on it and returns it as a JsonArrayResponse
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param modelName ID or name of the deployed model   * @param body The input array
  */
  public void predictwithpreprocessjson (String deploymentName, String versionName, String modelName, List<String> body, final Response.Listener<JsonArrayResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling predictwithpreprocessjson",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling predictwithpreprocessjson"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling predictwithpreprocessjson",
        new ApiException(400, "Missing the required parameter 'versionName' when calling predictwithpreprocessjson"));
    }
    // verify the required parameter 'modelName' is set
    if (modelName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelName' when calling predictwithpreprocessjson",
        new ApiException(400, "Missing the required parameter 'modelName' when calling predictwithpreprocessjson"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling predictwithpreprocessjson",
        new ApiException(400, "Missing the required parameter 'body' when calling predictwithpreprocessjson"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocessjson".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "modelName" + "\\}", apiInvoker.escapeString(modelName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((JsonArrayResponse) ApiInvoker.deserialize(localVarResponse,  "", JsonArrayResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Runs inference based on the input data. Output is defined relative to the output adapter specified.
  * 
   * @param inputType Input data type.
   * @param outputType Binary output data type.
   * @param inputData The input file to upload.
   * @return void
  */
  public void rawPredictBinary (String inputType, String outputType, File inputData) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'inputType' is set
    if (inputType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputType' when calling rawPredictBinary",
        new ApiException(400, "Missing the required parameter 'inputType' when calling rawPredictBinary"));
    }
    // verify the required parameter 'outputType' is set
    if (outputType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'outputType' when calling rawPredictBinary",
        new ApiException(400, "Missing the required parameter 'outputType' when calling rawPredictBinary"));
    }

    // create path and map variables
    String path = "/raw/{inputType}/{outputType}".replaceAll("\\{" + "inputType" + "\\}", apiInvoker.escapeString(inputType.toString())).replaceAll("\\{" + "outputType" + "\\}", apiInvoker.escapeString(outputType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (inputData != null) {
        localVarBuilder.addBinaryBody("inputData", inputData);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Runs inference based on the input data. Output is defined relative to the output adapter specified.
   * 
   * @param inputType Input data type.   * @param outputType Binary output data type.   * @param inputData The input file to upload.
  */
  public void rawPredictBinary (String inputType, String outputType, File inputData, final Response.Listener<String> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'inputType' is set
    if (inputType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'inputType' when calling rawPredictBinary",
        new ApiException(400, "Missing the required parameter 'inputType' when calling rawPredictBinary"));
    }
    // verify the required parameter 'outputType' is set
    if (outputType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'outputType' when calling rawPredictBinary",
        new ApiException(400, "Missing the required parameter 'outputType' when calling rawPredictBinary"));
    }

    // create path and map variables
    String path = "/raw/{inputType}/{outputType}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "inputType" + "\\}", apiInvoker.escapeString(inputType.toString())).replaceAll("\\{" + "outputType" + "\\}", apiInvoker.escapeString(outputType.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (inputData != null) {
        localVarBuilder.addBinaryBody("inputData", inputData);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
              responseListener.onResponse(localVarResponse);
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Refresh the remote job status. Can be used for monitoring.
  * 
   * @param jobId Job ID
   * @return JobEntity
  */
  public JobEntity refreshJobStatus (Long jobId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'jobId' is set
    if (jobId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobId' when calling refreshJobStatus",
        new ApiException(400, "Missing the required parameter 'jobId' when calling refreshJobStatus"));
    }

    // create path and map variables
    String path = "/jobs/{jobId}/refresh".replaceAll("\\{" + "jobId" + "\\}", apiInvoker.escapeString(jobId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (JobEntity) ApiInvoker.deserialize(localVarResponse, "", JobEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Refresh the remote job status. Can be used for monitoring.
   * 
   * @param jobId Job ID
  */
  public void refreshJobStatus (Long jobId, final Response.Listener<JobEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'jobId' is set
    if (jobId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobId' when calling refreshJobStatus",
        new ApiException(400, "Missing the required parameter 'jobId' when calling refreshJobStatus"));
    }

    // create path and map variables
    String path = "/jobs/{jobId}/refresh".replaceAll("\\{format\\}","json").replaceAll("\\{" + "jobId" + "\\}", apiInvoker.escapeString(jobId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((JobEntity) ApiInvoker.deserialize(localVarResponse,  "", JobEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Register a new user
  * 
   * @param user User details
   * @return User
  */
  public User registerUser (User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = user;
    // verify the required parameter 'user' is set
    if (user == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'user' when calling registerUser",
        new ApiException(400, "Missing the required parameter 'user' when calling registerUser"));
    }

    // create path and map variables
    String path = "/user/register";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (User) ApiInvoker.deserialize(localVarResponse, "", User.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Register a new user
   * 
   * @param user User details
  */
  public void registerUser (User user, final Response.Listener<User> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = user;

    // verify the required parameter 'user' is set
    if (user == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'user' when calling registerUser",
        new ApiException(400, "Missing the required parameter 'user' when calling registerUser"));
    }

    // create path and map variables
    String path = "/user/register".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((User) ApiInvoker.deserialize(localVarResponse,  "", User.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Reimport a model to a previous deployed model in a deployment
  * 
   * @param deploymentId ID deployment group
   * @param modelId the id of the deployed model
   * @param body the deployment request
   * @return ModelEntity
  */
  public ModelEntity reimportModel (String deploymentId, String modelId, ImportModelRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling reimportModel",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling reimportModel"));
    }
    // verify the required parameter 'modelId' is set
    if (modelId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelId' when calling reimportModel",
        new ApiException(400, "Missing the required parameter 'modelId' when calling reimportModel"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling reimportModel",
        new ApiException(400, "Missing the required parameter 'body' when calling reimportModel"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model/{modelId}".replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString())).replaceAll("\\{" + "modelId" + "\\}", apiInvoker.escapeString(modelId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelEntity) ApiInvoker.deserialize(localVarResponse, "", ModelEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Reimport a model to a previous deployed model in a deployment
   * 
   * @param deploymentId ID deployment group   * @param modelId the id of the deployed model   * @param body the deployment request
  */
  public void reimportModel (String deploymentId, String modelId, ImportModelRequest body, final Response.Listener<ModelEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'deploymentId' is set
    if (deploymentId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentId' when calling reimportModel",
        new ApiException(400, "Missing the required parameter 'deploymentId' when calling reimportModel"));
    }
    // verify the required parameter 'modelId' is set
    if (modelId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelId' when calling reimportModel",
        new ApiException(400, "Missing the required parameter 'modelId' when calling reimportModel"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling reimportModel",
        new ApiException(400, "Missing the required parameter 'body' when calling reimportModel"));
    }

    // create path and map variables
    String path = "/deployment/{deploymentId}/model/{modelId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentId" + "\\}", apiInvoker.escapeString(deploymentId.toString())).replaceAll("\\{" + "modelId" + "\\}", apiInvoker.escapeString(modelId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Revoke a user token.
  * 
   * @param tokenId Token ID
   * @return Token
  */
  public Token revokeUserToken (Long tokenId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'tokenId' is set
    if (tokenId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'tokenId' when calling revokeUserToken",
        new ApiException(400, "Missing the required parameter 'tokenId' when calling revokeUserToken"));
    }

    // create path and map variables
    String path = "/auth/token/{tokenId}".replaceAll("\\{" + "tokenId" + "\\}", apiInvoker.escapeString(tokenId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Token) ApiInvoker.deserialize(localVarResponse, "", Token.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Revoke a user token.
   * 
   * @param tokenId Token ID
  */
  public void revokeUserToken (Long tokenId, final Response.Listener<Token> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'tokenId' is set
    if (tokenId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'tokenId' when calling revokeUserToken",
        new ApiException(400, "Missing the required parameter 'tokenId' when calling revokeUserToken"));
    }

    // create path and map variables
    String path = "/auth/token/{tokenId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "tokenId" + "\\}", apiInvoker.escapeString(tokenId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Token) ApiInvoker.deserialize(localVarResponse,  "", Token.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Rollback to a previous revision of the model.
  * 
   * @param index Model revision index.
   * @return RollbackStatus
  */
  public RollbackStatus rollback (Integer index) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'index' is set
    if (index == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'index' when calling rollback",
        new ApiException(400, "Missing the required parameter 'index' when calling rollback"));
    }

    // create path and map variables
    String path = "/rollback/{index}".replaceAll("\\{" + "index" + "\\}", apiInvoker.escapeString(index.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (RollbackStatus) ApiInvoker.deserialize(localVarResponse, "", RollbackStatus.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Rollback to a previous revision of the model.
   * 
   * @param index Model revision index.
  */
  public void rollback (Integer index, final Response.Listener<RollbackStatus> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'index' is set
    if (index == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'index' when calling rollback",
        new ApiException(400, "Missing the required parameter 'index' when calling rollback"));
    }

    // create path and map variables
    String path = "/rollback/{index}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "index" + "\\}", apiInvoker.escapeString(index.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((RollbackStatus) ApiInvoker.deserialize(localVarResponse,  "", RollbackStatus.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Start running an (already created) job on the remote resource
  * 
   * @param jobId Job ID
   * @return JobEntity
  */
  public JobEntity runAJob (Long jobId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'jobId' is set
    if (jobId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobId' when calling runAJob",
        new ApiException(400, "Missing the required parameter 'jobId' when calling runAJob"));
    }

    // create path and map variables
    String path = "/jobs/{jobId}/run".replaceAll("\\{" + "jobId" + "\\}", apiInvoker.escapeString(jobId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (JobEntity) ApiInvoker.deserialize(localVarResponse, "", JobEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Start running an (already created) job on the remote resource
   * 
   * @param jobId Job ID
  */
  public void runAJob (Long jobId, final Response.Listener<JobEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'jobId' is set
    if (jobId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'jobId' when calling runAJob",
        new ApiException(400, "Missing the required parameter 'jobId' when calling runAJob"));
    }

    // create path and map variables
    String path = "/jobs/{jobId}/run".replaceAll("\\{format\\}","json").replaceAll("\\{" + "jobId" + "\\}", apiInvoker.escapeString(jobId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((JobEntity) ApiInvoker.deserialize(localVarResponse,  "", JobEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord
  * Takes a batch of SingleCSVRecord object and transforms it into the desired format
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param transformName ID or name of the deployed transform
   * @param batchCSVRecord The input batch of record arrays
   * @return BatchCSVRecord
  */
  public BatchCSVRecord transformCsv (String deploymentName, String versionName, String transformName, BatchCSVRecord batchCSVRecord) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = batchCSVRecord;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformCsv",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformCsv"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformCsv",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformCsv"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformCsv",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformCsv"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transform".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (BatchCSVRecord) ApiInvoker.deserialize(localVarResponse, "", BatchCSVRecord.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord
   * Takes a batch of SingleCSVRecord object and transforms it into the desired format
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param transformName ID or name of the deployed transform   * @param batchCSVRecord The input batch of record arrays
  */
  public void transformCsv (String deploymentName, String versionName, String transformName, BatchCSVRecord batchCSVRecord, final Response.Listener<BatchCSVRecord> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = batchCSVRecord;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformCsv",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformCsv"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformCsv",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformCsv"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformCsv",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformCsv"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transform".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((BatchCSVRecord) ApiInvoker.deserialize(localVarResponse,  "", BatchCSVRecord.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Takes a batch input arrays and transforms it
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param transformName ID or name of the deployed transform
   * @param batchRecord The input batch of record arrays
   * @return Base64NDArrayBody
  */
  public Base64NDArrayBody transformarray (String deploymentName, String versionName, String transformName, BatchRecord batchRecord) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = batchRecord;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformarray",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformarray"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformarray",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformarray"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformarray",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformarray"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformarray".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse, "", Base64NDArrayBody.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Takes a batch input arrays and transforms it
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param transformName ID or name of the deployed transform   * @param batchRecord The input batch of record arrays
  */
  public void transformarray (String deploymentName, String versionName, String transformName, BatchRecord batchRecord, final Response.Listener<Base64NDArrayBody> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = batchRecord;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformarray",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformarray"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformarray",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformarray"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformarray",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformarray"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformarray".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse,  "", Base64NDArrayBody.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Takes multiple multipart image file to transform and returns Base64NDArrayBody
  * Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param imageTransformName ID or name of the deployed image transform
   * @param files The image files to upload
   * @return Base64NDArrayBody
  */
  public Base64NDArrayBody transformimage (String deploymentName, String versionName, String imageTransformName, List<File> files) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformimage"));
    }
    // verify the required parameter 'imageTransformName' is set
    if (imageTransformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'imageTransformName' when calling transformimage",
        new ApiException(400, "Missing the required parameter 'imageTransformName' when calling transformimage"));
    }
    // verify the required parameter 'files' is set
    if (files == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'files' when calling transformimage",
        new ApiException(400, "Missing the required parameter 'files' when calling transformimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformimage".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "imageTransformName" + "\\}", apiInvoker.escapeString(imageTransformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (files != null) {
        localVarBuilder.addBinaryBody("files", files);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse, "", Base64NDArrayBody.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Takes multiple multipart image file to transform and returns Base64NDArrayBody
   * Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param imageTransformName ID or name of the deployed image transform   * @param files The image files to upload
  */
  public void transformimage (String deploymentName, String versionName, String imageTransformName, List<File> files, final Response.Listener<Base64NDArrayBody> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformimage"));
    }
    // verify the required parameter 'imageTransformName' is set
    if (imageTransformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'imageTransformName' when calling transformimage",
        new ApiException(400, "Missing the required parameter 'imageTransformName' when calling transformimage"));
    }
    // verify the required parameter 'files' is set
    if (files == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'files' when calling transformimage",
        new ApiException(400, "Missing the required parameter 'files' when calling transformimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformimage".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "imageTransformName" + "\\}", apiInvoker.escapeString(imageTransformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (files != null) {
        localVarBuilder.addBinaryBody("files", files);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse,  "", Base64NDArrayBody.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord
  * Takes a SingleCSVRecord object and transforms it into the desired format
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param transformName ID or name of the deployed transform
   * @param singleCSVRecord The input record array
   * @return SingleCSVRecord
  */
  public SingleCSVRecord transformincrementalCsv (String deploymentName, String versionName, String transformName, SingleCSVRecord singleCSVRecord) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = singleCSVRecord;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformincrementalCsv",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformincrementalCsv"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformincrementalCsv",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformincrementalCsv"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformincrementalCsv",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformincrementalCsv"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincremental".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SingleCSVRecord) ApiInvoker.deserialize(localVarResponse, "", SingleCSVRecord.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord
   * Takes a SingleCSVRecord object and transforms it into the desired format
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param transformName ID or name of the deployed transform   * @param singleCSVRecord The input record array
  */
  public void transformincrementalCsv (String deploymentName, String versionName, String transformName, SingleCSVRecord singleCSVRecord, final Response.Listener<SingleCSVRecord> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = singleCSVRecord;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformincrementalCsv",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformincrementalCsv"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformincrementalCsv",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformincrementalCsv"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformincrementalCsv",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformincrementalCsv"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincremental".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SingleCSVRecord) ApiInvoker.deserialize(localVarResponse,  "", SingleCSVRecord.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Same as /transformincremental but returns Base64NDArrayBody.
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param transformName ID or name of the deployed transform
   * @param singleRecord The input record array
   * @return Base64NDArrayBody
  */
  public Base64NDArrayBody transformincrementalarray (String deploymentName, String versionName, String transformName, SingleRecord singleRecord) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = singleRecord;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformincrementalarray",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformincrementalarray"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformincrementalarray",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformincrementalarray"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformincrementalarray",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformincrementalarray"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincrementalarray".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse, "", Base64NDArrayBody.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Same as /transformincremental but returns Base64NDArrayBody.
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param transformName ID or name of the deployed transform   * @param singleRecord The input record array
  */
  public void transformincrementalarray (String deploymentName, String versionName, String transformName, SingleRecord singleRecord, final Response.Listener<Base64NDArrayBody> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = singleRecord;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformincrementalarray",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformincrementalarray"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformincrementalarray",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformincrementalarray"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformincrementalarray",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformincrementalarray"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincrementalarray".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse,  "", Base64NDArrayBody.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Takes a single multipart image file to transform and returns Base64NDArrayBody
  * Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param imageTransformName ID or name of the deployed image transform
   * @param file The image file to upload
   * @return Base64NDArrayBody
  */
  public Base64NDArrayBody transformincrementalimage (String deploymentName, String versionName, String imageTransformName, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformincrementalimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformincrementalimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformincrementalimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformincrementalimage"));
    }
    // verify the required parameter 'imageTransformName' is set
    if (imageTransformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'imageTransformName' when calling transformincrementalimage",
        new ApiException(400, "Missing the required parameter 'imageTransformName' when calling transformincrementalimage"));
    }
    // verify the required parameter 'file' is set
    if (file == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'file' when calling transformincrementalimage",
        new ApiException(400, "Missing the required parameter 'file' when calling transformincrementalimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformincrementalimage".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "imageTransformName" + "\\}", apiInvoker.escapeString(imageTransformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse, "", Base64NDArrayBody.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Takes a single multipart image file to transform and returns Base64NDArrayBody
   * Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param imageTransformName ID or name of the deployed image transform   * @param file The image file to upload
  */
  public void transformincrementalimage (String deploymentName, String versionName, String imageTransformName, File file, final Response.Listener<Base64NDArrayBody> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformincrementalimage",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformincrementalimage"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformincrementalimage",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformincrementalimage"));
    }
    // verify the required parameter 'imageTransformName' is set
    if (imageTransformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'imageTransformName' when calling transformincrementalimage",
        new ApiException(400, "Missing the required parameter 'imageTransformName' when calling transformincrementalimage"));
    }
    // verify the required parameter 'file' is set
    if (file == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'file' when calling transformincrementalimage",
        new ApiException(400, "Missing the required parameter 'file' when calling transformincrementalimage"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformincrementalimage".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "imageTransformName" + "\\}", apiInvoker.escapeString(imageTransformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Base64NDArrayBody) ApiInvoker.deserialize(localVarResponse,  "", Base64NDArrayBody.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Gets the JSON string of the deployed transform process (CSV or Image)
  * 
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param transformName ID or name of the deployed transform
   * @return Object
  */
  public Object transformprocessGet (String deploymentName, String versionName, String transformName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformprocessGet",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformprocessGet"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformprocessGet",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformprocessGet"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformprocessGet",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformprocessGet"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Object) ApiInvoker.deserialize(localVarResponse, "", Object.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Gets the JSON string of the deployed transform process (CSV or Image)
   * 
   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param transformName ID or name of the deployed transform
  */
  public void transformprocessGet (String deploymentName, String versionName, String transformName, final Response.Listener<Object> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformprocessGet",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformprocessGet"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformprocessGet",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformprocessGet"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformprocessGet",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformprocessGet"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Object) ApiInvoker.deserialize(localVarResponse,  "", Object.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Sets the deployed (CSV or Image) transform process through the provided JSON string
  * 
   * @param contentType The &#x60;Content-Type&#x60; should be &#x60;application/json&#x60;.
   * @param deploymentName Name of the deployment group
   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;
   * @param transformName ID or name of the deployed transform
   * @param transformProcess The transform process to set (Specify a JSON string here).
   * @return Object
  */
  public Object transformprocessPost (String contentType, String deploymentName, String versionName, String transformName, String transformProcess) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = transformProcess;
    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling transformprocessPost",
        new ApiException(400, "Missing the required parameter 'contentType' when calling transformprocessPost"));
    }
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformprocessPost",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformprocessPost"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformprocessPost",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformprocessPost"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformprocessPost",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformprocessPost"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess".replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));
    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Object) ApiInvoker.deserialize(localVarResponse, "", Object.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Sets the deployed (CSV or Image) transform process through the provided JSON string
   * 
   * @param contentType The &#x60;Content-Type&#x60; should be &#x60;application/json&#x60;.   * @param deploymentName Name of the deployment group   * @param versionName Version name of the endpoint. The default value is \&quot;default\&quot;   * @param transformName ID or name of the deployed transform   * @param transformProcess The transform process to set (Specify a JSON string here).
  */
  public void transformprocessPost (String contentType, String deploymentName, String versionName, String transformName, String transformProcess, final Response.Listener<Object> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = transformProcess;

    // verify the required parameter 'contentType' is set
    if (contentType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'contentType' when calling transformprocessPost",
        new ApiException(400, "Missing the required parameter 'contentType' when calling transformprocessPost"));
    }
    // verify the required parameter 'deploymentName' is set
    if (deploymentName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'deploymentName' when calling transformprocessPost",
        new ApiException(400, "Missing the required parameter 'deploymentName' when calling transformprocessPost"));
    }
    // verify the required parameter 'versionName' is set
    if (versionName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'versionName' when calling transformprocessPost",
        new ApiException(400, "Missing the required parameter 'versionName' when calling transformprocessPost"));
    }
    // verify the required parameter 'transformName' is set
    if (transformName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transformName' when calling transformprocessPost",
        new ApiException(400, "Missing the required parameter 'transformName' when calling transformprocessPost"));
    }

    // create path and map variables
    String path = "/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess".replaceAll("\\{format\\}","json").replaceAll("\\{" + "deploymentName" + "\\}", apiInvoker.escapeString(deploymentName.toString())).replaceAll("\\{" + "versionName" + "\\}", apiInvoker.escapeString(versionName.toString())).replaceAll("\\{" + "transformName" + "\\}", apiInvoker.escapeString(transformName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();


    headerParams.put("Content-Type", ApiInvoker.parameterToString(contentType));

    String[] contentTypes = {
      "text/plain"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Object) ApiInvoker.deserialize(localVarResponse,  "", Object.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update auth policy
  * 
   * @param authPolicy Auth policy object
   * @return AuthPolicy
  */
  public AuthPolicy updateAuthPolicy (AuthPolicy authPolicy) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = authPolicy;
    // verify the required parameter 'authPolicy' is set
    if (authPolicy == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'authPolicy' when calling updateAuthPolicy",
        new ApiException(400, "Missing the required parameter 'authPolicy' when calling updateAuthPolicy"));
    }

    // create path and map variables
    String path = "/auth/policy";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AuthPolicy) ApiInvoker.deserialize(localVarResponse, "", AuthPolicy.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update auth policy
   * 
   * @param authPolicy Auth policy object
  */
  public void updateAuthPolicy (AuthPolicy authPolicy, final Response.Listener<AuthPolicy> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = authPolicy;

    // verify the required parameter 'authPolicy' is set
    if (authPolicy == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'authPolicy' when calling updateAuthPolicy",
        new ApiException(400, "Missing the required parameter 'authPolicy' when calling updateAuthPolicy"));
    }

    // create path and map variables
    String path = "/auth/policy".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AuthPolicy) ApiInvoker.deserialize(localVarResponse,  "", AuthPolicy.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Updates the best model for an experiment
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param updateBestModel Model encapsulating the experiment id to update and the best model id.
   * @return ExperimentEntity
  */
  public ExperimentEntity updateBestModelForExperiment (String modelHistoryServerId, UpdateBestModel updateBestModel) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = updateBestModel;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling updateBestModelForExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling updateBestModelForExperiment"));
    }
    // verify the required parameter 'updateBestModel' is set
    if (updateBestModel == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'updateBestModel' when calling updateBestModelForExperiment",
        new ApiException(400, "Missing the required parameter 'updateBestModel' when calling updateBestModelForExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/best".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ExperimentEntity) ApiInvoker.deserialize(localVarResponse, "", ExperimentEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Updates the best model for an experiment
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param updateBestModel Model encapsulating the experiment id to update and the best model id.
  */
  public void updateBestModelForExperiment (String modelHistoryServerId, UpdateBestModel updateBestModel, final Response.Listener<ExperimentEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = updateBestModel;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling updateBestModelForExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling updateBestModelForExperiment"));
    }
    // verify the required parameter 'updateBestModel' is set
    if (updateBestModel == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'updateBestModel' when calling updateBestModelForExperiment",
        new ApiException(400, "Missing the required parameter 'updateBestModel' when calling updateBestModelForExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/best".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ExperimentEntity) ApiInvoker.deserialize(localVarResponse,  "", ExperimentEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Updates an experiment, given an experiment entity
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param experimentID the GUID of the experiment to update
   * @param experimentEntity The experiment entity to update with
   * @return ExperimentEntity
  */
  public ExperimentEntity updateExperiment (String modelHistoryServerId, String experimentID, ExperimentEntity experimentEntity) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = experimentEntity;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling updateExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling updateExperiment"));
    }
    // verify the required parameter 'experimentID' is set
    if (experimentID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentID' when calling updateExperiment",
        new ApiException(400, "Missing the required parameter 'experimentID' when calling updateExperiment"));
    }
    // verify the required parameter 'experimentEntity' is set
    if (experimentEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentEntity' when calling updateExperiment",
        new ApiException(400, "Missing the required parameter 'experimentEntity' when calling updateExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/{experimentID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "experimentID" + "\\}", apiInvoker.escapeString(experimentID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ExperimentEntity) ApiInvoker.deserialize(localVarResponse, "", ExperimentEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Updates an experiment, given an experiment entity
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param experimentID the GUID of the experiment to update   * @param experimentEntity The experiment entity to update with
  */
  public void updateExperiment (String modelHistoryServerId, String experimentID, ExperimentEntity experimentEntity, final Response.Listener<ExperimentEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = experimentEntity;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling updateExperiment",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling updateExperiment"));
    }
    // verify the required parameter 'experimentID' is set
    if (experimentID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentID' when calling updateExperiment",
        new ApiException(400, "Missing the required parameter 'experimentID' when calling updateExperiment"));
    }
    // verify the required parameter 'experimentEntity' is set
    if (experimentEntity == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'experimentEntity' when calling updateExperiment",
        new ApiException(400, "Missing the required parameter 'experimentEntity' when calling updateExperiment"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/experiment/{experimentID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "experimentID" + "\\}", apiInvoker.escapeString(experimentID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ExperimentEntity) ApiInvoker.deserialize(localVarResponse,  "", ExperimentEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update a model history / workspace
  * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.
   * @param modelHistoryID the GUID of the model history / workspace to update
   * @param updateModelHistoryRequest The model history request object
   * @return ModelHistoryEntity
  */
  public ModelHistoryEntity updateModelHistory (String modelHistoryServerId, String modelHistoryID, AddModelHistoryRequest updateModelHistoryRequest) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = updateModelHistoryRequest;
    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling updateModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling updateModelHistory"));
    }
    // verify the required parameter 'modelHistoryID' is set
    if (modelHistoryID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryID' when calling updateModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryID' when calling updateModelHistory"));
    }
    // verify the required parameter 'updateModelHistoryRequest' is set
    if (updateModelHistoryRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'updateModelHistoryRequest' when calling updateModelHistory",
        new ApiException(400, "Missing the required parameter 'updateModelHistoryRequest' when calling updateModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}".replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelHistoryID" + "\\}", apiInvoker.escapeString(modelHistoryID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ModelHistoryEntity) ApiInvoker.deserialize(localVarResponse, "", ModelHistoryEntity.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update a model history / workspace
   * 
   * @param modelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID.   * @param modelHistoryID the GUID of the model history / workspace to update   * @param updateModelHistoryRequest The model history request object
  */
  public void updateModelHistory (String modelHistoryServerId, String modelHistoryID, AddModelHistoryRequest updateModelHistoryRequest, final Response.Listener<ModelHistoryEntity> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = updateModelHistoryRequest;

    // verify the required parameter 'modelHistoryServerId' is set
    if (modelHistoryServerId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryServerId' when calling updateModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryServerId' when calling updateModelHistory"));
    }
    // verify the required parameter 'modelHistoryID' is set
    if (modelHistoryID == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'modelHistoryID' when calling updateModelHistory",
        new ApiException(400, "Missing the required parameter 'modelHistoryID' when calling updateModelHistory"));
    }
    // verify the required parameter 'updateModelHistoryRequest' is set
    if (updateModelHistoryRequest == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'updateModelHistoryRequest' when calling updateModelHistory",
        new ApiException(400, "Missing the required parameter 'updateModelHistoryRequest' when calling updateModelHistory"));
    }

    // create path and map variables
    String path = "/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "modelHistoryServerId" + "\\}", apiInvoker.escapeString(modelHistoryServerId.toString())).replaceAll("\\{" + "modelHistoryID" + "\\}", apiInvoker.escapeString(modelHistoryID.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ModelHistoryEntity) ApiInvoker.deserialize(localVarResponse,  "", ModelHistoryEntity.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update a user
  * 
   * @param user User details
   * @return User
  */
  public User updateUser (User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = user;
    // verify the required parameter 'user' is set
    if (user == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'user' when calling updateUser",
        new ApiException(400, "Missing the required parameter 'user' when calling updateUser"));
    }

    // create path and map variables
    String path = "/user";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (User) ApiInvoker.deserialize(localVarResponse, "", User.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update a user
   * 
   * @param user User details
  */
  public void updateUser (User user, final Response.Listener<User> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = user;

    // verify the required parameter 'user' is set
    if (user == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'user' when calling updateUser",
        new ApiException(400, "Missing the required parameter 'user' when calling updateUser"));
    }

    // create path and map variables
    String path = "/user".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "application/json"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((User) ApiInvoker.deserialize(localVarResponse,  "", User.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Upload a model file to SKIL for import.
  * 
   * @param file The file to upload.
   * @return FileUploadList
  */
  public FileUploadList upload (File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/api/upload/model";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (FileUploadList) ApiInvoker.deserialize(localVarResponse, "", FileUploadList.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Upload a model file to SKIL for import.
   * 
   * @param file The file to upload.
  */
  public void upload (File file, final Response.Listener<FileUploadList> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/api/upload/model".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      "multipart/form-data"
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      
      if (file != null) {
        localVarBuilder.addBinaryBody("file", file);
      }
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    String[] authNames = new String[] { "api_key", "x_api_key" };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((FileUploadList) ApiInvoker.deserialize(localVarResponse,  "", FileUploadList.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
